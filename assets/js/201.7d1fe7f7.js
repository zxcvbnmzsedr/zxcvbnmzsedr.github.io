(window.webpackJsonp=window.webpackJsonp||[]).push([[201],{530:function(t,s,n){"use strict";n.r(s);var a=n(7),e=Object(a.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"hash的底层实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hash的底层实现"}},[t._v("#")]),t._v(" Hash的底层实现")]),t._v(" "),s("p",[t._v("Hash的底层编码格式是HashTable和ZipList。")]),t._v(" "),s("p",[t._v("Hash底层存储结构HashTable和ZipLit会互相转化。")]),t._v(" "),s("p",[t._v("控制他们转化的参数:")]),t._v(" "),s("ol",[s("li",[t._v("hash-max-ziplist-entries,默认512,使用压缩列表保存时哈希集合中的最大元素个数。")]),t._v(" "),s("li",[t._v("hash-max-ziplist-value,默认64,使用压缩列表保存时哈希集合中单个元素的最大长度。")])]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("redis"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" config get hash*\n        hash-max-ziplist-entries\n        "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("512")]),t._v("\n        hash-max-ziplist-value\n        "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("64")]),t._v("\n")])])]),s("p",[t._v("当哈希对象同时符合下面两个条件时，将使用 ziplist 编码：")]),t._v(" "),s("ol",[s("li",[t._v("哈希对象保存的所有键值对中，键和值的字符串长度都小于 64 个字节；")]),t._v(" "),s("li",[t._v("哈希对象保存的键值对数量小于 512 个。")])]),t._v(" "),s("p",[t._v("ZipList可以转换到HashTable，一旦从ZipList转为了HashTable，Hash类型就会一直用HashTable进行保存而不会再转回ZipList了。")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("hashTypeConvert")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("robj "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("o"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" enc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 原始编码是ZipList才进行转换")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("o"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("encoding "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" OBJ_ENCODING_ZIPLIST"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("hashTypeConvertZiplist")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("o"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" enc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("o"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("encoding "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" OBJ_ENCODING_HT"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 无法降级到ZipList")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("serverPanic")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Not implemented"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("serverPanic")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Unknown hash encoding"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h1",{attrs:{id:"ziplist编码的哈希对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ziplist编码的哈希对象"}},[t._v("#")]),t._v(" ZipList编码的哈希对象")]),t._v(" "),s("ol",[s("li",[t._v("普通的双向链表会有两个指针，在存储数据很小的情况下， 我们存储的实际数据的大小可能还没有指针占用的内存大，得不偿失 。\nziplist是一个特殊的双向链表没有维护双向指针:prev next；而是存储上一个 entry的长度和 当前entry的长度，通过长度推算下一个元素在什么地方。\n牺牲读取的性能，获得高效的存储空间，因为(简短字符串的情况)存储指针比存储entry长度更费内存。这是典型的“时间换空间”。")]),t._v(" "),s("li",[t._v("链表在内存中一般是不连续的，遍历相对比较慢，而ziplist可以很好的解决这个问题，普通数组的遍历是根据数组里存储的数据类型找到下一个元素的，但是ziplist的每个节点的长度是可以不一样的，而我们面对不同长度的节点又不可能直接sizeof(entry)，所以ziplist只好将一些必要的偏移量信息记录在了每一个节点里，使之能跳到上一个节点或下一个节点。")]),t._v(" "),s("li",[t._v("头节点里有头节点里同时还有一个参数 len，和string类型提到的 SDS 类似，这里是用来记录链表长度的。因此 获取链表长度时不用再遍历整个链表,直接拿到len值就可以了，这个时间复杂度是 O(1)")])]),t._v(" "),s("p",[t._v("ZipList的总体布局如下:"),s("br"),t._v("\n因为压缩列表的操作中涉及到的位运算很多，如果不统一的话会出现混乱。后续的所有位运算都是在小端存储的基础上进行的")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://www.shiyitopo.tech/uPic/redis_ziplist_%E7%BB%93%E6%9E%84.png",alt:"redis_ziplist_结构"}})]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("typedef struct zlentry "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    /**\n     * 前一个节点大小\n     */\n    unsigned int prevrawlensize"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    /**\n     * 前一个节点长度\n     */\n    unsigned int prevrawlen"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    /**\n     * 当前节点大小\n     */\n    unsigned int lensize"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    /**\n     * 当前节点长度\n     */\n    unsigned int len"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    /**\n     * 当前节点头部信息长度\n     */\n    unsigned int headersize"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   \n    /**\n     * 当前节点数据编码  ZIP_STR_* or ZIP_INT_*\n     */\n    unsigned char encoding"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  \n    /**\n     * 指向节点的指针 \n     */    \n    unsigned char *p"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" zlentry"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h1",{attrs:{id:"hashtable对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashtable对象"}},[t._v("#")]),t._v(" hashtable对象")]),t._v(" "),s("p",[t._v("hashtable 被称为字典（dictionary），它是一个数组+链表的结构.")]),t._v(" "),s("p",[t._v("哈希条目")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("typedef struct dictEntry "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    void *key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    union "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        void *val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        uint64_t u64"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        int64_t s64"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        double d"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("v")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    struct dictEntry *next"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" dictEntry"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("字典对象")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("typedef struct dict "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    dictType *type"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    void *privdata"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    dictht ht"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    long rehashidx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" /* rehashing not "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" progress "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" rehashidx "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-1")]),t._v(" */\n    unsigned long iterators"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" /* number of iterators currently running */\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" dict"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])])}),[],!1,null,null,null);s.default=e.exports}}]);