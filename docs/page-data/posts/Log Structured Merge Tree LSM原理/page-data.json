{
    "componentChunkName": "component---src-templates-article-page-template-tsx",
    "path": "/posts/Log Structured Merge Tree LSM原理",
    "result": {"pageContext":{"id":"/posts/Log Structured Merge Tree LSM原理","htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"最近在看Google十年前发表的"},{"type":"element","tagName":"a","properties":{"href":"/topic/%E5%88%86%E5%B8%83%E5%BC%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/%E4%B8%89%E9%A9%BE%E9%A9%AC%E8%BD%A6/BigTable%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91"},"children":[{"type":"text","value":"BigTable论文"}]},{"type":"text","value":"，BigTable这玩意，最骚的一点就是改变了大多数传统数据库所使用的文件组织方法,业界对这种新一代的文件组织方法进行了实现，叫做Log Structured Merge Tree，简称LSM，中文叫做"},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"日志结构的合并树。"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　LSM目前被用于多个面向大数据的数据库产品: HBase、Cassandra、LevelDB等。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"诞生背景"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　无论B树和B+树在写入的时候，为了能处理数据库异常崩溃的场景，通常都会有额外的结构，学名叫做"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"预写式日志"}]},{"type":"text","value":"(WAL，write-ahead log)，在Mysql 中叫做 redo log。在写入数据之前，会将操作都写入这个redo log(这个文件在磁盘上)，然后再从这个redo log中将数据同步到具体的B树中。这样即使数据库发生崩溃，也能够通过这个日志文件，让B树恢复到一致的状态。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　但是B树难以应对并发操作的情况，在多个线程同时访问B树的时候需要加锁，需要保证树的结构是一致和完整的，否则不同的线程就会看到树处于不一致的状态。Msql会有各个隔离级别和各种锁，也是因为这个原因。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　为了加快写入的速度，就诞生了LSM这个算法。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　LSM的思想，在对于数据修改采用增量的方式保存在内存中，内存容量达到指定的限制时就将操作的数据批量写入到磁盘(SSTable，Sorted String Table)中，相比较于写入操作的高性能，读取操作需要合并内存中最近修改的操作和磁盘中的历史数据，需要先看内存，如果没有命中还要访问磁盘文件。将之前使用一个大的查找结构（造成随机读写，影响写性能），变换为将写操作顺序的保存到一些相似的有序文件（也就是sstable)中。所以每个文件包含短时间内的一些改动。因为文件是有序的，所以之后查找也会很快。文件是不可修改的，他们永远不会被更新，新的更新操作只会写到新的文件中。通过周期性的合并这些文件来减少文件个数。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"B树对比LSM树"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　B树在写入的时候至少会被写入两次，一次是WAL(redo log)，另一次是树结构本身。即使树只有几个字节的变化，也需要接受整个页面写入的开销。如果一张表存在多个索引树，那肯定会对硬盘造成多次写入。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　一次数据库操作导入对磁盘上的文件多次写入，被称之为写放大。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　LSM树会有更低的写放大，因为磁盘上的SSTable是顺序且紧凑的而不是必须复写树结构。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　而且LSM树可以对文件进行压缩和排序，这是SSTable的特性所决定的，Stored String Table中的数据是可排序的，也就意味着可以用前缀树来进行排序。然后由于sstable文件是不可修改的，这让对他们的锁操作非常简单。一般来说，唯一的竞争资源就是memtable，相对来说需要相对复杂的锁机制来管理在不同的级别。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"LSM树"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　LSM本质上并不是一种树，而是一种文件组织的形式，将数据进行一个分层以便于获得更好的性能。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　从结构上分为两类，一种是存储在内存中的Memtable，另一种则是存储在磁盘中的SSTable。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　"},{"type":"element","tagName":"img","properties":{"src":"https://image.ztianzeng.com/uPic/20220518153629.png","alt":""},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　一般简单的都会划分为两层，Level 0 是存储在内存上的Memtable，Level 0以上则是存在磁盘中的SSTable"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"基本原理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"写入操作"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"当一些更新操作到达时，他们会被写到内存缓存（也就是memtable）中，memtable使用树结构来保持key的有序."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在大部分的实现中，memtable会通过写WAL的方式备份到磁盘，用来恢复数据，防止数据丢失。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"当memtable数据达到一定规模时会被刷新到磁盘上的一个新文件，重要的是系统只做了顺序磁盘读写，因为没有文件被编辑，新的内容或者修改只用简单的生成新的文件。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"合并文件"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以越多的数据存储到系统中，就会有越多的不可修改的，顺序的sstable文件被创建，它们代表了小的，按时间顺序的修改。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因为比较旧的文件不会被更新，重复的记录只会通过创建新的记录来覆盖，这也就产生了一些冗余的数据。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以系统会周期的执行合并操作（compaction)。 合并操作选择一些文件，并把他们合并到一起，移除重复的更新或者删除记录，同时也会删除上述的冗余。更重要的是，通过减少文件个数的增长，保证读操作的性 能。因为sstable文件都是有序结构的，所以合并操作也是非常高效的。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"读操作"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"读操作优先判断key是否在MemTable, 如果不在的话，则把覆盖该key range的所有SSTable都查找一遍。简单，但是低效。因此，在工程实现上，一般会为SSTable加入索引。可以是一个key-offset索引（类似于kafka的index文件），也可以是布隆过滤器（Bloom Filter）。布隆过滤器有一个特性：如果bloom说一个key不存在，就一定不存在，而当bloom说一个key存在于这个文件，可能是不存在的。实现层面上，布隆过滤器就是"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"key--比特位"}]},{"type":"text","value":"的映射。理想情况下，当然是一个key对应一个比特实现全映射，但是太消耗内存。因此，一般通过控制假阳性概率来节约内存，代价是牺牲了一定的读性能。对于我们的应用场景，我们将该概率从0.99降低到0.8，布隆过滤器的内存消耗从2GB+下降到了300MB，数据读取速度有所降低，但在感知层面可忽略。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"总结"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　LSM Tree 思想是把随机写入转化成顺序写入，这样可以大幅度提升写入的性能，但是查询性能会有一部分牺牲。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　在时序数据库运用这一特性非常合适。持续写入数据量大，数据和时间，将时间编码到 key 值中很容易使 key 值有序。读取操作通常是根据某个Key的值，去获取一段时间范围内的数据。这样就把 LSM Tree 读取性能差的劣势缩小了，反而因为数据在 SSTable 中是按照 key 值顺序排列，读取大块连续的数据时效率也很高。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"style","properties":{"className":["grvsc-styles"]},"children":[{"type":"text","value":"\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n"}]}],"data":{"quirksMode":false}},"html":"<p updated=\"20220808111208\">　　最近在看Google十年前发表的<a href=\"/topic/分布式解决方案/分布式理论/三驾马车/BigTable中文翻译\">BigTable论文</a>，BigTable这玩意，最骚的一点就是改变了大多数传统数据库所使用的文件组织方法,业界对这种新一代的文件组织方法进行了实现，叫做Log Structured Merge Tree，简称LSM，中文叫做<em>日志结构的合并树。</em></p>\n<p updated=\"20220808111208\">　　LSM目前被用于多个面向大数据的数据库产品: HBase、Cassandra、LevelDB等。</p>\n<h1 id=\"诞生背景\">诞生背景</h1>\n<p updated=\"20220808111208\">　　无论B树和B+树在写入的时候，为了能处理数据库异常崩溃的场景，通常都会有额外的结构，学名叫做<strong>预写式日志</strong>(WAL，write-ahead log)，在Mysql 中叫做 redo log。在写入数据之前，会将操作都写入这个redo log(这个文件在磁盘上)，然后再从这个redo log中将数据同步到具体的B树中。这样即使数据库发生崩溃，也能够通过这个日志文件，让B树恢复到一致的状态。</p>\n<p updated=\"20220808111208\">　　但是B树难以应对并发操作的情况，在多个线程同时访问B树的时候需要加锁，需要保证树的结构是一致和完整的，否则不同的线程就会看到树处于不一致的状态。Msql会有各个隔离级别和各种锁，也是因为这个原因。</p>\n<p updated=\"20220808111208\">　　为了加快写入的速度，就诞生了LSM这个算法。</p>\n<p updated=\"20220808111208\">　　LSM的思想，在对于数据修改采用增量的方式保存在内存中，内存容量达到指定的限制时就将操作的数据批量写入到磁盘(SSTable，Sorted String Table)中，相比较于写入操作的高性能，读取操作需要合并内存中最近修改的操作和磁盘中的历史数据，需要先看内存，如果没有命中还要访问磁盘文件。将之前使用一个大的查找结构（造成随机读写，影响写性能），变换为将写操作顺序的保存到一些相似的有序文件（也就是sstable)中。所以每个文件包含短时间内的一些改动。因为文件是有序的，所以之后查找也会很快。文件是不可修改的，他们永远不会被更新，新的更新操作只会写到新的文件中。通过周期性的合并这些文件来减少文件个数。</p>\n<h2 id=\"B树对比LSM树\">B树对比LSM树</h2>\n<p updated=\"20220808111208\">　　B树在写入的时候至少会被写入两次，一次是WAL(redo log)，另一次是树结构本身。即使树只有几个字节的变化，也需要接受整个页面写入的开销。如果一张表存在多个索引树，那肯定会对硬盘造成多次写入。</p>\n<p updated=\"20220808111208\">　　一次数据库操作导入对磁盘上的文件多次写入，被称之为写放大。</p>\n<p updated=\"20220808111208\">　　LSM树会有更低的写放大，因为磁盘上的SSTable是顺序且紧凑的而不是必须复写树结构。</p>\n<p updated=\"20220808111208\">　　而且LSM树可以对文件进行压缩和排序，这是SSTable的特性所决定的，Stored String Table中的数据是可排序的，也就意味着可以用前缀树来进行排序。然后由于sstable文件是不可修改的，这让对他们的锁操作非常简单。一般来说，唯一的竞争资源就是memtable，相对来说需要相对复杂的锁机制来管理在不同的级别。</p>\n<h1 id=\"LSM树\">LSM树</h1>\n<p updated=\"20220808111208\">　　LSM本质上并不是一种树，而是一种文件组织的形式，将数据进行一个分层以便于获得更好的性能。</p>\n<p updated=\"20220808111208\">　　从结构上分为两类，一种是存储在内存中的Memtable，另一种则是存储在磁盘中的SSTable。</p>\n<p updated=\"20220808111208\">　　<span class=\"img\"><img src=\"https://image.ztianzeng.com/uPic/20220518153629.png\" alt=\"\" /></span></p>\n<p updated=\"20220808111208\">　　一般简单的都会划分为两层，Level 0 是存储在内存上的Memtable，Level 0以上则是存在磁盘中的SSTable</p>\n<h2 id=\"基本原理\">基本原理</h2>\n<ul updated=\"20220808111208\">\n<li id=\"20220808111208-5cpw9ar\" updated=\"20220808111208\">\n<p updated=\"20220808111208\">写入操作</p>\n<p updated=\"20220808111208\">当一些更新操作到达时，他们会被写到内存缓存（也就是memtable）中，memtable使用树结构来保持key的有序.</p>\n<p updated=\"20220808111208\">在大部分的实现中，memtable会通过写WAL的方式备份到磁盘，用来恢复数据，防止数据丢失。</p>\n<p updated=\"20220808111208\">当memtable数据达到一定规模时会被刷新到磁盘上的一个新文件，重要的是系统只做了顺序磁盘读写，因为没有文件被编辑，新的内容或者修改只用简单的生成新的文件。</p>\n</li>\n<li id=\"20220808111208-2n4fage\" updated=\"20220808111208\">\n<p updated=\"20220808111208\">合并文件</p>\n<p updated=\"20220808111208\">所以越多的数据存储到系统中，就会有越多的不可修改的，顺序的sstable文件被创建，它们代表了小的，按时间顺序的修改。</p>\n<p updated=\"20220808111208\">因为比较旧的文件不会被更新，重复的记录只会通过创建新的记录来覆盖，这也就产生了一些冗余的数据。</p>\n<p updated=\"20220808111208\">所以系统会周期的执行合并操作（compaction)。 合并操作选择一些文件，并把他们合并到一起，移除重复的更新或者删除记录，同时也会删除上述的冗余。更重要的是，通过减少文件个数的增长，保证读操作的性 能。因为sstable文件都是有序结构的，所以合并操作也是非常高效的。</p>\n</li>\n<li id=\"20220808111208-1ptlc1f\" updated=\"20220808111208\">\n<p updated=\"20220808111208\">读操作</p>\n<p updated=\"20220808111208\">读操作优先判断key是否在MemTable, 如果不在的话，则把覆盖该key range的所有SSTable都查找一遍。简单，但是低效。因此，在工程实现上，一般会为SSTable加入索引。可以是一个key-offset索引（类似于kafka的index文件），也可以是布隆过滤器（Bloom Filter）。布隆过滤器有一个特性：如果bloom说一个key不存在，就一定不存在，而当bloom说一个key存在于这个文件，可能是不存在的。实现层面上，布隆过滤器就是<code>key--比特位</code>的映射。理想情况下，当然是一个key对应一个比特实现全映射，但是太消耗内存。因此，一般通过控制假阳性概率来节约内存，代价是牺牲了一定的读性能。对于我们的应用场景，我们将该概率从0.99降低到0.8，布隆过滤器的内存消耗从2GB+下降到了300MB，数据读取速度有所降低，但在感知层面可忽略。</p>\n</li>\n</ul>\n<h1 id=\"总结\">总结</h1>\n<p updated=\"20220808111208\">　　LSM Tree 思想是把随机写入转化成顺序写入，这样可以大幅度提升写入的性能，但是查询性能会有一部分牺牲。</p>\n<p updated=\"20220808111208\">　　在时序数据库运用这一特性非常合适。持续写入数据量大，数据和时间，将时间编码到 key 值中很容易使 key 值有序。读取操作通常是根据某个Key的值，去获取一段时间范围内的数据。这样就把 LSM Tree 读取性能差的劣势缩小了，反而因为数据在 SSTable 中是按照 key 值顺序排列，读取大块连续的数据时效率也很高。</p>\n","articleNode":{"field":{"contentType":"posts","topic":null},"frontmatter":{"id":"/posts/Log Structured Merge Tree LSM原理","title":"Log Structured Merge Tree LSM原理","date":"2022-05-18 11:01","absolute_path":"/posts/Log Structured Merge Tree LSM原理"},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"最近在看Google十年前发表的"},{"type":"element","tagName":"a","properties":{"href":"/topic/%E5%88%86%E5%B8%83%E5%BC%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/%E4%B8%89%E9%A9%BE%E9%A9%AC%E8%BD%A6/BigTable%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91"},"children":[{"type":"text","value":"BigTable论文"}]},{"type":"text","value":"，BigTable这玩意，最骚的一点就是改变了大多数传统数据库所使用的文件组织方法,业界对这种新一代的文件组织方法进行了实现，叫做Log Structured Merge Tree，简称LSM，中文叫做"},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"日志结构的合并树。"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　LSM目前被用于多个面向大数据的数据库产品: HBase、Cassandra、LevelDB等。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"诞生背景"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　无论B树和B+树在写入的时候，为了能处理数据库异常崩溃的场景，通常都会有额外的结构，学名叫做"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"预写式日志"}]},{"type":"text","value":"(WAL，write-ahead log)，在Mysql 中叫做 redo log。在写入数据之前，会将操作都写入这个redo log(这个文件在磁盘上)，然后再从这个redo log中将数据同步到具体的B树中。这样即使数据库发生崩溃，也能够通过这个日志文件，让B树恢复到一致的状态。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　但是B树难以应对并发操作的情况，在多个线程同时访问B树的时候需要加锁，需要保证树的结构是一致和完整的，否则不同的线程就会看到树处于不一致的状态。Msql会有各个隔离级别和各种锁，也是因为这个原因。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　为了加快写入的速度，就诞生了LSM这个算法。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　LSM的思想，在对于数据修改采用增量的方式保存在内存中，内存容量达到指定的限制时就将操作的数据批量写入到磁盘(SSTable，Sorted String Table)中，相比较于写入操作的高性能，读取操作需要合并内存中最近修改的操作和磁盘中的历史数据，需要先看内存，如果没有命中还要访问磁盘文件。将之前使用一个大的查找结构（造成随机读写，影响写性能），变换为将写操作顺序的保存到一些相似的有序文件（也就是sstable)中。所以每个文件包含短时间内的一些改动。因为文件是有序的，所以之后查找也会很快。文件是不可修改的，他们永远不会被更新，新的更新操作只会写到新的文件中。通过周期性的合并这些文件来减少文件个数。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"B树对比LSM树"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　B树在写入的时候至少会被写入两次，一次是WAL(redo log)，另一次是树结构本身。即使树只有几个字节的变化，也需要接受整个页面写入的开销。如果一张表存在多个索引树，那肯定会对硬盘造成多次写入。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　一次数据库操作导入对磁盘上的文件多次写入，被称之为写放大。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　LSM树会有更低的写放大，因为磁盘上的SSTable是顺序且紧凑的而不是必须复写树结构。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　而且LSM树可以对文件进行压缩和排序，这是SSTable的特性所决定的，Stored String Table中的数据是可排序的，也就意味着可以用前缀树来进行排序。然后由于sstable文件是不可修改的，这让对他们的锁操作非常简单。一般来说，唯一的竞争资源就是memtable，相对来说需要相对复杂的锁机制来管理在不同的级别。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"LSM树"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　LSM本质上并不是一种树，而是一种文件组织的形式，将数据进行一个分层以便于获得更好的性能。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　从结构上分为两类，一种是存储在内存中的Memtable，另一种则是存储在磁盘中的SSTable。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　"},{"type":"element","tagName":"img","properties":{"src":"https://image.ztianzeng.com/uPic/20220518153629.png","alt":""},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　一般简单的都会划分为两层，Level 0 是存储在内存上的Memtable，Level 0以上则是存在磁盘中的SSTable"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"基本原理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"写入操作"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"当一些更新操作到达时，他们会被写到内存缓存（也就是memtable）中，memtable使用树结构来保持key的有序."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在大部分的实现中，memtable会通过写WAL的方式备份到磁盘，用来恢复数据，防止数据丢失。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"当memtable数据达到一定规模时会被刷新到磁盘上的一个新文件，重要的是系统只做了顺序磁盘读写，因为没有文件被编辑，新的内容或者修改只用简单的生成新的文件。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"合并文件"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以越多的数据存储到系统中，就会有越多的不可修改的，顺序的sstable文件被创建，它们代表了小的，按时间顺序的修改。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因为比较旧的文件不会被更新，重复的记录只会通过创建新的记录来覆盖，这也就产生了一些冗余的数据。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以系统会周期的执行合并操作（compaction)。 合并操作选择一些文件，并把他们合并到一起，移除重复的更新或者删除记录，同时也会删除上述的冗余。更重要的是，通过减少文件个数的增长，保证读操作的性 能。因为sstable文件都是有序结构的，所以合并操作也是非常高效的。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"读操作"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"读操作优先判断key是否在MemTable, 如果不在的话，则把覆盖该key range的所有SSTable都查找一遍。简单，但是低效。因此，在工程实现上，一般会为SSTable加入索引。可以是一个key-offset索引（类似于kafka的index文件），也可以是布隆过滤器（Bloom Filter）。布隆过滤器有一个特性：如果bloom说一个key不存在，就一定不存在，而当bloom说一个key存在于这个文件，可能是不存在的。实现层面上，布隆过滤器就是"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"key--比特位"}]},{"type":"text","value":"的映射。理想情况下，当然是一个key对应一个比特实现全映射，但是太消耗内存。因此，一般通过控制假阳性概率来节约内存，代价是牺牲了一定的读性能。对于我们的应用场景，我们将该概率从0.99降低到0.8，布隆过滤器的内存消耗从2GB+下降到了300MB，数据读取速度有所降低，但在感知层面可忽略。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"总结"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　LSM Tree 思想是把随机写入转化成顺序写入，这样可以大幅度提升写入的性能，但是查询性能会有一部分牺牲。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　在时序数据库运用这一特性非常合适。持续写入数据量大，数据和时间，将时间编码到 key 值中很容易使 key 值有序。读取操作通常是根据某个Key的值，去获取一段时间范围内的数据。这样就把 LSM Tree 读取性能差的劣势缩小了，反而因为数据在 SSTable 中是按照 key 值顺序排列，读取大块连续的数据时效率也很高。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"style","properties":{"className":["grvsc-styles"]},"children":[{"type":"text","value":"\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n"}]}],"data":{"quirksMode":false}},"html":"<p updated=\"20220808111208\">　　最近在看Google十年前发表的<a href=\"/topic/分布式解决方案/分布式理论/三驾马车/BigTable中文翻译\">BigTable论文</a>，BigTable这玩意，最骚的一点就是改变了大多数传统数据库所使用的文件组织方法,业界对这种新一代的文件组织方法进行了实现，叫做Log Structured Merge Tree，简称LSM，中文叫做<em>日志结构的合并树。</em></p>\n<p updated=\"20220808111208\">　　LSM目前被用于多个面向大数据的数据库产品: HBase、Cassandra、LevelDB等。</p>\n<h1 id=\"诞生背景\">诞生背景</h1>\n<p updated=\"20220808111208\">　　无论B树和B+树在写入的时候，为了能处理数据库异常崩溃的场景，通常都会有额外的结构，学名叫做<strong>预写式日志</strong>(WAL，write-ahead log)，在Mysql 中叫做 redo log。在写入数据之前，会将操作都写入这个redo log(这个文件在磁盘上)，然后再从这个redo log中将数据同步到具体的B树中。这样即使数据库发生崩溃，也能够通过这个日志文件，让B树恢复到一致的状态。</p>\n<p updated=\"20220808111208\">　　但是B树难以应对并发操作的情况，在多个线程同时访问B树的时候需要加锁，需要保证树的结构是一致和完整的，否则不同的线程就会看到树处于不一致的状态。Msql会有各个隔离级别和各种锁，也是因为这个原因。</p>\n<p updated=\"20220808111208\">　　为了加快写入的速度，就诞生了LSM这个算法。</p>\n<p updated=\"20220808111208\">　　LSM的思想，在对于数据修改采用增量的方式保存在内存中，内存容量达到指定的限制时就将操作的数据批量写入到磁盘(SSTable，Sorted String Table)中，相比较于写入操作的高性能，读取操作需要合并内存中最近修改的操作和磁盘中的历史数据，需要先看内存，如果没有命中还要访问磁盘文件。将之前使用一个大的查找结构（造成随机读写，影响写性能），变换为将写操作顺序的保存到一些相似的有序文件（也就是sstable)中。所以每个文件包含短时间内的一些改动。因为文件是有序的，所以之后查找也会很快。文件是不可修改的，他们永远不会被更新，新的更新操作只会写到新的文件中。通过周期性的合并这些文件来减少文件个数。</p>\n<h2 id=\"B树对比LSM树\">B树对比LSM树</h2>\n<p updated=\"20220808111208\">　　B树在写入的时候至少会被写入两次，一次是WAL(redo log)，另一次是树结构本身。即使树只有几个字节的变化，也需要接受整个页面写入的开销。如果一张表存在多个索引树，那肯定会对硬盘造成多次写入。</p>\n<p updated=\"20220808111208\">　　一次数据库操作导入对磁盘上的文件多次写入，被称之为写放大。</p>\n<p updated=\"20220808111208\">　　LSM树会有更低的写放大，因为磁盘上的SSTable是顺序且紧凑的而不是必须复写树结构。</p>\n<p updated=\"20220808111208\">　　而且LSM树可以对文件进行压缩和排序，这是SSTable的特性所决定的，Stored String Table中的数据是可排序的，也就意味着可以用前缀树来进行排序。然后由于sstable文件是不可修改的，这让对他们的锁操作非常简单。一般来说，唯一的竞争资源就是memtable，相对来说需要相对复杂的锁机制来管理在不同的级别。</p>\n<h1 id=\"LSM树\">LSM树</h1>\n<p updated=\"20220808111208\">　　LSM本质上并不是一种树，而是一种文件组织的形式，将数据进行一个分层以便于获得更好的性能。</p>\n<p updated=\"20220808111208\">　　从结构上分为两类，一种是存储在内存中的Memtable，另一种则是存储在磁盘中的SSTable。</p>\n<p updated=\"20220808111208\">　　<span class=\"img\"><img src=\"https://image.ztianzeng.com/uPic/20220518153629.png\" alt=\"\" /></span></p>\n<p updated=\"20220808111208\">　　一般简单的都会划分为两层，Level 0 是存储在内存上的Memtable，Level 0以上则是存在磁盘中的SSTable</p>\n<h2 id=\"基本原理\">基本原理</h2>\n<ul updated=\"20220808111208\">\n<li id=\"20220808111208-5cpw9ar\" updated=\"20220808111208\">\n<p updated=\"20220808111208\">写入操作</p>\n<p updated=\"20220808111208\">当一些更新操作到达时，他们会被写到内存缓存（也就是memtable）中，memtable使用树结构来保持key的有序.</p>\n<p updated=\"20220808111208\">在大部分的实现中，memtable会通过写WAL的方式备份到磁盘，用来恢复数据，防止数据丢失。</p>\n<p updated=\"20220808111208\">当memtable数据达到一定规模时会被刷新到磁盘上的一个新文件，重要的是系统只做了顺序磁盘读写，因为没有文件被编辑，新的内容或者修改只用简单的生成新的文件。</p>\n</li>\n<li id=\"20220808111208-2n4fage\" updated=\"20220808111208\">\n<p updated=\"20220808111208\">合并文件</p>\n<p updated=\"20220808111208\">所以越多的数据存储到系统中，就会有越多的不可修改的，顺序的sstable文件被创建，它们代表了小的，按时间顺序的修改。</p>\n<p updated=\"20220808111208\">因为比较旧的文件不会被更新，重复的记录只会通过创建新的记录来覆盖，这也就产生了一些冗余的数据。</p>\n<p updated=\"20220808111208\">所以系统会周期的执行合并操作（compaction)。 合并操作选择一些文件，并把他们合并到一起，移除重复的更新或者删除记录，同时也会删除上述的冗余。更重要的是，通过减少文件个数的增长，保证读操作的性 能。因为sstable文件都是有序结构的，所以合并操作也是非常高效的。</p>\n</li>\n<li id=\"20220808111208-1ptlc1f\" updated=\"20220808111208\">\n<p updated=\"20220808111208\">读操作</p>\n<p updated=\"20220808111208\">读操作优先判断key是否在MemTable, 如果不在的话，则把覆盖该key range的所有SSTable都查找一遍。简单，但是低效。因此，在工程实现上，一般会为SSTable加入索引。可以是一个key-offset索引（类似于kafka的index文件），也可以是布隆过滤器（Bloom Filter）。布隆过滤器有一个特性：如果bloom说一个key不存在，就一定不存在，而当bloom说一个key存在于这个文件，可能是不存在的。实现层面上，布隆过滤器就是<code>key--比特位</code>的映射。理想情况下，当然是一个key对应一个比特实现全映射，但是太消耗内存。因此，一般通过控制假阳性概率来节约内存，代价是牺牲了一定的读性能。对于我们的应用场景，我们将该概率从0.99降低到0.8，布隆过滤器的内存消耗从2GB+下降到了300MB，数据读取速度有所降低，但在感知层面可忽略。</p>\n</li>\n</ul>\n<h1 id=\"总结\">总结</h1>\n<p updated=\"20220808111208\">　　LSM Tree 思想是把随机写入转化成顺序写入，这样可以大幅度提升写入的性能，但是查询性能会有一部分牺牲。</p>\n<p updated=\"20220808111208\">　　在时序数据库运用这一特性非常合适。持续写入数据量大，数据和时间，将时间编码到 key 值中很容易使 key 值有序。读取操作通常是根据某个Key的值，去获取一段时间范围内的数据。这样就把 LSM Tree 读取性能差的劣势缩小了，反而因为数据在 SSTable 中是按照 key 值顺序排列，读取大块连续的数据时效率也很高。</p>\n","headings":[{"depth":1,"value":"诞生背景"},{"depth":2,"value":"B树对比LSM树"},{"depth":1,"value":"LSM树"},{"depth":2,"value":"基本原理"},{"depth":1,"value":"总结"}],"path":"/posts/Log Structured Merge Tree LSM原理"},"headings":[{"depth":1,"value":"诞生背景","slug":"诞生背景"},{"depth":2,"value":"B树对比LSM树","slug":"b树对比lsm树"},{"depth":1,"value":"LSM树","slug":"lsm树"},{"depth":2,"value":"基本原理","slug":"基本原理"},{"depth":1,"value":"总结","slug":"总结-1"}]}},
    "staticQueryHashes": ["630634786","928362550"]}