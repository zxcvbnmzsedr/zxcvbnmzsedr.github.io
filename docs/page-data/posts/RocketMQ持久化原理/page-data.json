{
    "componentChunkName": "component---src-templates-article-page-template-tsx",
    "path": "/posts/RocketMQ持久化原理",
    "result": {"pageContext":{"id":"/posts/RocketMQ持久化原理","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"RocketMQ持久化原理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"消息的持久化是RocketMQ中最为复杂和重要的一部分，由于持久化机制的存在才能够实现RocketMQ的高可靠性。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"图1"}]},{"type":"text","value":"展示了RocketMQ的整体的工作逻辑"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://image.ztianzeng.com/uPic/20220507104147.png","alt":"","title":"图1 整体工作流程"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Productor按照顺序写入"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CommitLog"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Consumer顺序读取"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"ConsumeQueue"}]},{"type":"text","value":"进行消费, "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"ConsumeQueue"}]},{"type":"text","value":"是"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CommitLog"}]},{"type":"text","value":"基于"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Topic"}]},{"type":"text","value":"的索引文件"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"RocketMQ通过文件来作为中介，来衔接Productor和Consumer之间的消息传递，其流程还是比较简单的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"ComitLog"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"comitLog是RocketMQ存储消息的地方，Productor的发送消息都会写入到这个文件里面。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"对应的实现类就叫做CommitLog。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"CommitLog是通过MMAP的方式来操作文件，以加快文件处理速度，代码在"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"asyncPutMessages"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"// CommitLog.java\npublic CompletableFuture<PutMessageResult> asyncPutMessages(final MessageExtBatch messageExtBatch) {\n        \t// .....\n            MappedFile mappedFile = this.mappedFileQueue.getLastMappedFile();\n\n\t\t// 如果文件为空，或者文件已经满了，则整一个新的文件出来\n            if (null == mappedFile || mappedFile.isFull()) {\n                mappedFile = this.mappedFileQueue.getLastMappedFile(0); // Mark: NewFile may be cause noise\n            }\n\t\t// 创建出来的文件为空，就返回异常\n            if (null == mappedFile) {\n                log.error(\"Create mapped file1 error, topic: {} clientAddr: {}\", messageExtBatch.getTopic(), messageExtBatch.getBornHostString());\n                return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, null));\n            }\n            // 向文件中追加消息信息\n            result = mappedFile.appendMessages(messageExtBatch, this.appendMessageCallback, putMessageContext);\n\n            switch (result.getStatus()) {\n\t\t// 如果正常处理，则相安无事\n                case PUT_OK:\n                    break;\n\t\t// 如果正好到了文件的末尾，则新建一个文件追加到新的文件中去\n                case END_OF_FILE:\n                    unlockMappedFile = mappedFile;\n                    // Create a new file, re-write the message\n                    mappedFile = this.mappedFileQueue.getLastMappedFile(0);\n                    if (null == mappedFile) {\n                        // XXX: warn and notify me\n                        log.error(\"Create mapped file2 error, topic: {} clientAddr: {}\", messageExtBatch.getTopic(), messageExtBatch.getBornHostString());\n                        return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result));\n                    }\n                    result = mappedFile.appendMessages(messageExtBatch, this.appendMessageCallback, putMessageContext);\n                    break;\n                case MESSAGE_SIZE_EXCEEDED:\n                case PROPERTIES_SIZE_EXCEEDED:\n                    return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result));\n                case UNKNOWN_ERROR:\n                default:\n                    return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result));\n            }\n\t// .....\n    }\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"asyncPutMessages"}]},{"type":"text","value":" 追加msg信息还是比较好理解的，会调用到一个自己封装的"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"MappedFile"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"MappedFile"}]},{"type":"text","value":"的构造函数中，通过JDK提供的文件NIO，初始化了"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"mappedByteBuffer"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"// MappedFile.java\nprivate void init(final String fileName, final int fileSize) throws IOException {\n        // .... \n            this.fileChannel = new RandomAccessFile(this.file, \"rw\").getChannel();\n\t    // 用mmap的技术来获取文件的句柄\n            this.mappedByteBuffer = this.fileChannel.map(MapMode.READ_WRITE, 0, fileSize);\n            TOTAL_MAPPED_VIRTUAL_MEMORY.addAndGet(fileSize);\n            TOTAL_MAPPED_FILES.incrementAndGet();\n            ok = true;\n   // .....\n    \n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"然后调用"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"MappedFile"}]},{"type":"text","value":"的"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"appendMessagesInner"}]},{"type":"text","value":"来进行文件的追加，最终又会回到"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CommitLog"}]},{"type":"text","value":"中的内部类"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"DefaultAppendMessageCallback"}]},{"type":"text","value":"完成文件的写入。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"ComitLog结构"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"启动一个Productor，向着Broker中发送一条msg，msg结构如下"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"Message msg = new Message(\"TopicTest\",\n                    \"TagA\",\n                    \"OrderID188\",\n                    \"Hello world\".getBytes(RemotingHelper.DEFAULT_CHARSET));\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"然后我们用UltraEdit查看一下位于"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"${home}/store/commitlog"}]},{"type":"text","value":"下的"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"00000000000000000000"}]},{"type":"text","value":" 文件"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://image.ztianzeng.com/uPic/20220507160040.png","alt":""},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"可以明显的看到这个CommitLog文件里面明显有我们上传的msg信息。它具体的写入逻辑在"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CommitLog"}]},{"type":"text","value":"中的内部类"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"DefaultAppendMessageCallback#doAppend"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这个代码非常的长，主要盯住"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"byteBuffer"}]},{"type":"text","value":" 这个对象，看看往里面"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"put"}]},{"type":"text","value":"了什么东西"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"/**\n* 追加逻辑\n* @param fileFromOffset 文件偏移量，也就是具体的文件\n* @param byteBuffer 字节缓冲区，需要通过这个对象，完成文件的追加\n* @param maxBlank  可以写入的文件的所剩空间\n* @param msgInner 内部消息，就是msg对象\n* @param putMessageContext 写入消息的上下文\n* @return\n*/\npublic AppendMessageResult doAppend(final long fileFromOffset, final ByteBuffer byteBuffer, final int maxBlank,\n\t// ...先省略        \n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"第一个put"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"通过IDEA工具，可以看到第一个"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"byteBuffer"}]},{"type":"text","value":"的"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"put"}]},{"type":"text","value":"处理，是用于判断文件是否结束的"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"// 如果消息的长度+用于控制文件结束的8个空白字符 > 剩余胡亮\nif ((msgLen + END_FILE_MIN_BLANK_LENGTH) > maxBlank) {\n                this.msgStoreItemMemory.clear();\n                // 1 TOTALSIZE\n                this.msgStoreItemMemory.putInt(maxBlank);\n                // 2 MAGICCODE\n                this.msgStoreItemMemory.putInt(CommitLog.BLANK_MAGIC_CODE);\n                // 3 The remaining space may be any value\n                // Here the length of the specially set maxBlank\n                final long beginTimeMills = CommitLog.this.defaultMessageStore.now();\n\t\t// 加入最后8个空白字符，并且返回文件已经写满的标记\n                byteBuffer.put(this.msgStoreItemMemory.array(), 0, 8);\n                return new AppendMessageResult(AppendMessageStatus.END_OF_FILE, wroteOffset,\n                        maxBlank, /* only wrote 8 bytes, but declare wrote maxBlank for compute write position */\n                        msgIdSupplier, msgInner.getStoreTimestamp(),\n                        queueOffset, CommitLog.this.defaultMessageStore.now() - beginTimeMills);\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"第二个put"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第二个Put的时候，"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"put"}]},{"type":"text","value":"了一个"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"preEncodeBuffer"}]},{"type":"text","value":" 进去"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"byteBuffer.put(preEncodeBuffer);\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以，重点就回到了"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"preEncodeBuffer"}]},{"type":"text","value":"是怎么构造出来的"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"// CommitLog.java\n// 发现就一行代码，通过内部msgInner获取到byteBuffer\nByteBuffer preEncodeBuffer = msgInner.getEncodedBuff();\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"继续倒过来看，可以看到"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"MessageExtEncoder"}]},{"type":"text","value":"中设置有"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"encode"}]},{"type":"text","value":"方法来对进来的消息体进行设置"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"// 1 TOTALSIZE\nthis.encoderBuffer.putInt(msgLen);\n// 2 MAGICCODE\nthis.encoderBuffer.putInt(CommitLog.MESSAGE_MAGIC_CODE);\n// 3 BODYCRC\nthis.encoderBuffer.putInt(msgInner.getBodyCRC());\n// 4 QUEUEID\nthis.encoderBuffer.putInt(msgInner.getQueueId());\n// 5 FLAG\nthis.encoderBuffer.putInt(msgInner.getFlag());\n// 6 QUEUEOFFSET, need update later\nthis.encoderBuffer.putLong(0);\n{\n   // DefaultAppendMessageCallback.class 中\n   preEncodeBuffer.putLong(pos, queueOffset);\n}\n// 7 PHYSICALOFFSET, need update later\nthis.encoderBuffer.putLong(0);\n{\n   // DefaultAppendMessageCallback.class 中\n    preEncodeBuffer.putLong(pos, fileFromOffset + byteBuffer.position());\n\n}\n\n// 8 SYSFLAG\nthis.encoderBuffer.putInt(msgInner.getSysFlag());\n// 9 BORNTIMESTAMP\nthis.encoderBuffer.putLong(msgInner.getBornTimestamp());\n// 10 BORNHOST\nsocketAddress2ByteBuffer(msgInner.getBornHost() ,this.encoderBuffer);\n// 11 STORETIMESTAMP\nthis.encoderBuffer.putLong(msgInner.getStoreTimestamp());\n// 12 STOREHOSTADDRESS\nsocketAddress2ByteBuffer(msgInner.getStoreHost() ,this.encoderBuffer);\n// 13 RECONSUMETIMES\nthis.encoderBuffer.putInt(msgInner.getReconsumeTimes());\n// 14 Prepared Transaction Offset\nthis.encoderBuffer.putLong(msgInner.getPreparedTransactionOffset());\n// 15 BODY\nthis.encoderBuffer.putInt(bodyLength);\nif (bodyLength > 0)\n    this.encoderBuffer.put(msgInner.getBody());\n// 16 TOPIC\nthis.encoderBuffer.put((byte) topicLength);\nthis.encoderBuffer.put(topicData);\n// 17 PROPERTIES\nthis.encoderBuffer.putShort((short) propertiesLength);\nif (propertiesLength > 0)\n    this.encoderBuffer.put(propertiesData);\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://image.ztianzeng.com/uPic/20220507163411.png","alt":""},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"TOTALSIZE: 该消息条目总长度，4字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"MAGICCODE: 魔法值，固定0xdaa320a7，4字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"BODYCRC: 消息体crc校验码，4字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"QUEUEID: ComsumeQueue消息消费队列ID，4字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"FLAG: 消息FLAG，预留给消费者的标识位，4字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"QUEUEOFFSET: 消息在ComsumeQueue的偏移量，8字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"PHYSICALOFFSET: 消息在CommitLog文件中的偏移量，8字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"SYSFLAG: 消息系统FLAG，例如是否压缩、是否有事务消息，4字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"BORNTIMESTAMP: 消息产生者调用消息发送API的时间戳，8字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"BORNHOST: 消息发送者IP、端口号，8字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"STORETIMESTAMP: 消息存储时间戳，8字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"STOREHOSPTADDRESS: Broker服务器IP+端口号，8字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"RECONSUMETIMES: 消息重试次数，4字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Prepare Transaction Offset: 事务消息物理偏移量，8字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"BodyLength: 消息体长度，4字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Body: 消息体内容"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"TopicLength: 主题存储长度，主题名称不能超过255个字符，1字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Topic: 主题内容"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"PropertiesLength: 消息属性长度，表示消息属性长度不能超过65536个字符，2字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Properties: 消息属性"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"最后把这个消息体给put到byteBuffer中去，就完成了文件的写入。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"消息丢失"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"为了加快读写速度，RocketMQ采用了MMAP来进行写入"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"将数据文件通过MMAP技术，映射文件到OS的虚拟内存中"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"MMAP技术在写入消息时，会写入到PageCache中，然后异步刷盘到实际的磁盘中"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"写入PageCache的时候，假如说这个时候发生了断电，导致数据没有及时刷到磁盘中就会发生消息丢失"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解决方案"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"修改配置"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"修改 Broker 端配置，默认刷盘方式是通过异步刷盘，修改为同步刷盘"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"## 默认情况为 ASYNC_FLUSH \nflushDiskType = SYNC_FLUSH\n"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"集群部署"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"为了保证可用性，Broker 通常采用一主（ "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"master"}]},{"type":"text","value":" ）多从（ "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"slave"}]},{"type":"text","value":" ）部署方式。为了保证消息不丢失，消息还需要复制到 slave 节点。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"默认方式下，消息写入 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"master"}]},{"type":"text","value":" 成功，就可以返回确认响应给生产者，接着消息将会异步复制到 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"slave"}]},{"type":"text","value":" 节点。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"注：master 配置：flushDiskType = SYNC_FLUSH"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"此时若 master 突然"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":" 宕机且不可恢复"}]},{"type":"text","value":" ，那么还未复制到 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"slave"}]},{"type":"text","value":" 的消息将会丢失。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"为了进一步提高消息的可靠性，我们可以采用同步的复制方式，"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"master"}]},{"type":"text","value":" 节点将会同步等待 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"slave"}]},{"type":"text","value":" 节点复制完成，才会返回确认响应"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"虽然上述配置提高消息的高可靠性，但是会降低性能 ，生产实践中需要综合选择。"}]}],"data":{"quirksMode":false}},"articleNode":{"field":{"contentType":"posts","topic":null},"frontmatter":{"id":"/posts/RocketMQ持久化原理","title":"RocketMQ持久化原理","date":"2022-05-07 10:17","absolute_path":"/posts/RocketMQ持久化原理"},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"RocketMQ持久化原理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"消息的持久化是RocketMQ中最为复杂和重要的一部分，由于持久化机制的存在才能够实现RocketMQ的高可靠性。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"图1"}]},{"type":"text","value":"展示了RocketMQ的整体的工作逻辑"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://image.ztianzeng.com/uPic/20220507104147.png","alt":"","title":"图1 整体工作流程"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Productor按照顺序写入"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CommitLog"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Consumer顺序读取"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"ConsumeQueue"}]},{"type":"text","value":"进行消费, "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"ConsumeQueue"}]},{"type":"text","value":"是"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CommitLog"}]},{"type":"text","value":"基于"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Topic"}]},{"type":"text","value":"的索引文件"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"RocketMQ通过文件来作为中介，来衔接Productor和Consumer之间的消息传递，其流程还是比较简单的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"ComitLog"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"comitLog是RocketMQ存储消息的地方，Productor的发送消息都会写入到这个文件里面。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"对应的实现类就叫做CommitLog。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"CommitLog是通过MMAP的方式来操作文件，以加快文件处理速度，代码在"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"asyncPutMessages"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"// CommitLog.java\npublic CompletableFuture<PutMessageResult> asyncPutMessages(final MessageExtBatch messageExtBatch) {\n        \t// .....\n            MappedFile mappedFile = this.mappedFileQueue.getLastMappedFile();\n\n\t\t// 如果文件为空，或者文件已经满了，则整一个新的文件出来\n            if (null == mappedFile || mappedFile.isFull()) {\n                mappedFile = this.mappedFileQueue.getLastMappedFile(0); // Mark: NewFile may be cause noise\n            }\n\t\t// 创建出来的文件为空，就返回异常\n            if (null == mappedFile) {\n                log.error(\"Create mapped file1 error, topic: {} clientAddr: {}\", messageExtBatch.getTopic(), messageExtBatch.getBornHostString());\n                return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, null));\n            }\n            // 向文件中追加消息信息\n            result = mappedFile.appendMessages(messageExtBatch, this.appendMessageCallback, putMessageContext);\n\n            switch (result.getStatus()) {\n\t\t// 如果正常处理，则相安无事\n                case PUT_OK:\n                    break;\n\t\t// 如果正好到了文件的末尾，则新建一个文件追加到新的文件中去\n                case END_OF_FILE:\n                    unlockMappedFile = mappedFile;\n                    // Create a new file, re-write the message\n                    mappedFile = this.mappedFileQueue.getLastMappedFile(0);\n                    if (null == mappedFile) {\n                        // XXX: warn and notify me\n                        log.error(\"Create mapped file2 error, topic: {} clientAddr: {}\", messageExtBatch.getTopic(), messageExtBatch.getBornHostString());\n                        return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result));\n                    }\n                    result = mappedFile.appendMessages(messageExtBatch, this.appendMessageCallback, putMessageContext);\n                    break;\n                case MESSAGE_SIZE_EXCEEDED:\n                case PROPERTIES_SIZE_EXCEEDED:\n                    return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result));\n                case UNKNOWN_ERROR:\n                default:\n                    return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result));\n            }\n\t// .....\n    }\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"asyncPutMessages"}]},{"type":"text","value":" 追加msg信息还是比较好理解的，会调用到一个自己封装的"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"MappedFile"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"MappedFile"}]},{"type":"text","value":"的构造函数中，通过JDK提供的文件NIO，初始化了"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"mappedByteBuffer"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"// MappedFile.java\nprivate void init(final String fileName, final int fileSize) throws IOException {\n        // .... \n            this.fileChannel = new RandomAccessFile(this.file, \"rw\").getChannel();\n\t    // 用mmap的技术来获取文件的句柄\n            this.mappedByteBuffer = this.fileChannel.map(MapMode.READ_WRITE, 0, fileSize);\n            TOTAL_MAPPED_VIRTUAL_MEMORY.addAndGet(fileSize);\n            TOTAL_MAPPED_FILES.incrementAndGet();\n            ok = true;\n   // .....\n    \n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"然后调用"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"MappedFile"}]},{"type":"text","value":"的"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"appendMessagesInner"}]},{"type":"text","value":"来进行文件的追加，最终又会回到"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CommitLog"}]},{"type":"text","value":"中的内部类"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"DefaultAppendMessageCallback"}]},{"type":"text","value":"完成文件的写入。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"ComitLog结构"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"启动一个Productor，向着Broker中发送一条msg，msg结构如下"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"Message msg = new Message(\"TopicTest\",\n                    \"TagA\",\n                    \"OrderID188\",\n                    \"Hello world\".getBytes(RemotingHelper.DEFAULT_CHARSET));\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"然后我们用UltraEdit查看一下位于"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"${home}/store/commitlog"}]},{"type":"text","value":"下的"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"00000000000000000000"}]},{"type":"text","value":" 文件"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://image.ztianzeng.com/uPic/20220507160040.png","alt":""},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"可以明显的看到这个CommitLog文件里面明显有我们上传的msg信息。它具体的写入逻辑在"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CommitLog"}]},{"type":"text","value":"中的内部类"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"DefaultAppendMessageCallback#doAppend"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这个代码非常的长，主要盯住"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"byteBuffer"}]},{"type":"text","value":" 这个对象，看看往里面"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"put"}]},{"type":"text","value":"了什么东西"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"/**\n* 追加逻辑\n* @param fileFromOffset 文件偏移量，也就是具体的文件\n* @param byteBuffer 字节缓冲区，需要通过这个对象，完成文件的追加\n* @param maxBlank  可以写入的文件的所剩空间\n* @param msgInner 内部消息，就是msg对象\n* @param putMessageContext 写入消息的上下文\n* @return\n*/\npublic AppendMessageResult doAppend(final long fileFromOffset, final ByteBuffer byteBuffer, final int maxBlank,\n\t// ...先省略        \n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"第一个put"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"通过IDEA工具，可以看到第一个"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"byteBuffer"}]},{"type":"text","value":"的"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"put"}]},{"type":"text","value":"处理，是用于判断文件是否结束的"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"// 如果消息的长度+用于控制文件结束的8个空白字符 > 剩余胡亮\nif ((msgLen + END_FILE_MIN_BLANK_LENGTH) > maxBlank) {\n                this.msgStoreItemMemory.clear();\n                // 1 TOTALSIZE\n                this.msgStoreItemMemory.putInt(maxBlank);\n                // 2 MAGICCODE\n                this.msgStoreItemMemory.putInt(CommitLog.BLANK_MAGIC_CODE);\n                // 3 The remaining space may be any value\n                // Here the length of the specially set maxBlank\n                final long beginTimeMills = CommitLog.this.defaultMessageStore.now();\n\t\t// 加入最后8个空白字符，并且返回文件已经写满的标记\n                byteBuffer.put(this.msgStoreItemMemory.array(), 0, 8);\n                return new AppendMessageResult(AppendMessageStatus.END_OF_FILE, wroteOffset,\n                        maxBlank, /* only wrote 8 bytes, but declare wrote maxBlank for compute write position */\n                        msgIdSupplier, msgInner.getStoreTimestamp(),\n                        queueOffset, CommitLog.this.defaultMessageStore.now() - beginTimeMills);\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"第二个put"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第二个Put的时候，"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"put"}]},{"type":"text","value":"了一个"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"preEncodeBuffer"}]},{"type":"text","value":" 进去"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"byteBuffer.put(preEncodeBuffer);\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以，重点就回到了"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"preEncodeBuffer"}]},{"type":"text","value":"是怎么构造出来的"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"// CommitLog.java\n// 发现就一行代码，通过内部msgInner获取到byteBuffer\nByteBuffer preEncodeBuffer = msgInner.getEncodedBuff();\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"继续倒过来看，可以看到"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"MessageExtEncoder"}]},{"type":"text","value":"中设置有"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"encode"}]},{"type":"text","value":"方法来对进来的消息体进行设置"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"// 1 TOTALSIZE\nthis.encoderBuffer.putInt(msgLen);\n// 2 MAGICCODE\nthis.encoderBuffer.putInt(CommitLog.MESSAGE_MAGIC_CODE);\n// 3 BODYCRC\nthis.encoderBuffer.putInt(msgInner.getBodyCRC());\n// 4 QUEUEID\nthis.encoderBuffer.putInt(msgInner.getQueueId());\n// 5 FLAG\nthis.encoderBuffer.putInt(msgInner.getFlag());\n// 6 QUEUEOFFSET, need update later\nthis.encoderBuffer.putLong(0);\n{\n   // DefaultAppendMessageCallback.class 中\n   preEncodeBuffer.putLong(pos, queueOffset);\n}\n// 7 PHYSICALOFFSET, need update later\nthis.encoderBuffer.putLong(0);\n{\n   // DefaultAppendMessageCallback.class 中\n    preEncodeBuffer.putLong(pos, fileFromOffset + byteBuffer.position());\n\n}\n\n// 8 SYSFLAG\nthis.encoderBuffer.putInt(msgInner.getSysFlag());\n// 9 BORNTIMESTAMP\nthis.encoderBuffer.putLong(msgInner.getBornTimestamp());\n// 10 BORNHOST\nsocketAddress2ByteBuffer(msgInner.getBornHost() ,this.encoderBuffer);\n// 11 STORETIMESTAMP\nthis.encoderBuffer.putLong(msgInner.getStoreTimestamp());\n// 12 STOREHOSTADDRESS\nsocketAddress2ByteBuffer(msgInner.getStoreHost() ,this.encoderBuffer);\n// 13 RECONSUMETIMES\nthis.encoderBuffer.putInt(msgInner.getReconsumeTimes());\n// 14 Prepared Transaction Offset\nthis.encoderBuffer.putLong(msgInner.getPreparedTransactionOffset());\n// 15 BODY\nthis.encoderBuffer.putInt(bodyLength);\nif (bodyLength > 0)\n    this.encoderBuffer.put(msgInner.getBody());\n// 16 TOPIC\nthis.encoderBuffer.put((byte) topicLength);\nthis.encoderBuffer.put(topicData);\n// 17 PROPERTIES\nthis.encoderBuffer.putShort((short) propertiesLength);\nif (propertiesLength > 0)\n    this.encoderBuffer.put(propertiesData);\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://image.ztianzeng.com/uPic/20220507163411.png","alt":""},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"TOTALSIZE: 该消息条目总长度，4字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"MAGICCODE: 魔法值，固定0xdaa320a7，4字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"BODYCRC: 消息体crc校验码，4字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"QUEUEID: ComsumeQueue消息消费队列ID，4字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"FLAG: 消息FLAG，预留给消费者的标识位，4字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"QUEUEOFFSET: 消息在ComsumeQueue的偏移量，8字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"PHYSICALOFFSET: 消息在CommitLog文件中的偏移量，8字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"SYSFLAG: 消息系统FLAG，例如是否压缩、是否有事务消息，4字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"BORNTIMESTAMP: 消息产生者调用消息发送API的时间戳，8字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"BORNHOST: 消息发送者IP、端口号，8字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"STORETIMESTAMP: 消息存储时间戳，8字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"STOREHOSPTADDRESS: Broker服务器IP+端口号，8字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"RECONSUMETIMES: 消息重试次数，4字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Prepare Transaction Offset: 事务消息物理偏移量，8字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"BodyLength: 消息体长度，4字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Body: 消息体内容"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"TopicLength: 主题存储长度，主题名称不能超过255个字符，1字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Topic: 主题内容"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"PropertiesLength: 消息属性长度，表示消息属性长度不能超过65536个字符，2字节"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Properties: 消息属性"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"最后把这个消息体给put到byteBuffer中去，就完成了文件的写入。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"消息丢失"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"为了加快读写速度，RocketMQ采用了MMAP来进行写入"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"将数据文件通过MMAP技术，映射文件到OS的虚拟内存中"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"MMAP技术在写入消息时，会写入到PageCache中，然后异步刷盘到实际的磁盘中"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"写入PageCache的时候，假如说这个时候发生了断电，导致数据没有及时刷到磁盘中就会发生消息丢失"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"解决方案"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"修改配置"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"修改 Broker 端配置，默认刷盘方式是通过异步刷盘，修改为同步刷盘"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"## 默认情况为 ASYNC_FLUSH \nflushDiskType = SYNC_FLUSH\n"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"集群部署"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"为了保证可用性，Broker 通常采用一主（ "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"master"}]},{"type":"text","value":" ）多从（ "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"slave"}]},{"type":"text","value":" ）部署方式。为了保证消息不丢失，消息还需要复制到 slave 节点。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"默认方式下，消息写入 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"master"}]},{"type":"text","value":" 成功，就可以返回确认响应给生产者，接着消息将会异步复制到 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"slave"}]},{"type":"text","value":" 节点。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"注：master 配置：flushDiskType = SYNC_FLUSH"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"此时若 master 突然"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":" 宕机且不可恢复"}]},{"type":"text","value":" ，那么还未复制到 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"slave"}]},{"type":"text","value":" 的消息将会丢失。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"为了进一步提高消息的可靠性，我们可以采用同步的复制方式，"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"master"}]},{"type":"text","value":" 节点将会同步等待 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"slave"}]},{"type":"text","value":" 节点复制完成，才会返回确认响应"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"虽然上述配置提高消息的高可靠性，但是会降低性能 ，生产实践中需要综合选择。"}]}],"data":{"quirksMode":false}},"headings":[{"depth":1,"value":"RocketMQ持久化原理"},{"depth":1,"value":"ComitLog"},{"depth":1,"value":"ComitLog结构"},{"depth":2,"value":"第一个put"},{"depth":2,"value":"第二个put"},{"depth":1,"value":"消息丢失"},{"depth":2,"value":"解决方案"}],"path":"/posts/RocketMQ持久化原理"},"headings":[{"depth":1,"value":"RocketMQ持久化原理","slug":"rocketmq持久化原理"},{"depth":1,"value":"ComitLog","slug":"comitlog"},{"depth":1,"value":"ComitLog结构","slug":"comitlog结构"},{"depth":2,"value":"第一个put","slug":"第一个put"},{"depth":2,"value":"第二个put","slug":"第二个put"},{"depth":1,"value":"消息丢失","slug":"消息丢失"},{"depth":2,"value":"解决方案","slug":"解决方案-1"}]}},
    "staticQueryHashes": ["630634786","928362550"]}