{
    "componentChunkName": "component---src-templates-topic-page-template-tsx",
    "path": "/topic/redis/Redis分布式缓存/缓存击穿",
    "result": {"pageContext":{"id":"/topic/redis/Redis分布式缓存/缓存击穿","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"缓存击穿"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"大量的请求同时查询一个key时，假设此时，这个key正好失效了，就会导致大量的请求都打到数据库上面去。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"缓存击穿和缓存雪崩有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了DB。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"而缓存击穿不同的是缓存击穿是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"解决方案"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"不过期"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们简单粗暴点，直接让热点数据永远不过期，定时任务定期去刷新数据就可以了。不过这样设置需要区分场景，比如某宝首页可以这么做"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"互斥锁"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"为了避免出现缓存击穿的情况，我们可以在第一个请求去查询数据库的时候对他加一个互斥锁，其余的查询请求都会被阻塞住，直到锁被释放，后面的线程进来发现已经有缓存了，就直接走缓存，从而保护数据库。但是也是由于它会阻塞其他的线程，此时系统吞吐量会下降。需要结合实际的业务去考虑是否要这么做。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public class Test {\n    public String get(String key) {\n        //查询缓存\n        String value = redis.get(key);\n        if (value != null) {\n            //缓存存在直接返回\n            return value;\n        } else {\n            //缓存不存在则对方法加锁\n            //假设请求量很大，缓存过期\n            synchronized (Test.class) {\n                //再查一遍redis\n                value = redis.get(key);\n                if (value != null) {\n                    // 查到数据直接返回\n                    return value;\n                } else {\n                    // 二次查询缓存也不存在，直接查DB\n                    value = dao.get(key);\n                    // 数据缓存\n                    redis.setnx(key, value, time);\n                    //返回\n                    return value;\n                }\n            }\n        }\n    }\n}\n"}]}]}],"data":{"quirksMode":false}},"headings":[{"depth":1,"value":"缓存击穿","slug":"缓存击穿"},{"depth":1,"value":"解决方案","slug":"解决方案-1"},{"depth":2,"value":"不过期","slug":"不过期"},{"depth":2,"value":"互斥锁","slug":"互斥锁"}]}},
    "staticQueryHashes": ["928362550"]}