{
    "componentChunkName": "component---src-templates-article-page-template-tsx",
    "path": "/posts/RocketMQ延迟消息原理",
    "result": {"pageContext":{"id":"/posts/RocketMQ延迟消息原理","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"RocketMQ延迟消息原理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"RocketMQ提供了延迟消息的功能，消息在发送到RocketMQ服务端之后不会马上投递，而是根据消息中的属性延迟固定时间之后才会投递到消费者那。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"使用场景"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"电商里，提交了一个订单就可以发送一个延时消息，1h后去检查这个订单的状态，如果还是未付款就取消订单释放库存。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"启动消费者等待传入订阅消息"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public class ScheduledMessageConsumer {\n   public static void main(String[] args) throws Exception {\n      // 实例化消费者\n      DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"ExampleConsumer\");\n      // 订阅Topics\n      consumer.subscribe(\"TestTopic\", \"*\");\n      // 注册消息监听者\n      consumer.registerMessageListener(new MessageListenerConcurrently() {\n          @Override\n          public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> messages, ConsumeConcurrentlyContext context) {\n              for (MessageExt message : messages) {\n                  // Print approximate delay time period\n                  System.out.println(\"Receive message[msgId=\" + message.getMsgId() + \"] \" + (System.currentTimeMillis() - message.getBornTimestamp()) + \"ms later\");\n              }\n              return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n          }\n      });\n      // 启动消费者\n      consumer.start();\n  }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"发送延迟消息"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"现在RocketMq并不支持任意时间的延时，需要设置几个固定的延时等级，从1s到2h分别对应着等级1到18 消息消费失败会进入延时消息队列，消息发送时间与设置的延时等级和重试次数有关"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public class ScheduledMessageProducer {\n   public static void main(String[] args) throws Exception {\n      // 实例化一个生产者来产生延时消息\n      DefaultMQProducer producer = new DefaultMQProducer(\"ExampleProducerGroup\");\n      // 启动生产者\n      producer.start();\n      int totalMessagesToSend = 100;\n      for (int i = 0; i < totalMessagesToSend; i++) {\n          Message message = new Message(\"TestTopic\", (\"Hello scheduled message \" + i).getBytes());\n          // 设置延时等级3,这个消息将在10s之后发送(现在只支持固定的几个时间,详看delayTimeLevel)\n          message.setDelayTimeLevel(3);\n          // 发送消息\n          producer.send(message);\n      }\n       // 关闭生产者\n      producer.shutdown();\n  }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"原理分析"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Productor发送没啥好说的，与事务消息队列相比简单太多，与正常发送相比仅仅设置了一个"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"DelayTimeLevel"}]},{"type":"text","value":"的属性。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"broker接收流程"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"消息从"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"SendMessageProcessor#asyncProcessRequest"}]},{"type":"text","value":" 进来之后，会一步步向下执行"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"// SendMessageProcessor.java\n private CompletableFuture<RemotingCommand> asyncSendMessage(ChannelHandlerContext ctx, RemotingCommand request,\n                                                                SendMessageContext mqtraceContext,\n                                                                SendMessageRequestHeader requestHeader) {\n        // ......\n        CompletableFuture<PutMessageResult> putMessageResult = null;\n        String transFlag = origProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);\n        if (transFlag != null && Boolean.parseBoolean(transFlag)) {\n            if (this.brokerController.getBrokerConfig().isRejectTransactionMessage()) {\n                response.setCode(ResponseCode.NO_PERMISSION);\n                response.setRemark(\n                        \"the broker[\" + this.brokerController.getBrokerConfig().getBrokerIP1()\n                                + \"] sending transaction message is forbidden\");\n                return CompletableFuture.completedFuture(response);\n            }\n            //存储事务消息\n            putMessageResult = this.brokerController.getTransactionalMessageService().asyncPrepareMessage(msgInner);\n        } else {\n            //存储普通消息\n            putMessageResult = this.brokerController.getMessageStore().asyncPutMessage(msgInner);\n        }\n        return handlePutMessageResultFuture(putMessageResult, response, request, msgInner, responseHeader, mqtraceContext, ctx, queueIdInt);\n    }\n\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"然后会调用到"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"DefaultMessageStore#asyncPutMessage"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"// DefaultMessageStore#asyncPutMessage.java\npublic CompletableFuture<PutMessageResult> asyncPutMessage(MessageExtBrokerInner msg) {\n \t// 检查存储状态：是否关闭、是否slave、是否不可写、写入是否频繁\n        PutMessageStatus checkStoreStatus = this.checkStoreStatus();\n        if (checkStoreStatus != PutMessageStatus.PUT_OK) {\n            return CompletableFuture.completedFuture(new PutMessageResult(checkStoreStatus, null));\n        }\n\t// 检查msg长度是否合法：topic是否超过127、body长度是否超过限定值\n        PutMessageStatus msgCheckStatus = this.checkMessage(msg);\n        if (msgCheckStatus == PutMessageStatus.MESSAGE_ILLEGAL) {\n            return CompletableFuture.completedFuture(new PutMessageResult(msgCheckStatus, null));\n        }\n\n        PutMessageStatus lmqMsgCheckStatus = this.checkLmqMessage(msg);\n        if (msgCheckStatus == PutMessageStatus.LMQ_CONSUME_QUEUE_NUM_EXCEEDED) {\n            return CompletableFuture.completedFuture(new PutMessageResult(lmqMsgCheckStatus, null));\n        }\n\n\n        long beginTime = this.getSystemClock().now();\n\t// 往commitLog中塞入消息（核心！！）\n        CompletableFuture<PutMessageResult> putResultFuture = this.commitLog.asyncPutMessage(msg);\n\n        putResultFuture.thenAccept((result) -> {\n            long elapsedTime = this.getSystemClock().now() - beginTime;\n            if (elapsedTime > 500) {\n                log.warn(\"putMessage not in lock elapsed time(ms)={}, bodyLength={}\", elapsedTime, msg.getBody().length);\n            }\n            this.storeStatsService.setPutMessageEntireTimeMax(elapsedTime);\n\n            if (null == result || !result.isOk()) {\n                this.storeStatsService.getPutMessageFailedTimes().add(1);\n            }\n        });\n\n        return putResultFuture;\n    }\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"最后通过RocketMQ的"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CommitLog"}]},{"type":"text","value":"将消息存储起来，延迟消息的秘密也在这里将会得到解答"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public CompletableFuture<PutMessageResult> asyncPutMessage(final MessageExtBrokerInner msg) {\n\t// .... 省略一些代码\n        if (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE\n                || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) {\n            // 如果设置的延迟等级>0,则表示需要延迟进行推送\n            if (msg.getDelayTimeLevel() > 0) {\n                if (msg.getDelayTimeLevel() > this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) {\n                    msg.setDelayTimeLevel(this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());\n                }\n\n                topic = TopicValidator.RMQ_SYS_SCHEDULE_TOPIC;\n                int queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());\n\n                // 保存真实的Topic和QueueId\n                MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());\n                MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));\n                msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));\n\t\t// 将topic修改成延迟队列的topic\n                msg.setTopic(topic);\n                msg.setQueueId(queueId);\n            }\n        }\n\t// ... 省略一些代码\n    }\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"RocketMQ实现延迟队列的方式大致和事务消息类似，让消息重写到一个"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Consumer"}]},{"type":"text","value":"无法监听的"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Topic"}]},{"type":"text","value":"中，这样就能够将延迟消息给保存下来"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"延迟投递原理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"通过IDEA 查看 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"TopicValidator#RMQ_SYS_SCHEDULE_TOPIC"}]},{"type":"text","value":",可以发现在"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"ScheduleMessageService"}]},{"type":"text","value":"中有去扫描这个Topic，看这个类名大概也能够猜出，是延迟投递的核心实现类。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"// ScheduleMessageService.java\npublic void start() {\n        if (started.compareAndSet(false, true)) {\n            this.load();\n            this.deliverExecutorService = new ScheduledThreadPoolExecutor(this.maxDelayLevel, new ThreadFactoryImpl(\"ScheduleMessageTimerThread_\"));\n            if (this.enableAsyncDeliver) {\n                this.handleExecutorService = new ScheduledThreadPoolExecutor(this.maxDelayLevel, new ThreadFactoryImpl(\"ScheduleMessageExecutorHandleThread_\"));\n            }\n            for (Map.Entry<Integer, Long> entry : this.delayLevelTable.entrySet()) {\n                Integer level = entry.getKey();\n                Long timeDelay = entry.getValue();\n                Long offset = this.offsetTable.get(level);\n                if (null == offset) {\n                    offset = 0L;\n                }\n\n                if (timeDelay != null) {\n                    if (this.enableAsyncDeliver) {\n                        this.handleExecutorService.schedule(new HandlePutResultTask(level), FIRST_DELAY_TIME, TimeUnit.MILLISECONDS);\n                    }\n\t\t    // 启动延迟队列，调度任务\n                    this.deliverExecutorService.schedule(new DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME, TimeUnit.MILLISECONDS);\n                }\n            }\n\n            this.deliverExecutorService.scheduleAtFixedRate(new Runnable() {\n\n                @Override\n                public void run() {\n                    try {\n                        if (started.get()) {\n\t\t\t// 将任务持久化到文件中去\n                            ScheduleMessageService.this.persist();\n                        }\n                    } catch (Throwable e) {\n                        log.error(\"scheduleAtFixedRate flush exception\", e);\n                    }\n                }\n            }, 10000, this.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval(), TimeUnit.MILLISECONDS);\n        }\n    }\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"通过线程启动了一个"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"DeliverDelayedMessageTimerTask"}]},{"type":"text","value":"来调度延迟消息。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"就是通过Java自带的延迟队列，来掉队队列中的消息，满足时间了则进行投递，将定时任务的Topic中移除，放入它原本的Topic中。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这样客户端就能够接收到消息的信息。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"总结"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"producer端设置消息delayLevel延迟级别，消息属性DELAY中存储了对应了延时级别"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"broker端收到消息后，判断延时消息延迟级别，如果大于0，则备份消息原始topic，queueId，并将消息topic改为延时消息队列特定topic(SCHEDULE_TOPIC)，queueId改为延时级别-1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"mq服务端ScheduleMessageService中，为每一个延迟级别单独设置一个定时器，定时(每隔1秒)拉取对应延迟级别的消费队列"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"根据消费偏移量offset从commitLog中解析出对应消息"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"从消息tagsCode中解析出消息应当被投递的时间，与当前时间做比较，判断是否应该进行投递"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"若到达了投递时间，则构建一个新的消息，并从消息属性中恢复出原始的topic，queueId，并清除消息延迟属性，从新进行消息投递"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"articleNode":{"field":{"contentType":"posts","topic":null},"frontmatter":{"id":"/posts/RocketMQ延迟消息原理","title":"RocketMQ延迟消息原理","date":"2022-05-06 17:05","absolute_path":"/posts/RocketMQ延迟消息原理"},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"RocketMQ延迟消息原理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"RocketMQ提供了延迟消息的功能，消息在发送到RocketMQ服务端之后不会马上投递，而是根据消息中的属性延迟固定时间之后才会投递到消费者那。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"使用场景"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"电商里，提交了一个订单就可以发送一个延时消息，1h后去检查这个订单的状态，如果还是未付款就取消订单释放库存。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"启动消费者等待传入订阅消息"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public class ScheduledMessageConsumer {\n   public static void main(String[] args) throws Exception {\n      // 实例化消费者\n      DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"ExampleConsumer\");\n      // 订阅Topics\n      consumer.subscribe(\"TestTopic\", \"*\");\n      // 注册消息监听者\n      consumer.registerMessageListener(new MessageListenerConcurrently() {\n          @Override\n          public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> messages, ConsumeConcurrentlyContext context) {\n              for (MessageExt message : messages) {\n                  // Print approximate delay time period\n                  System.out.println(\"Receive message[msgId=\" + message.getMsgId() + \"] \" + (System.currentTimeMillis() - message.getBornTimestamp()) + \"ms later\");\n              }\n              return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n          }\n      });\n      // 启动消费者\n      consumer.start();\n  }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"发送延迟消息"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"现在RocketMq并不支持任意时间的延时，需要设置几个固定的延时等级，从1s到2h分别对应着等级1到18 消息消费失败会进入延时消息队列，消息发送时间与设置的延时等级和重试次数有关"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public class ScheduledMessageProducer {\n   public static void main(String[] args) throws Exception {\n      // 实例化一个生产者来产生延时消息\n      DefaultMQProducer producer = new DefaultMQProducer(\"ExampleProducerGroup\");\n      // 启动生产者\n      producer.start();\n      int totalMessagesToSend = 100;\n      for (int i = 0; i < totalMessagesToSend; i++) {\n          Message message = new Message(\"TestTopic\", (\"Hello scheduled message \" + i).getBytes());\n          // 设置延时等级3,这个消息将在10s之后发送(现在只支持固定的几个时间,详看delayTimeLevel)\n          message.setDelayTimeLevel(3);\n          // 发送消息\n          producer.send(message);\n      }\n       // 关闭生产者\n      producer.shutdown();\n  }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"原理分析"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Productor发送没啥好说的，与事务消息队列相比简单太多，与正常发送相比仅仅设置了一个"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"DelayTimeLevel"}]},{"type":"text","value":"的属性。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"broker接收流程"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"消息从"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"SendMessageProcessor#asyncProcessRequest"}]},{"type":"text","value":" 进来之后，会一步步向下执行"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"// SendMessageProcessor.java\n private CompletableFuture<RemotingCommand> asyncSendMessage(ChannelHandlerContext ctx, RemotingCommand request,\n                                                                SendMessageContext mqtraceContext,\n                                                                SendMessageRequestHeader requestHeader) {\n        // ......\n        CompletableFuture<PutMessageResult> putMessageResult = null;\n        String transFlag = origProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);\n        if (transFlag != null && Boolean.parseBoolean(transFlag)) {\n            if (this.brokerController.getBrokerConfig().isRejectTransactionMessage()) {\n                response.setCode(ResponseCode.NO_PERMISSION);\n                response.setRemark(\n                        \"the broker[\" + this.brokerController.getBrokerConfig().getBrokerIP1()\n                                + \"] sending transaction message is forbidden\");\n                return CompletableFuture.completedFuture(response);\n            }\n            //存储事务消息\n            putMessageResult = this.brokerController.getTransactionalMessageService().asyncPrepareMessage(msgInner);\n        } else {\n            //存储普通消息\n            putMessageResult = this.brokerController.getMessageStore().asyncPutMessage(msgInner);\n        }\n        return handlePutMessageResultFuture(putMessageResult, response, request, msgInner, responseHeader, mqtraceContext, ctx, queueIdInt);\n    }\n\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"然后会调用到"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"DefaultMessageStore#asyncPutMessage"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"// DefaultMessageStore#asyncPutMessage.java\npublic CompletableFuture<PutMessageResult> asyncPutMessage(MessageExtBrokerInner msg) {\n \t// 检查存储状态：是否关闭、是否slave、是否不可写、写入是否频繁\n        PutMessageStatus checkStoreStatus = this.checkStoreStatus();\n        if (checkStoreStatus != PutMessageStatus.PUT_OK) {\n            return CompletableFuture.completedFuture(new PutMessageResult(checkStoreStatus, null));\n        }\n\t// 检查msg长度是否合法：topic是否超过127、body长度是否超过限定值\n        PutMessageStatus msgCheckStatus = this.checkMessage(msg);\n        if (msgCheckStatus == PutMessageStatus.MESSAGE_ILLEGAL) {\n            return CompletableFuture.completedFuture(new PutMessageResult(msgCheckStatus, null));\n        }\n\n        PutMessageStatus lmqMsgCheckStatus = this.checkLmqMessage(msg);\n        if (msgCheckStatus == PutMessageStatus.LMQ_CONSUME_QUEUE_NUM_EXCEEDED) {\n            return CompletableFuture.completedFuture(new PutMessageResult(lmqMsgCheckStatus, null));\n        }\n\n\n        long beginTime = this.getSystemClock().now();\n\t// 往commitLog中塞入消息（核心！！）\n        CompletableFuture<PutMessageResult> putResultFuture = this.commitLog.asyncPutMessage(msg);\n\n        putResultFuture.thenAccept((result) -> {\n            long elapsedTime = this.getSystemClock().now() - beginTime;\n            if (elapsedTime > 500) {\n                log.warn(\"putMessage not in lock elapsed time(ms)={}, bodyLength={}\", elapsedTime, msg.getBody().length);\n            }\n            this.storeStatsService.setPutMessageEntireTimeMax(elapsedTime);\n\n            if (null == result || !result.isOk()) {\n                this.storeStatsService.getPutMessageFailedTimes().add(1);\n            }\n        });\n\n        return putResultFuture;\n    }\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"最后通过RocketMQ的"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CommitLog"}]},{"type":"text","value":"将消息存储起来，延迟消息的秘密也在这里将会得到解答"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public CompletableFuture<PutMessageResult> asyncPutMessage(final MessageExtBrokerInner msg) {\n\t// .... 省略一些代码\n        if (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE\n                || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) {\n            // 如果设置的延迟等级>0,则表示需要延迟进行推送\n            if (msg.getDelayTimeLevel() > 0) {\n                if (msg.getDelayTimeLevel() > this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) {\n                    msg.setDelayTimeLevel(this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());\n                }\n\n                topic = TopicValidator.RMQ_SYS_SCHEDULE_TOPIC;\n                int queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());\n\n                // 保存真实的Topic和QueueId\n                MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());\n                MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));\n                msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));\n\t\t// 将topic修改成延迟队列的topic\n                msg.setTopic(topic);\n                msg.setQueueId(queueId);\n            }\n        }\n\t// ... 省略一些代码\n    }\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"RocketMQ实现延迟队列的方式大致和事务消息类似，让消息重写到一个"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Consumer"}]},{"type":"text","value":"无法监听的"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Topic"}]},{"type":"text","value":"中，这样就能够将延迟消息给保存下来"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"延迟投递原理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"通过IDEA 查看 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"TopicValidator#RMQ_SYS_SCHEDULE_TOPIC"}]},{"type":"text","value":",可以发现在"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"ScheduleMessageService"}]},{"type":"text","value":"中有去扫描这个Topic，看这个类名大概也能够猜出，是延迟投递的核心实现类。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"// ScheduleMessageService.java\npublic void start() {\n        if (started.compareAndSet(false, true)) {\n            this.load();\n            this.deliverExecutorService = new ScheduledThreadPoolExecutor(this.maxDelayLevel, new ThreadFactoryImpl(\"ScheduleMessageTimerThread_\"));\n            if (this.enableAsyncDeliver) {\n                this.handleExecutorService = new ScheduledThreadPoolExecutor(this.maxDelayLevel, new ThreadFactoryImpl(\"ScheduleMessageExecutorHandleThread_\"));\n            }\n            for (Map.Entry<Integer, Long> entry : this.delayLevelTable.entrySet()) {\n                Integer level = entry.getKey();\n                Long timeDelay = entry.getValue();\n                Long offset = this.offsetTable.get(level);\n                if (null == offset) {\n                    offset = 0L;\n                }\n\n                if (timeDelay != null) {\n                    if (this.enableAsyncDeliver) {\n                        this.handleExecutorService.schedule(new HandlePutResultTask(level), FIRST_DELAY_TIME, TimeUnit.MILLISECONDS);\n                    }\n\t\t    // 启动延迟队列，调度任务\n                    this.deliverExecutorService.schedule(new DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME, TimeUnit.MILLISECONDS);\n                }\n            }\n\n            this.deliverExecutorService.scheduleAtFixedRate(new Runnable() {\n\n                @Override\n                public void run() {\n                    try {\n                        if (started.get()) {\n\t\t\t// 将任务持久化到文件中去\n                            ScheduleMessageService.this.persist();\n                        }\n                    } catch (Throwable e) {\n                        log.error(\"scheduleAtFixedRate flush exception\", e);\n                    }\n                }\n            }, 10000, this.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval(), TimeUnit.MILLISECONDS);\n        }\n    }\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"通过线程启动了一个"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"DeliverDelayedMessageTimerTask"}]},{"type":"text","value":"来调度延迟消息。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"就是通过Java自带的延迟队列，来掉队队列中的消息，满足时间了则进行投递，将定时任务的Topic中移除，放入它原本的Topic中。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这样客户端就能够接收到消息的信息。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"总结"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"producer端设置消息delayLevel延迟级别，消息属性DELAY中存储了对应了延时级别"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"broker端收到消息后，判断延时消息延迟级别，如果大于0，则备份消息原始topic，queueId，并将消息topic改为延时消息队列特定topic(SCHEDULE_TOPIC)，queueId改为延时级别-1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"mq服务端ScheduleMessageService中，为每一个延迟级别单独设置一个定时器，定时(每隔1秒)拉取对应延迟级别的消费队列"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"根据消费偏移量offset从commitLog中解析出对应消息"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"从消息tagsCode中解析出消息应当被投递的时间，与当前时间做比较，判断是否应该进行投递"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"若到达了投递时间，则构建一个新的消息，并从消息属性中恢复出原始的topic，queueId，并清除消息延迟属性，从新进行消息投递"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"headings":[{"depth":1,"value":"RocketMQ延迟消息原理"},{"depth":1,"value":"使用场景"},{"depth":2,"value":"启动消费者等待传入订阅消息"},{"depth":2,"value":"发送延迟消息"},{"depth":1,"value":"原理分析"},{"depth":2,"value":"broker接收流程"},{"depth":2,"value":"延迟投递原理"},{"depth":1,"value":"总结"}],"path":"/posts/RocketMQ延迟消息原理"},"headings":[{"depth":1,"value":"RocketMQ延迟消息原理","slug":"rocketmq延迟消息原理"},{"depth":1,"value":"使用场景","slug":"使用场景"},{"depth":2,"value":"启动消费者等待传入订阅消息","slug":"启动消费者等待传入订阅消息"},{"depth":2,"value":"发送延迟消息","slug":"发送延迟消息"},{"depth":1,"value":"原理分析","slug":"原理分析"},{"depth":2,"value":"broker接收流程","slug":"broker接收流程"},{"depth":2,"value":"延迟投递原理","slug":"延迟投递原理"},{"depth":1,"value":"总结","slug":"总结-2"}]}},
    "staticQueryHashes": ["630634786","928362550"]}