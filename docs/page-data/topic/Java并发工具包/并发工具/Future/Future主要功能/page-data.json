{
    "componentChunkName": "component---src-templates-topic-page-template-tsx",
    "path": "/topic/Java并发工具包/并发工具/Future/Future主要功能",
    "result": {"pageContext":{"id":"/topic/Java并发工具包/并发工具/Future/Future主要功能","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"Future主要功能"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Future 最主要的作用是，比如当做一定运算的时候，运算过程可能比较耗时，有时会去查数据库，或是繁重的计算，比如压缩、加密等。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在这种情况下，如果我们一直在原地等待方法返回，显然是不明智的，整体程序的运行效率会大大降低。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们可以把运算的过程放到子线程去执行，再通过 Future 去控制子线程执行的计算过程，最后获取到计算结果。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这样一来就可以把整个程序的运行效率提高，是一种异步的思想。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Future接口"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Future代表着未来的计算结果。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"有一系列方法，比如检查检查计算结果是否完成，或者获取计算的结果。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public interface Future<V> {\n\n    boolean cancel(boolean mayInterruptIfRunning);\n\n    boolean isCancelled();\n\n    boolean isDone();\n\n    V get() throws InterruptedException, ExecutionException;\n\n    V get(long timeout, TimeUnit unit)\n\n        throws InterruptedException, ExecutionException, TimeoutExceptio\n\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"cancel方法: 取消任务执行"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"调用cancel方法有三种情况:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"任务还没有开始，直接取消"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"任务已经完成，或者已经被取消过了会返回false。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果任务正在执行，会根据mayInterruptIfRunning的状态来判断\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果为true，会强制将任务结束，执行任务会收到中断信号"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果为false，会在任务结束之后进行取消"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"isCancelled() 方法:判断是否被取消"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"和cancel配合使用，比较简单"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"isDown():判断是否执行完毕"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"返回有两种情况:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"返回值为false代表未完成"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"返回值为true,有两种情况\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"任务抛出了异常"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"任务正常执行完毕"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"最特殊的就是返回为true的情况，不代表任务是成功执行的，只代表执行完毕了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"get(): 获取结果"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"get 方法最主要的作用就是获取任务执行的结果，该方法在执行时的行为取决于 Callable 任务的状态，可能会发生以下 5 种情况。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"执行get的时候，任务已经执行完毕"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"可以立刻返回，获取到任务执行结果"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"任务还没有结果"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"线程池积压了很多任务，执行get的时候任务还没有开始"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"或者，任务开始执行了，但是执行时间较长，调用get的时候会将当前线程阻塞，直到任务完成再把结果返回回来"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"任务执行过程中抛出异常"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在调用get的时候，会抛出ExecutionException异常。不管执行的call方法里面抛出的异常类型是什么，执行get方法所获得的异常都是ExecutionException"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"任务被取消了"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果任务被取消，我们用 get 方法去获取结果时则会抛出 CancellationException。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"任务超时"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"get 方法有一个重载方法，那就是带延迟参数的，调用了这个带延迟参数的 get 方法之后，如果 call 方法在规定时间内正常顺利完成了任务，那么 get 会正常返回；但是如果到达了指定时间依然没有完成任务，get 方法则会抛出 TimeoutException，代表超时了。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"基础实现"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"FutureTask为Future提供了基础实现。FutureTask常用来封装Callable和Runable，也可以作为一个任务提交到线程池中执行。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"来看一下代码实现:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"传入callable作为构造函数，实际的执行逻辑在callable中"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public class FutureTask<V> implements RunnableFuture<V>{\n  ...\n  public FutureTask(Callable<V> callable) {\n        if (callable == null)\n            throw new NullPointerException();\n        this.callable = callable;\n        this.state = NEW;       // ensure visibility of callable\n    }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"可以看到，它实现了一个接口，这个接口叫作 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"RunnableFuture"}]},{"type":"text","value":"。我们再来看一下 RunnableFuture 接口的代码实现："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public interface RunnableFuture<V> extends Runnable, Future<V> {\n    void run();\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"他们的关系入下图所示:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/image-20211207205138417.png","alt":"image-20211207205138417"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"从此可以看出，FutureTask既可以作为Runable被线程执行，又可以作为Future得到Callable的返回值。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"FutureTask示例"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"直接使用:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public class FutureDemo {\n      public static void main(String[] args) {\n          ExecutorService executorService = Executors.newCachedThreadPool();\n          Future future = executorService.submit(new Callable<Object>() {\n              @Override\n              public Object call() throws Exception {\n                  Long start = System.currentTimeMillis();\n                  while (true) {\n                      Long current = System.currentTimeMillis();\n                     if ((current - start) > 1000) {\n                         return 1;\n                     }\n                 }\n             }\n         });\n  \n         try {\n             Integer result = (Integer)future.get();\n             System.out.println(result);\n         }catch (Exception e){\n             e.printStackTrace();\n         }\n     }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"还有配合线程的使用:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"第一种方式: Future + ExecutorService"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"第二种方式: FutureTask + ExecutorService"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"第三种方式: FutureTask + Thread"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"import java.util.concurrent.*;\npublic class CallDemo {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n \n        /**\n         * 第一种方式:Future + ExecutorService\n         * Task task = new Task();\n         * ExecutorService service = Executors.newCachedThreadPool();\n         * Future<Integer> future = service.submit(task1);\n         * service.shutdown();\n         */\n \n \n        /**\n         * 第二种方式: FutureTask + ExecutorService\n         * ExecutorService executor = Executors.newCachedThreadPool();\n         * Task task = new Task();\n         * FutureTask<Integer> futureTask = new FutureTask<Integer>(task);\n         * executor.submit(futureTask);\n         * executor.shutdown();\n         */\n \n        /**\n         * 第三种方式:FutureTask + Thread\n         */\n \n        // 2. 新建FutureTask,需要一个实现了Callable接口的类的实例作为构造函数参数\n        FutureTask<Integer> futureTask = new FutureTask<Integer>(new Task());\n        // 3. 新建Thread对象并启动\n        Thread thread = new Thread(futureTask);\n        thread.setName(\"Task thread\");\n        thread.start();\n \n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n \n        System.out.println(\"Thread [\" + Thread.currentThread().getName() + \"] is running\");\n \n        // 4. 调用isDone()判断任务是否结束\n        if(!futureTask.isDone()) {\n            System.out.println(\"Task is not done\");\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        int result = 0;\n        try {\n            // 5. 调用get()方法获取任务结果,如果任务没有执行完成则阻塞等待\n            result = futureTask.get();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n \n        System.out.println(\"result is \" + result);\n \n    }\n \n    // 1. 继承Callable接口,实现call()方法,泛型参数为要返回的类型\n    static class Task  implements Callable<Integer> {\n        @Override\n        public Integer call() throws Exception {\n            System.out.println(\"Thread [\" + Thread.currentThread().getName() + \"] is running\");\n            int result = 0;\n            for(int i = 0; i < 100;++i) {\n                result += i;\n            }\n \n            Thread.sleep(3000);\n            return result;\n        }\n    }\n}\n\n"}]}]}],"data":{"quirksMode":false}},"headings":[{"depth":1,"value":"Future主要功能","slug":"future主要功能"},{"depth":2,"value":"Future接口","slug":"future接口"},{"depth":3,"value":"cancel方法: 取消任务执行","slug":"cancel方法-取消任务执行"},{"depth":3,"value":"isCancelled() 方法:判断是否被取消","slug":"iscancelled-方法判断是否被取消"},{"depth":3,"value":"isDown():判断是否执行完毕","slug":"isdown判断是否执行完毕"},{"depth":3,"value":"get(): 获取结果","slug":"get-获取结果"},{"depth":2,"value":"基础实现","slug":"基础实现"},{"depth":3,"value":"FutureTask示例","slug":"futuretask示例"}]}},
    "staticQueryHashes": ["928362550"]}