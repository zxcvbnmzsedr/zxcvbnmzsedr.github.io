{
    "componentChunkName": "component---src-templates-article-page-template-tsx",
    "path": "/posts/Maven包管理",
    "result": {"pageContext":{"id":"/posts/Maven包管理","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"Maven包管理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"今天面试被问到maven包管理的机制。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A引用B A引用C ，B引用D1.0版本，C引用D2.0版本。。那么A引用的是1.0还是2.0\n这个问题没答上来，不过按照自己的多年的经验来进行推断，推断出来是依赖隔离那套，明显是有点问题。哈哈。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"平常在排查mavenjar冲突的时候，使用mvn dependency:tree找出有问题的jar,然后粗暴的用exclusion将出现问题的jar包给排除掉。还真没了解过其中奥妙。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"maven 是有两种规则来尽可能规避依赖冲突问题，广度优先 和 声明优先。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"广度优先"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"看下图这种依赖关系，最终项目中存在的是哪个？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{"className":["grvsc-container","dark-default-dark"],"dataLanguage":"","dataIndex":"0"},"children":[{"type":"element","tagName":"code","properties":{"className":["grvsc-code"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"A"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"├── B"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"│   └── C"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"│       └── D 2.0"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"└── E"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"    └── D 1.0"}]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"从A到D有两条路径，A->B->C->D 2.0 和 A->E->D 1.0 。根据广度优先的规则，先扫描到的是D 1.0 这个版本，后面再扫描到了D 2.0 就不会加入依赖，因此最后的版本是1.0;"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"声明优先"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"看下图这种依赖关系，最终项目中存在的是哪个？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{"className":["grvsc-container","dark-default-dark"],"dataLanguage":"","dataIndex":"1"},"children":[{"type":"element","tagName":"code","properties":{"className":["grvsc-code"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"A"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"├── B"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"│ └── D 2.0"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"└── C"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"    └── D 1.0"}]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"根据广度优先的理论，从A到D都是三层，A->B->D 2.0 和 A->C->D 1.0 。在扫描时发现有两个D，会将先声明的D 2.0 加入到依赖中，也就是D 2.0."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"依赖隔离"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{"className":["grvsc-container","dark-default-dark"],"dataLanguage":"","dataIndex":"2"},"children":[{"type":"element","tagName":"code","properties":{"className":["grvsc-code"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"A"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"├── B"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"│ └── D 2.0"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"└── C"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"    └── D 1.0"}]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"有的时候我们的jar在修改的时候没有考虑到兼容升级的问题，导致1.0和2.0的版本差异非常大。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这个时候，无论怎么修改jar版本其实都没有办法满足需求，其最好的方式还是采用C依赖D1.0，B依赖2.0。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"各依赖各自的版本，这样就不会出现jar冲突了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"目前有两个解决思路，打包时解决和运行时解决"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"打包时解决"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"maven-shade-plugin将B或者C打成一个独立的jar包来解决。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"maven-shade-plugin 在打包时，可以将项目中依赖的 jar 包中的一些类文件打包到项目构建生成的 jar 包中，在打包的时候把类重命名。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"运行时解决"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"运行时解决只有通过我们神奇的classLoader了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这块官方并没有什么比较好的解决方案。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"目前支付宝开源的sofa可以了解一下，"},{"type":"element","tagName":"a","properties":{"href":"https://www.sofastack.tech/projects/sofa-boot/sofa-ark-readme/"},"children":[{"type":"text","value":"https://www.sofastack.tech/projects/sofa-boot/sofa-ark-readme/"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"style","properties":{"className":["grvsc-styles"]},"children":[{"type":"text","value":"\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .dark-default-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .dark-default-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n"}]}],"data":{"quirksMode":false}},"html":"<h1 id=\"Maven包管理\">Maven包管理</h1>\n<p updated=\"20220705131435\">今天面试被问到maven包管理的机制。</p>\n<blockquote updated=\"20220705131435\">\n<p updated=\"20220705131435\">A引用B A引用C ，B引用D1.0版本，C引用D2.0版本。。那么A引用的是1.0还是2.0<br />\n这个问题没答上来，不过按照自己的多年的经验来进行推断，推断出来是依赖隔离那套，明显是有点问题。哈哈。</p>\n</blockquote>\n<p updated=\"20220705131435\">平常在排查mavenjar冲突的时候，使用mvn dependency:tree找出有问题的jar,然后粗暴的用exclusion将出现问题的jar包给排除掉。还真没了解过其中奥妙。</p>\n<p updated=\"20220705131435\">maven 是有两种规则来尽可能规避依赖冲突问题，广度优先 和 声明优先。</p>\n<h2 id=\"广度优先\">广度优先</h2>\n<p updated=\"20220705131435\">看下图这种依赖关系，最终项目中存在的是哪个？</p>\n<pre class=\"code-block\" data-language=\"\"><code class=\"hljs\">A\n├── B\n│   └── C\n│       └── D 2.0\n└── E\n    └── D 1.0\n</code></pre>\n<p updated=\"20220705131435\">从A到D有两条路径，A-&gt;B-&gt;C-&gt;D 2.0 和 A-&gt;E-&gt;D 1.0 。根据广度优先的规则，先扫描到的是D 1.0 这个版本，后面再扫描到了D 2.0 就不会加入依赖，因此最后的版本是1.0;</p>\n<h2 id=\"声明优先\">声明优先</h2>\n<p updated=\"20220705131435\">看下图这种依赖关系，最终项目中存在的是哪个？</p>\n<pre class=\"code-block\" data-language=\"\"><code class=\"hljs\">A\n├── B\n│ └── D 2.0\n└── C\n    └── D 1.0\n</code></pre>\n<p updated=\"20220705131435\">根据广度优先的理论，从A到D都是三层，A-&gt;B-&gt;D 2.0 和 A-&gt;C-&gt;D 1.0 。在扫描时发现有两个D，会将先声明的D 2.0 加入到依赖中，也就是D 2.0.</p>\n<h2 id=\"依赖隔离\">依赖隔离</h2>\n<pre class=\"code-block\" data-language=\"\"><code class=\"hljs\">A\n├── B\n│ └── D 2.0\n└── C\n    └── D 1.0\n</code></pre>\n<p updated=\"20220705131435\">有的时候我们的jar在修改的时候没有考虑到兼容升级的问题，导致1.0和2.0的版本差异非常大。</p>\n<p updated=\"20220705131435\">这个时候，无论怎么修改jar版本其实都没有办法满足需求，其最好的方式还是采用C依赖D1.0，B依赖2.0。</p>\n<p updated=\"20220705131435\">各依赖各自的版本，这样就不会出现jar冲突了。</p>\n<p updated=\"20220705131435\">目前有两个解决思路，打包时解决和运行时解决</p>\n<h2 id=\"打包时解决\">打包时解决</h2>\n<p updated=\"20220705131435\">maven-shade-plugin将B或者C打成一个独立的jar包来解决。</p>\n<p updated=\"20220705131435\">maven-shade-plugin 在打包时，可以将项目中依赖的 jar 包中的一些类文件打包到项目构建生成的 jar 包中，在打包的时候把类重命名。</p>\n<h2 id=\"运行时解决\">运行时解决</h2>\n<p updated=\"20220705131435\">运行时解决只有通过我们神奇的classLoader了。</p>\n<p updated=\"20220705131435\">这块官方并没有什么比较好的解决方案。</p>\n<p updated=\"20220705131435\">目前支付宝开源的sofa可以了解一下，https://www.sofastack.tech/projects/sofa-boot/sofa-ark-readme/</p>\n","articleNode":{"field":{"contentType":"posts","topic":null},"frontmatter":{"id":"/posts/Maven包管理","title":"Maven包管理","date":"2022-04-21 15:48","absolute_path":"/posts/Maven包管理"},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"Maven包管理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"今天面试被问到maven包管理的机制。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A引用B A引用C ，B引用D1.0版本，C引用D2.0版本。。那么A引用的是1.0还是2.0\n这个问题没答上来，不过按照自己的多年的经验来进行推断，推断出来是依赖隔离那套，明显是有点问题。哈哈。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"平常在排查mavenjar冲突的时候，使用mvn dependency:tree找出有问题的jar,然后粗暴的用exclusion将出现问题的jar包给排除掉。还真没了解过其中奥妙。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"maven 是有两种规则来尽可能规避依赖冲突问题，广度优先 和 声明优先。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"广度优先"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"看下图这种依赖关系，最终项目中存在的是哪个？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{"className":["grvsc-container","dark-default-dark"],"dataLanguage":"","dataIndex":"0"},"children":[{"type":"element","tagName":"code","properties":{"className":["grvsc-code"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"A"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"├── B"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"│   └── C"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"│       └── D 2.0"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"└── E"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"    └── D 1.0"}]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"从A到D有两条路径，A->B->C->D 2.0 和 A->E->D 1.0 。根据广度优先的规则，先扫描到的是D 1.0 这个版本，后面再扫描到了D 2.0 就不会加入依赖，因此最后的版本是1.0;"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"声明优先"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"看下图这种依赖关系，最终项目中存在的是哪个？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{"className":["grvsc-container","dark-default-dark"],"dataLanguage":"","dataIndex":"1"},"children":[{"type":"element","tagName":"code","properties":{"className":["grvsc-code"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"A"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"├── B"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"│ └── D 2.0"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"└── C"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"    └── D 1.0"}]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"根据广度优先的理论，从A到D都是三层，A->B->D 2.0 和 A->C->D 1.0 。在扫描时发现有两个D，会将先声明的D 2.0 加入到依赖中，也就是D 2.0."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"依赖隔离"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{"className":["grvsc-container","dark-default-dark"],"dataLanguage":"","dataIndex":"2"},"children":[{"type":"element","tagName":"code","properties":{"className":["grvsc-code"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"A"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"├── B"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"│ └── D 2.0"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"└── C"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["grvsc-line"]},"children":[{"type":"element","tagName":"span","properties":{"className":["grvsc-source"]},"children":[{"type":"text","value":"    └── D 1.0"}]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"有的时候我们的jar在修改的时候没有考虑到兼容升级的问题，导致1.0和2.0的版本差异非常大。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这个时候，无论怎么修改jar版本其实都没有办法满足需求，其最好的方式还是采用C依赖D1.0，B依赖2.0。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"各依赖各自的版本，这样就不会出现jar冲突了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"目前有两个解决思路，打包时解决和运行时解决"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"打包时解决"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"maven-shade-plugin将B或者C打成一个独立的jar包来解决。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"maven-shade-plugin 在打包时，可以将项目中依赖的 jar 包中的一些类文件打包到项目构建生成的 jar 包中，在打包的时候把类重命名。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"运行时解决"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"运行时解决只有通过我们神奇的classLoader了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这块官方并没有什么比较好的解决方案。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"目前支付宝开源的sofa可以了解一下，"},{"type":"element","tagName":"a","properties":{"href":"https://www.sofastack.tech/projects/sofa-boot/sofa-ark-readme/"},"children":[{"type":"text","value":"https://www.sofastack.tech/projects/sofa-boot/sofa-ark-readme/"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"style","properties":{"className":["grvsc-styles"]},"children":[{"type":"text","value":"\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .dark-default-dark {\n    background-color: #1E1E1E;\n    color: #D4D4D4;\n  }\n  .dark-default-dark .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n"}]}],"data":{"quirksMode":false}},"html":"<h1 id=\"Maven包管理\">Maven包管理</h1>\n<p updated=\"20220705131435\">今天面试被问到maven包管理的机制。</p>\n<blockquote updated=\"20220705131435\">\n<p updated=\"20220705131435\">A引用B A引用C ，B引用D1.0版本，C引用D2.0版本。。那么A引用的是1.0还是2.0<br />\n这个问题没答上来，不过按照自己的多年的经验来进行推断，推断出来是依赖隔离那套，明显是有点问题。哈哈。</p>\n</blockquote>\n<p updated=\"20220705131435\">平常在排查mavenjar冲突的时候，使用mvn dependency:tree找出有问题的jar,然后粗暴的用exclusion将出现问题的jar包给排除掉。还真没了解过其中奥妙。</p>\n<p updated=\"20220705131435\">maven 是有两种规则来尽可能规避依赖冲突问题，广度优先 和 声明优先。</p>\n<h2 id=\"广度优先\">广度优先</h2>\n<p updated=\"20220705131435\">看下图这种依赖关系，最终项目中存在的是哪个？</p>\n<pre class=\"code-block\" data-language=\"\"><code class=\"hljs\">A\n├── B\n│   └── C\n│       └── D 2.0\n└── E\n    └── D 1.0\n</code></pre>\n<p updated=\"20220705131435\">从A到D有两条路径，A-&gt;B-&gt;C-&gt;D 2.0 和 A-&gt;E-&gt;D 1.0 。根据广度优先的规则，先扫描到的是D 1.0 这个版本，后面再扫描到了D 2.0 就不会加入依赖，因此最后的版本是1.0;</p>\n<h2 id=\"声明优先\">声明优先</h2>\n<p updated=\"20220705131435\">看下图这种依赖关系，最终项目中存在的是哪个？</p>\n<pre class=\"code-block\" data-language=\"\"><code class=\"hljs\">A\n├── B\n│ └── D 2.0\n└── C\n    └── D 1.0\n</code></pre>\n<p updated=\"20220705131435\">根据广度优先的理论，从A到D都是三层，A-&gt;B-&gt;D 2.0 和 A-&gt;C-&gt;D 1.0 。在扫描时发现有两个D，会将先声明的D 2.0 加入到依赖中，也就是D 2.0.</p>\n<h2 id=\"依赖隔离\">依赖隔离</h2>\n<pre class=\"code-block\" data-language=\"\"><code class=\"hljs\">A\n├── B\n│ └── D 2.0\n└── C\n    └── D 1.0\n</code></pre>\n<p updated=\"20220705131435\">有的时候我们的jar在修改的时候没有考虑到兼容升级的问题，导致1.0和2.0的版本差异非常大。</p>\n<p updated=\"20220705131435\">这个时候，无论怎么修改jar版本其实都没有办法满足需求，其最好的方式还是采用C依赖D1.0，B依赖2.0。</p>\n<p updated=\"20220705131435\">各依赖各自的版本，这样就不会出现jar冲突了。</p>\n<p updated=\"20220705131435\">目前有两个解决思路，打包时解决和运行时解决</p>\n<h2 id=\"打包时解决\">打包时解决</h2>\n<p updated=\"20220705131435\">maven-shade-plugin将B或者C打成一个独立的jar包来解决。</p>\n<p updated=\"20220705131435\">maven-shade-plugin 在打包时，可以将项目中依赖的 jar 包中的一些类文件打包到项目构建生成的 jar 包中，在打包的时候把类重命名。</p>\n<h2 id=\"运行时解决\">运行时解决</h2>\n<p updated=\"20220705131435\">运行时解决只有通过我们神奇的classLoader了。</p>\n<p updated=\"20220705131435\">这块官方并没有什么比较好的解决方案。</p>\n<p updated=\"20220705131435\">目前支付宝开源的sofa可以了解一下，https://www.sofastack.tech/projects/sofa-boot/sofa-ark-readme/</p>\n","headings":[{"depth":1,"value":"Maven包管理"},{"depth":2,"value":"广度优先"},{"depth":2,"value":"声明优先"},{"depth":2,"value":"依赖隔离"},{"depth":2,"value":"打包时解决"},{"depth":2,"value":"运行时解决"}],"path":"/posts/Maven包管理"},"headings":[{"depth":1,"value":"Maven包管理","slug":"maven包管理"},{"depth":2,"value":"广度优先","slug":"广度优先"},{"depth":2,"value":"声明优先","slug":"声明优先"},{"depth":2,"value":"依赖隔离","slug":"依赖隔离"},{"depth":2,"value":"打包时解决","slug":"打包时解决"},{"depth":2,"value":"运行时解决","slug":"运行时解决"}]}},
    "staticQueryHashes": ["630634786","928362550"]}