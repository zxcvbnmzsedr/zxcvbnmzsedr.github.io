{
    "componentChunkName": "component---src-templates-topic-page-template-tsx",
    "path": "/topic/Java并发工具包/并发工具/Future/FutureTask源码分析",
    "result": {"pageContext":{"id":"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"FutureTask源码分析"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"FutureTask为future提供了基础实现，而且也是我们用的最多的实现方式。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"接下来，将会对FutureTask展开深入的分析。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"核心属性"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"    /**\n     * 任务的运行状态。\n     * 可能的状态转换:\n     * NEW -> COMPLETING -> NORMAL\n     * NEW -> COMPLETING -> EXCEPTIONAL\n     * NEW -> CANCELLED\n     * NEW -> INTERRUPTING -> INTERRUPTED\n     */\n    private volatile int state;\n    private static final int NEW          = 0;\n    private static final int COMPLETING   = 1;\n    private static final int NORMAL       = 2;\n    private static final int EXCEPTIONAL  = 3;\n    private static final int CANCELLED    = 4;\n    private static final int INTERRUPTING = 5;\n    private static final int INTERRUPTED  = 6;\n\n    /** 运行callable的线程，运行后清零 */\n    private Callable<V> callable;\n    /** 从get()中返回的结果或者异常 */\n    private Object outcome; // non-volatile, protected by state reads/writes\n    /** 运行callable的线程 */\n    private volatile Thread runner;\n    /** 使用Treiber保存等待线程 */\n    private volatile WaitNode waiters;\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"其中我们需要注意的就是state类型，是volatile类型的，任何一个线程修改了这个变量，那么其他所有的线程都会知道最新的值。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"7种状态:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"NEW"}]},{"type":"text","value":": 表示是一个新的任务或者还没有被执行完的状态。初始状态"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"COMPLETING"}]},{"type":"text","value":": 任务执行完，或者执行任务的时候发生异常，但是任务执行结果或者异常原因还没有被保存到outcome字段的时候，装填会从NEW->COMPLETING。这个状态时间很短，属于中间状态。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"NORMAL"}]},{"type":"text","value":":任务执行完，并且任务执行结果已经保存到outcome字段中，状态会从NEW -> COMPLETING -> NORMAL。最终态。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"EXCEPTIONAL"}]},{"type":"text","value":":任务执行发生异常，并且异常原因已经保存到outcome字段中，状态会从NEW -> COMPLETING -> EXCEPTIONAL。最终态。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CANCELLED"}]},{"type":"text","value":":任务还没有开始执行或者已经开始执行但是还没有执行完，此时用户调用了cancel(false)方法，"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"不中断任务"}]},{"type":"text","value":"执行的情况下取消线程执行。这个时候状态则是: NEW -> CANCELLED。最终态。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"INTERRUPTING"}]},{"type":"text","value":":任务还没有开始执行或者已经开始执行但是还没有执行完，此时用户调用了cancel(ture)方法，"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"中断任务"}]},{"type":"text","value":"执行并且还没有执行中断操作之前。这个时候状态则是: NEW -> INTERRUPTING。这是一个中间状态。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"INTERRUPTED"}]},{"type":"text","value":":调用interrupt()中断任务执行线程会到这个状态。NEW -> INTERRUPTING -> INTERRUPTED。这是一个最终态。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"值得注意的是，所有状态值大于COMPLETING的状态都是标识任务已经执行完成，无论是正常、异常、或者任务取消。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-mermaid"]},"children":[{"type":"text","value":"graph TD;\n    NEW-->COMPLETING;\n    COMPLETING-->NORMAL;\n    COMPLETING-->EXCEPTIONAL;\n    NEW-->CANCELLED;\n    NEW-->INTERRUPTING-->INTERRUPTED;\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"构造函数"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public FutureTask(Callable<V> callable) {\n        if (callable == null)\n            throw new NullPointerException();\n        this.callable = callable;\n        this.state = NEW;       // ensure visibility of callable\n    }\npublic FutureTask(Runnable runnable, V result) {\n        this.callable = Executors.callable(runnable, result);\n        this.state = NEW;       // ensure visibility of callable\n    }\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"可以在构造函数中看到，初始化的状态是NEW，和我们上文中写的一致。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"callable"}]},{"type":"text","value":":用来保存底层调用。如果直接传入runable，会将Runnable对象包装成callable对象，如果任务执行成功就会返回传入的result。如果不需要返回值，可以传入一个null。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"核心方法：Run()"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public void run() {\n  // 新建任务，CAS替换runner为当前线程。\n  if (state != NEW ||\n      !RUNNER.compareAndSet(this, null, Thread.currentThread()))\n    return;\n  try {\n    Callable<V> c = callable;\n    // 只有在初始状态的时候才进行执行\n    if (c != null && state == NEW) {\n      V result;\n      boolean ran;\n      try {\n        // 执行传入的操作\n        result = c.call();\n        ran = true;\n      } catch (Throwable ex) {\n        result = null;\n        ran = false;\n        // 如果发生异常，设置异常信息\n        // NEW -> COMPLETING -> EXCEPTIONAL\n        setException(ex);\n      }\n      if (ran)\n        // 如果正常执行完成，设置执行结果\n        // NEW -> COMPLETING -> NORMAL\n        set(result);\n    }\n  } finally {\n    // runner must be non-null until state is settled to\n    // prevent concurrent calls to run()\n    runner = null;\n    // state must be re-read after nulling runner to prevent\n    // leaked interrupts\n    int s = state;\n    if (s >= INTERRUPTING)。\n      handlePossibleCancellationInterrupt(s);\n  }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"说明:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"运行任务，如果任务状态为NEW状态，则利用CAS修改为当前线程，执行完毕调用set(result)设置执行结果。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"/**\n * 1. 通过CAS操作设置STATE的状态，NEW -> COMPLETING\n * 2. outcome复制为v\n * 3. 设置STATE为NOMAL，COMPLETING -> NOMAL\n * 4. 执行完毕，唤醒等待的县城\n */\nprotected void set(V v) {\n        if (STATE.compareAndSet(this, NEW, COMPLETING)) {\n            outcome = v;\n            STATE.setRelease(this, NORMAL); // final state\n            finishCompletion();\n        }\n    }\n"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"结果设置完毕调用finishCompletion()唤醒等待县城"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"\nprivate void finishCompletion() {\n        // assert state > COMPLETING;\n  \t\t\t// 确保当前状态是结果态，才能进行唤醒操作\n        for (WaitNode q; (q = waiters) != null;) {\n            if (WAITERS.weakCompareAndSet(this, q, null)) {\n                for (;;) { // 自旋便等待线程\n                    Thread t = q.thread;\n                    if (t != null) {\n                        q.thread = null;\n                      \t// 唤醒等待线程\n                        LockSupport.unpark(t);\n                    }\n                    WaitNode next = q.next;\n                    if (next == null)\n                        break;\n                  \t// 将非等待的线程设置为null，帮助GC\n                    q.next = null; // unlink to help gc\n                    q = next;\n                }\n                break;\n            }\n        }\n  \t\t\t// 任务完成后调用函数，自定义扩展\n        done();\n        callable = null;        // to reduce footprint\n    }\n"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果run的运行期间被中断，需要调用handlePossibleCancellationInterrupt来处理中断逻辑，确保任何中断(例如cancel(true))只停留在当前run或runAndReset的任务中"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"/**\n * Ensures that any interrupt from a possible cancel(true) is only\n * delivered to a task while in run or runAndReset.\n */\nprivate void handlePossibleCancellationInterrupt(int s) {\n    // It is possible for our interrupter to stall before getting a\n    // chance to interrupt us.  Let's spin-wait patiently.\n    // 在中断者中断线程之前可能会延迟，所以我们只需要让出CPU时间片自旋等待\n    if (s == INTERRUPTING)\n        while (state == INTERRUPTING)\n            Thread.yield(); // wait out pending interrupt\n\n    // assert state == INTERRUPTED;\n\n    // We want to clear any interrupt we may have received from\n    // cancel(true).  However, it is permissible to use interrupts\n    // as an independent mechanism for a task to communicate with\n    // its caller, and there is no way to clear only the\n    // cancellation interrupt.\n    //\n    // Thread.interrupted();\n}\n"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"核心方法:get()"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public V get() throws InterruptedException, ExecutionException {\n    int s = state;\n    if (s <= COMPLETING)\n      s = awaitDone(false, 0L);\n    return report(s);\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"说明: FutureTask通过get()方法获取任务执行结果。任务处于未完成的状态 state <= COMPLETEING，就调用awaitDown等待任务完成，通过report获取执行结果或者抛出异常。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"report方法比较简单，如果当前状态是正常的NORMAL，则直接返回结果。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果方法状态>=CANCELLED,也就是处于CANCELLED、INTERRUPTING、INTERRUPTED这三种状态的时候，抛出CancellationException，否则（状态为EXCEPTIONAL）就抛出业务异常"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"private V report(int s) throws ExecutionException {\n        Object x = outcome;\n        if (s == NORMAL)\n            return (V)x;\n        if (s >= CANCELLED)\n            throw new CancellationException();\n        throw new ExecutionException((Throwable)x);\n    }\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"核心方法:awaitDone(boolean timed,long nanos)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这个方法就是get方法阻塞的关键所在"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"\nprivate int awaitDone(boolean timed, long nanos)\n        throws InterruptedException {\n        long startTime = 0L;    // Special value 0L means not yet parked\n        WaitNode q = null;\n        boolean queued = false;\n        for (;;) {// 自旋\n            int s = state;\n            // 如果状态处于完成态，置空等待节点的线程，帮助GC\n            if (s > COMPLETING) {\n                if (q != null)\n                    q.thread = null;\n                return s;\n            }\n            else if (s == COMPLETING)\n              \t// 如果还在等待任务的执行结果，就yield()，暂时让出时间片，让其他线程执行\n                Thread.yield();\n            else if (Thread.interrupted()) {\n                // 如果线程被中断，则调用removeWaiter，移除节点避免堆积垃圾\n                removeWaiter(q);\n                throw new InterruptedException();\n            }\n            else if (q == null) {\n              \t// 如果等待时间为0 ，则意味着自旋一次就退出循环\n                if (timed && nanos <= 0L)\n                    return s;\n                q = new WaitNode();\n            }\n            else if (!queued)\n              \t// CAS修改waiter\n                queued = WAITERS.weakCompareAndSet(this, q.next = waiters, q);\n            else if (timed) {\n                // 统计超时时间\n                final long parkNanos;\n              \t// 首次循环，则初始化时间\n                if (startTime == 0L) { // first time\n                    startTime = System.nanoTime();\n                    if (startTime == 0L)\n                        startTime = 1L;\n                    parkNanos = nanos;\n                } else {\n                  \t// 后面的每次循环，都将记录运行时间\n                    long elapsed = System.nanoTime() - startTime;\n                    // 如果，超时了，就移除等待节点，返回节点状态回去\n                    if (elapsed >= nanos) {\n                        removeWaiter(q);\n                        return state;\n                    }\n                    parkNanos = nanos - elapsed;\n                }\n                // nanoTime may be slow; recheck before parking\n                // 如果，状态还处于未完成状态，阻塞当前线程\n                if (state < COMPLETING)\n                    LockSupport.parkNanos(this, parkNanos);\n            }\n            else\n                // 不记录时间的话，阻塞当前线程\n                LockSupport.park(this);\n        }\n    }\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果当前状态为结束状态(state>COMPLETING),则根据需要置空等待节点的线程，并返回 Future 状态；"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果当前状态为正在完成(COMPLETING)，说明此时 Future 还不能做出超时动作，为任务让出CPU执行时间片；"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果state为NEW，先新建一个WaitNode，然后CAS修改当前waiters；"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果等待超时，则调用removeWaiter移除等待节点，返回任务状态；如果设置了超时时间但是尚未超时，则park阻塞当前线程；"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"其他情况直接阻塞当前线程。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"核心方法:Cancel()"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public boolean cancel(boolean mayInterruptIfRunning) {\n //如果当前状态为NEW，根据参数修改状态为INTERRUPTING或CANCELLED\n  if (!(state == NEW && STATE.compareAndSet\n        (this, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))\n    return false;\n  try {    // in case call to interrupt throws exception\n    if (mayInterruptIfRunning) {\n      //可以在运行时中断\n      try {\n        Thread t = runner;\n        if (t != null)\n          t.interrupt();\n      } finally { // final state\n        STATE.setRelease(this, INTERRUPTED);\n      }\n    }\n  } finally {\n    finishCompletion();//移除并唤醒所有等待线程\n  }\n  return true;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"说明：尝试取消任务。如果任务已经完成或已经被取消，此操作会失败。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果当前Future状态为NEW，根据参数修改Future状态为INTERRUPTING或CANCELLED。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"如果当前状态不为NEW，则根据参数mayInterruptIfRunning决定是否在任务运行中也可以中断。中断操作完成后，调用finishCompletion移除并唤醒所有等待线程。"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"headings":[{"depth":1,"value":"FutureTask源码分析","slug":"futuretask源码分析"},{"depth":2,"value":"核心属性","slug":"核心属性"},{"depth":2,"value":"构造函数","slug":"构造函数"},{"depth":2,"value":"核心方法：Run()","slug":"核心方法run"},{"depth":2,"value":"核心方法:get()","slug":"核心方法get"},{"depth":2,"value":"核心方法:awaitDone(boolean timed,long nanos)","slug":"核心方法awaitdoneboolean-timedlong-nanos"},{"depth":2,"value":"核心方法:Cancel()","slug":"核心方法cancel"}]}},
    "staticQueryHashes": ["928362550"]}