{
    "componentChunkName": "component---src-templates-topic-page-template-tsx",
    "path": "/topic/Java并发工具包/并发基础/线程基础/生产者消费者模型",
    "result": {"pageContext":{"id":"/topic/Java并发工具包/并发基础/线程基础/生产者消费者模型","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"生产者消费者模型"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"生产者消费者模式"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"生产者消费者，是在软件开发中很常见的一种设计模式，大致结构如下图"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B.png","alt":"生产者消费者模型"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"生产者和消费者最核心的就是那个队列，用于平衡"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"生产者生产速度和消费者消费速度不一致"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"在队列满了之后，生产者则会阻塞，在队列空了之后，消费者则会阻塞。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"队列非空组则提醒消费者继续消费，队列非慢则提醒生产者继续生产"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"使用 BlockingQueue 实现生产者消费者模式"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"代码很简单"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"就是创建两个消费者线程和两个生产者线程，通过BlockQueue这个中间媒介，时期不断的进行生产-> 消费的循环"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public static void main(String[] args) {\n        BlockingQueue<Object> queue = new ArrayBlockingQueue<>(10);\n        Runnable producer = () -> {\n            while (true) {\n                try {\n                    queue.put(new Object());\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        };\n        new Thread(producer).start();\n        new Thread(producer).start();\n        Runnable consumer = () -> {\n            while (true) {\n                try {\n                    queue.take();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n\n        };\n        new Thread(consumer).start();\n        new Thread(consumer).start();\n    }\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"使用 Condition 实现生产者消费者模式"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们利用lock的Condition来实现一个简易版的BlockingQueue"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public static class MyBlockingQueueForCondition {\n        private Queue queue;\n        private int max = 16;\n        private ReentrantLock lock = new ReentrantLock();\n        private Condition notFull = lock.newCondition();\n        private Condition notEmpty = lock.newCondition();\n\n        public MyBlockingQueueForCondition(int max) {\n            this.max = max;\n            queue = new LinkedList();\n        }\n\n        public void put(Object v) throws InterruptedException {\n            lock.lock();\n            try {\n                while (queue.size() == max) {\n                    notFull.await();\n                }\n                queue.add(v);\n                notEmpty.signalAll();\n            } finally {\n                lock.unlock();\n            }\n        }\n\n        public Object take() throws InterruptedException {\n            lock.lock();\n            try {\n                while (queue.size() == 0) {\n                    notEmpty.await();\n                }\n                Object o = queue.remove();\n                notFull.signalAll();\n                return o;\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"最灵魂的操作是使用while循环来判断临界情况 ，"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"为什么不用if来进行判断"}]},{"type":"text","value":"?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在多个线程进入put操作的时候，发现队列已经满了，多个线程都进入等待状态，然后在notFull.signalAll()的时候多个线程都会调用add(v)操作，导致队列中的数量大于max的限定值;反之，同理。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"使用 wait/notify 实现生产者消费者模式"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"使用wait/notify的方式，是使用lock的方式相似。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"class MyBlockingQueue {\n\n   private int maxSize;\n\n   private LinkedList<Object> storage;\n\n   public MyBlockingQueue(int size) {\n\n       this.maxSize = size;\n\n       storage = new LinkedList<>();\n\n   }\n\n   public synchronized void put() throws InterruptedException {\n       while (storage.size() == maxSize) {\n           wait();\n       }\n       storage.add(new Object());\n       notifyAll();\n   }\n\n   public synchronized void take() throws InterruptedException {\n       while (storage.size() == 0) {\n           wait();\n       }\n       storage.poll();\n       notifyAll();\n   }\n\n}\n"}]}]}],"data":{"quirksMode":false}},"headings":[{"depth":1,"value":"生产者消费者模型","slug":"生产者消费者模型"},{"depth":2,"value":"生产者消费者模式","slug":"生产者消费者模式"},{"depth":2,"value":"使用 BlockingQueue 实现生产者消费者模式","slug":"使用-blockingqueue-实现生产者消费者模式"},{"depth":2,"value":"使用 Condition 实现生产者消费者模式","slug":"使用-condition-实现生产者消费者模式"},{"depth":2,"value":"使用 wait/notify 实现生产者消费者模式","slug":"使用-waitnotify-实现生产者消费者模式"}]}},
    "staticQueryHashes": ["928362550"]}