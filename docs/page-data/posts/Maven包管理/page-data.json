{
    "componentChunkName": "component---src-templates-article-page-template-tsx",
    "path": "/posts/Maven包管理",
    "result": {"pageContext":{"id":"/posts/Maven包管理","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"Maven包管理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"今天面试被问到maven包管理的机制。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A引用B A引用C ，B引用D1.0版本，C引用D2.0版本。。那么A引用的是1.0还是2.0\n这个问题没答上来，不过按照自己的多年的经验来进行推断，推断出来是依赖隔离那套，明显是有点问题。哈哈。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"平常在排查mavenjar冲突的时候，使用mvn dependency:tree找出有问题的jar,然后粗暴的用exclusion将出现问题的jar包给排除掉。还真没了解过其中奥妙。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"maven 是有两种规则来尽可能规避依赖冲突问题，广度优先 和 声明优先。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"广度优先"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"看下图这种依赖关系，最终项目中存在的是哪个？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"A\n├── B\n│   └── C\n│       └── D 2.0\n└── E\n    └── D 1.0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"从A到D有两条路径，A->B->C->D 2.0 和 A->E->D 1.0 。根据广度优先的规则，先扫描到的是D 1.0 这个版本，后面再扫描到了D 2.0 就不会加入依赖，因此最后的版本是1.0;"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"声明优先"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"看下图这种依赖关系，最终项目中存在的是哪个？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"A\n├── B\n│ └── D 2.0\n└── C\n    └── D 1.0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"根据广度优先的理论，从A到D都是三层，A->B->D 2.0 和 A->C->D 1.0 。在扫描时发现有两个D，会将先声明的D 2.0 加入到依赖中，也就是D 2.0."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"依赖隔离"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"A\n├── B\n│ └── D 2.0\n└── C\n    └── D 1.0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"有的时候我们的jar在修改的时候没有考虑到兼容升级的问题，导致1.0和2.0的版本差异非常大。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这个时候，无论怎么修改jar版本其实都没有办法满足需求，其最好的方式还是采用C依赖D1.0，B依赖2.0。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"各依赖各自的版本，这样就不会出现jar冲突了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"目前有两个解决思路，打包时解决和运行时解决"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"打包时解决"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"maven-shade-plugin将B或者C打成一个独立的jar包来解决。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"maven-shade-plugin 在打包时，可以将项目中依赖的 jar 包中的一些类文件打包到项目构建生成的 jar 包中，在打包的时候把类重命名。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"运行时解决"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"运行时解决只有通过我们神奇的classLoader了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这块官方并没有什么比较好的解决方案。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"目前支付宝开源的sofa可以了解一下，https://www.sofastack.tech/projects/sofa-boot/sofa-ark-readme/"}]}],"data":{"quirksMode":false}},"articleNode":{"field":{"contentType":"posts","topic":null},"frontmatter":{"id":"/posts/Maven包管理","title":"Maven包管理","date":"2022-04-21 15:48","absolute_path":"/posts/Maven包管理"},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"Maven包管理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"今天面试被问到maven包管理的机制。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"A引用B A引用C ，B引用D1.0版本，C引用D2.0版本。。那么A引用的是1.0还是2.0\n这个问题没答上来，不过按照自己的多年的经验来进行推断，推断出来是依赖隔离那套，明显是有点问题。哈哈。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"平常在排查mavenjar冲突的时候，使用mvn dependency:tree找出有问题的jar,然后粗暴的用exclusion将出现问题的jar包给排除掉。还真没了解过其中奥妙。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"maven 是有两种规则来尽可能规避依赖冲突问题，广度优先 和 声明优先。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"广度优先"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"看下图这种依赖关系，最终项目中存在的是哪个？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"A\n├── B\n│   └── C\n│       └── D 2.0\n└── E\n    └── D 1.0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"从A到D有两条路径，A->B->C->D 2.0 和 A->E->D 1.0 。根据广度优先的规则，先扫描到的是D 1.0 这个版本，后面再扫描到了D 2.0 就不会加入依赖，因此最后的版本是1.0;"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"声明优先"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"看下图这种依赖关系，最终项目中存在的是哪个？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"A\n├── B\n│ └── D 2.0\n└── C\n    └── D 1.0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"根据广度优先的理论，从A到D都是三层，A->B->D 2.0 和 A->C->D 1.0 。在扫描时发现有两个D，会将先声明的D 2.0 加入到依赖中，也就是D 2.0."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"依赖隔离"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"A\n├── B\n│ └── D 2.0\n└── C\n    └── D 1.0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"有的时候我们的jar在修改的时候没有考虑到兼容升级的问题，导致1.0和2.0的版本差异非常大。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这个时候，无论怎么修改jar版本其实都没有办法满足需求，其最好的方式还是采用C依赖D1.0，B依赖2.0。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"各依赖各自的版本，这样就不会出现jar冲突了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"目前有两个解决思路，打包时解决和运行时解决"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"打包时解决"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"maven-shade-plugin将B或者C打成一个独立的jar包来解决。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"maven-shade-plugin 在打包时，可以将项目中依赖的 jar 包中的一些类文件打包到项目构建生成的 jar 包中，在打包的时候把类重命名。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"运行时解决"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"运行时解决只有通过我们神奇的classLoader了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这块官方并没有什么比较好的解决方案。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"目前支付宝开源的sofa可以了解一下，https://www.sofastack.tech/projects/sofa-boot/sofa-ark-readme/"}]}],"data":{"quirksMode":false}},"headings":[{"depth":1,"value":"Maven包管理"},{"depth":2,"value":"广度优先"},{"depth":2,"value":"声明优先"},{"depth":2,"value":"依赖隔离"},{"depth":2,"value":"打包时解决"},{"depth":2,"value":"运行时解决"}],"path":"/posts/Maven包管理"},"headings":[{"depth":1,"value":"Maven包管理","slug":"maven包管理"},{"depth":2,"value":"广度优先","slug":"广度优先"},{"depth":2,"value":"声明优先","slug":"声明优先"},{"depth":2,"value":"依赖隔离","slug":"依赖隔离"},{"depth":2,"value":"打包时解决","slug":"打包时解决"},{"depth":2,"value":"运行时解决","slug":"运行时解决"}]}},
    "staticQueryHashes": ["630634786","928362550"]}