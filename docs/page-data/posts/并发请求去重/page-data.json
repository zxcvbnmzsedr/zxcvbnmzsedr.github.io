{
    "componentChunkName": "component---src-templates-article-page-template-tsx",
    "path": "/posts/并发请求去重",
    "result": {"pageContext":{"id":"/posts/并发请求去重","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"并发请求去重"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"背景"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"一些请求在某种情况下，会导致重复请求，比如:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Nginx反向代理下游服务器，下游服务器超时自动故障转移进行重试"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"前端按钮重复点击，没有做处理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"分布式环境下，请求出现错误进行重试"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"甚至于"},{"type":"element","tagName":"a","properties":{"href":"https://zh.wikipedia.org/wiki/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB"},"children":[{"type":"text","value":"重放攻击"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因此，对于后端来说需要统一去处理这种情况。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"利用唯一编号进行去重"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在分布式环境下，我们可以借助Redis来进行数据去重,伪代码如下:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"fun 是否第一次访问(key){\n    if (redis.setKey(key,key,超时时间)){\n\treturn true\n    }else {\n\treturn false\n    }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以，目前的问题就是这个关键的key怎么生成"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"提前下发"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们可以提供一个接口，提前下发一个key下去，在请求的时候带上这个key就可以完成重复接口的判断"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但是这种方式会导致开发成本变大，不太适合用这个"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"唯一索引"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"数据库处理就是设置唯一索引，可设联合唯一索引用来处理重复数据。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"缺点：如果业务场景就是应该存储重复的数据，则该种方式不可用。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"业务参数去重"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"主流的方式都是采用业务参数进行去重"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们可以对请求的参数进行一个升序排序，拼接成一个字符串，然后字符串转成MD5来作为请求的key。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"代码如下："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因为用的是SpringMVC来做处理，参数都是用Bean来声明，所以加密的时候可以去掉排序这项，因为反序列化的顺序就是Bean中的顺序"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RepeatableCommit {\n\n    /**\n     * 根据UserId限制重复提交\n     * 取不到 ID 会报错\n     */\n    boolean userId() default true;\n\n    /**\n     * 用于定义区别重复提交的Key SPEl语法描述，就和CacheAble一样\n     * <p>\n     * 默认直接按照整个类去区分\n     */\n    String key() default \"\";\n\n    /**\n     * 指定时间内不可重复提交,单位毫秒\n     */\n    long timeout() default 3000;\n}\n\n@Aspect\n@Component\npublic class RepeatableCommitAspect {\n\n    @Autowired\n    private RedisConnectionFactory redisConnectionFactory;\n\n    @Around(\"@annotation(com.easysoft.puyao.config.RepeatableCommit)\")\n    public Object around(ProceedingJoinPoint point) throws Throwable {\n        MethodSignature signature = (MethodSignature) point.getSignature();\n        Method method = signature.getMethod();\n        RepeatableCommit commitAnnotation = method.getAnnotation(RepeatableCommit.class);\n        String[] parameterNames = new LocalVariableTableParameterNameDiscoverer().getParameterNames(signature.getMethod());\n\n\n        String className = method.getDeclaringClass().getName();\n        String commitKey = handlerKey(commitAnnotation.key(), parameterNames, point.getArgs());\n\n        String key;\n\n        if (commitAnnotation.userId()) {\n            String userId = BaseContextHandler.getUserId();\n            if (userId == null) {\n                throw new BizRuntimeException(API_REQUEST_LIMIT_ERROR, \"请求失败，UserID不能为空\");\n            }\n            key = StrUtil.format(\"{}_{}_{}\", className, commitKey, userId);\n        } else {\n            key = StrUtil.format(\"{}_{}\", className, commitKey);\n        }\n\n\n        long timeout = commitAnnotation.timeout();\n        RedisLockRegistry redisLockRegistry = new RedisLockRegistry(redisConnectionFactory, \"new_king\", timeout);\n\n        Lock lock = redisLockRegistry.obtain(\"lock:\" + key);\n        if (!lock.tryLock()) {\n            throw new BizRuntimeException(API_REQUEST_LIMIT_ERROR, \"重复请求\");\n        }\n        //执行方法\n        return point.proceed();\n    }\n\n    /**\n     * 处理用于过滤重复请求的key\n     */\n    private String handlerKey(String key, String[] params, Object[] args) {\n        if (StringUtils.isEmpty(key)) {\n            return SecureUtil.md5(JSONObject.toJSONString(args));\n        }\n        Object request = getRequest(key, params, args);\n        return SecureUtil.md5(JSONObject.toJSONString(request));\n    }\n\n    /**\n     * 通过spring Spel 获取参数\n     *\n     * @param key            定义的key值 以#开头 例如:#user\n     * @param parameterNames 形参\n     * @param values         形参值\n     * @return\n     */\n    public Object getRequest(String key, String[] parameterNames, Object[] values) {\n\n        //spel解析器\n        ExpressionParser parser = new SpelExpressionParser();\n        //spel上下文\n        EvaluationContext context = new StandardEvaluationContext();\n        for (int i = 0; i < parameterNames.length; i++) {\n            context.setVariable(parameterNames[i], values[i]);\n        }\n        return parser.parseExpression(key).getValue(context);\n    }\n}\n"}]}]}],"data":{"quirksMode":false}},"articleNode":{"field":{"contentType":"posts","topic":null},"frontmatter":{"id":"/posts/并发请求去重","title":"并发请求去重","date":"2022-05-25 20:17","absolute_path":"/posts/并发请求去重"},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"并发请求去重"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"背景"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"一些请求在某种情况下，会导致重复请求，比如:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Nginx反向代理下游服务器，下游服务器超时自动故障转移进行重试"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"前端按钮重复点击，没有做处理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"分布式环境下，请求出现错误进行重试"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"甚至于"},{"type":"element","tagName":"a","properties":{"href":"https://zh.wikipedia.org/wiki/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB"},"children":[{"type":"text","value":"重放攻击"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因此，对于后端来说需要统一去处理这种情况。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"利用唯一编号进行去重"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在分布式环境下，我们可以借助Redis来进行数据去重,伪代码如下:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"fun 是否第一次访问(key){\n    if (redis.setKey(key,key,超时时间)){\n\treturn true\n    }else {\n\treturn false\n    }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以，目前的问题就是这个关键的key怎么生成"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"提前下发"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们可以提供一个接口，提前下发一个key下去，在请求的时候带上这个key就可以完成重复接口的判断"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但是这种方式会导致开发成本变大，不太适合用这个"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"唯一索引"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"数据库处理就是设置唯一索引，可设联合唯一索引用来处理重复数据。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"缺点：如果业务场景就是应该存储重复的数据，则该种方式不可用。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"业务参数去重"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"主流的方式都是采用业务参数进行去重"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们可以对请求的参数进行一个升序排序，拼接成一个字符串，然后字符串转成MD5来作为请求的key。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"代码如下："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因为用的是SpringMVC来做处理，参数都是用Bean来声明，所以加密的时候可以去掉排序这项，因为反序列化的顺序就是Bean中的顺序"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RepeatableCommit {\n\n    /**\n     * 根据UserId限制重复提交\n     * 取不到 ID 会报错\n     */\n    boolean userId() default true;\n\n    /**\n     * 用于定义区别重复提交的Key SPEl语法描述，就和CacheAble一样\n     * <p>\n     * 默认直接按照整个类去区分\n     */\n    String key() default \"\";\n\n    /**\n     * 指定时间内不可重复提交,单位毫秒\n     */\n    long timeout() default 3000;\n}\n\n@Aspect\n@Component\npublic class RepeatableCommitAspect {\n\n    @Autowired\n    private RedisConnectionFactory redisConnectionFactory;\n\n    @Around(\"@annotation(com.easysoft.puyao.config.RepeatableCommit)\")\n    public Object around(ProceedingJoinPoint point) throws Throwable {\n        MethodSignature signature = (MethodSignature) point.getSignature();\n        Method method = signature.getMethod();\n        RepeatableCommit commitAnnotation = method.getAnnotation(RepeatableCommit.class);\n        String[] parameterNames = new LocalVariableTableParameterNameDiscoverer().getParameterNames(signature.getMethod());\n\n\n        String className = method.getDeclaringClass().getName();\n        String commitKey = handlerKey(commitAnnotation.key(), parameterNames, point.getArgs());\n\n        String key;\n\n        if (commitAnnotation.userId()) {\n            String userId = BaseContextHandler.getUserId();\n            if (userId == null) {\n                throw new BizRuntimeException(API_REQUEST_LIMIT_ERROR, \"请求失败，UserID不能为空\");\n            }\n            key = StrUtil.format(\"{}_{}_{}\", className, commitKey, userId);\n        } else {\n            key = StrUtil.format(\"{}_{}\", className, commitKey);\n        }\n\n\n        long timeout = commitAnnotation.timeout();\n        RedisLockRegistry redisLockRegistry = new RedisLockRegistry(redisConnectionFactory, \"new_king\", timeout);\n\n        Lock lock = redisLockRegistry.obtain(\"lock:\" + key);\n        if (!lock.tryLock()) {\n            throw new BizRuntimeException(API_REQUEST_LIMIT_ERROR, \"重复请求\");\n        }\n        //执行方法\n        return point.proceed();\n    }\n\n    /**\n     * 处理用于过滤重复请求的key\n     */\n    private String handlerKey(String key, String[] params, Object[] args) {\n        if (StringUtils.isEmpty(key)) {\n            return SecureUtil.md5(JSONObject.toJSONString(args));\n        }\n        Object request = getRequest(key, params, args);\n        return SecureUtil.md5(JSONObject.toJSONString(request));\n    }\n\n    /**\n     * 通过spring Spel 获取参数\n     *\n     * @param key            定义的key值 以#开头 例如:#user\n     * @param parameterNames 形参\n     * @param values         形参值\n     * @return\n     */\n    public Object getRequest(String key, String[] parameterNames, Object[] values) {\n\n        //spel解析器\n        ExpressionParser parser = new SpelExpressionParser();\n        //spel上下文\n        EvaluationContext context = new StandardEvaluationContext();\n        for (int i = 0; i < parameterNames.length; i++) {\n            context.setVariable(parameterNames[i], values[i]);\n        }\n        return parser.parseExpression(key).getValue(context);\n    }\n}\n"}]}]}],"data":{"quirksMode":false}},"headings":[{"depth":1,"value":"并发请求去重"},{"depth":1,"value":"背景"},{"depth":1,"value":"利用唯一编号进行去重"},{"depth":2,"value":"提前下发"},{"depth":2,"value":"唯一索引"},{"depth":2,"value":"业务参数去重"}],"path":"/posts/并发请求去重"},"headings":[{"depth":1,"value":"并发请求去重","slug":"并发请求去重"},{"depth":1,"value":"背景","slug":"背景"},{"depth":1,"value":"利用唯一编号进行去重","slug":"利用唯一编号进行去重"},{"depth":2,"value":"提前下发","slug":"提前下发"},{"depth":2,"value":"唯一索引","slug":"唯一索引"},{"depth":2,"value":"业务参数去重","slug":"业务参数去重"}]}},
    "staticQueryHashes": ["630634786","928362550"]}