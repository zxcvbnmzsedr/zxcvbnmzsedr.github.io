{"componentChunkName":"component---src-templates-topic-post-template-js","path":"/topic/redis/Redis集群/Redis数据删除策略","result":{"data":{"siYuan":{"excerpt":"Redis数据删除策略 Redis可以对Key设置过期时间，如果Key到过期时间，Redis是如何删除的？ Redis会将过期时间的键和过期时间存放到一个字典当中。当我们查询一个键时，redis首先检查是否在过期字典当中，如果存在，则获取其...","raw":"# Redis数据删除策略\n\nRedis可以对Key设置过期时间，如果Key到过期时间，Redis是如何删除的？\n\nRedis会将过期时间的键和过期时间存放到一个字典当中。当我们查询一个键时，redis首先检查是否在过期字典当中，如果存在，则获取其过期时间，然后将过期时间和当前时间进行对比，如果比当前时间大则认定过期，否则则认定没有过期。\n\nRedis采用惰性删除+定期删除\n\n|删除模式|优点|缺点|\n| :------: | :-----------------------------------------------------------------------------------------------------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |\n|惰性删除|对 CPU友好，<br />我们只会在使用该键时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。|如果一个键已经过期，但是一直没有使用，<br />该键就会一直存在内存中，内存永远不会释放。<br />如有较多这样的过期键，容易造成内存泄漏。|\n|定期删除|可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。<br />另外定期删除，也能有效释放过期键占用的内存。|难以确定删除操作执行的时长和频率。<br />如果执行的太频繁对CPU不友好。<br />如果执行频率过低，那又和惰性删除一样了，<br />过期键占用的内存不会及时得到释放。<br />另外最重要的是，在获取某个键时，如果某个键的过期时间已经到了，但是还没执行定期删除，那么就会返回这个键的值，这是业务不能忍受的错误。|\n\n# 惰性删除\n\n```mermaid\nflowchart TD;\n\tA(所有读写数据库的命令) --> B(调用expireIfNeeded方法)\n\tB-->C{输入键已过期?}\n\tC-->|是|D(删除键)\n\tC-->|否|E(执行实际流程)\n\tD-->E\n```\n\n```c\nint expireIfNeeded(redisDb *db, robj *key) {\n    // 键未过期返回0\n    if (!keyIsExpired(db,key)) return 0;\n    // 如果运行在从节点上，直接返回1，因为从节点不执行删除操作\n    if (server.masterhost != NULL) return 1;\n    // 运行到这里，表示键带有过期时间且运行在主节点上\n    // 删除过期键个数\n    server.stat_expiredkeys++;\n    // 向从节点和AOF文件传播过期信息\n    propagateExpire(db,key,server.lazyfree_lazy_expire);\n    // 发送事件通知\n    notifyKeyspaceEvent(NOTIFY_EXPIRED,\n        \"expired\",key,db->id);\n    // 根据配置（默认是同步删除）判断是否采用惰性删除（这里的惰性删除是指采用后台线程处理删除操做，这样会减少卡顿）\n    int retval = server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :\n                                               dbSyncDelete(db,key);\n    if (retval) signalModifiedKey(NULL,db,key);\n    return retval;\n}\n```\n\n# 定期删除\n\n定期策略是每隔一段时间执行一次删除过期键的操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU 时间的影响，同时也减少了内存浪费\n\nRedis 默认会每秒进行 10 次（redis.conf 中通过 hz 配置）过期扫描，扫描并不是遍历过期字典中的所有键，而是采用了如下方法\n\n1. 从过期字典中随机取出 20 个键(ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP)\n2. 删除这 20 个键中过期的键\n3. 如果过期键的比例超过 25% ，重复步骤 1 和 2\n\n为了保证扫描不会出现循环过度，导致线程卡死现象，还增加了扫描时间的上限，默认是 25 毫秒(ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC)（即默认在慢模式下，如果是快模式，扫描上限是 1 毫秒）\n\n从定期回收策略的慢速检查中，我们可以看到，redis 处理到期数据，通过采样，判断到期数据的密集度。到期数据越密集，处理时间越多。我们使用中，不应该把大量数据设置在同一个时间段到期。\n\n底层源码实现:\n\n```c\nvoid activeExpireCycle(int type) {\n    /* Adjust the running parameters according to the configured expire\n     * effort. The default effort is 1, and the maximum configurable effort\n     * is 10. */\n    unsigned long\n    // 努力力度，默认 1，也就是遍历过期字典的力度，力度越大，遍历数量越多，但是性能损耗更多。\n    effort = server.active_expire_effort-1, /* Rescale from 0 to 9. */\n    // 每次循环遍历键值个数。力度越大，遍历个数越多。\n    config_keys_per_loop = ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP +\n                           ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP/4*effort,\n    // 快速遍历时间范围，力度越大，给予遍历时间越多。\n    config_cycle_fast_duration = ACTIVE_EXPIRE_CYCLE_FAST_DURATION +\n                                 ACTIVE_EXPIRE_CYCLE_FAST_DURATION/4*effort,\n    // 慢速遍历检查时间片\n    config_cycle_slow_time_perc = ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC +\n                                  2*effort,\n    // 已经到期数据 / 检查数据 比例。达到可以接受的比例。\n    config_cycle_acceptable_stale = ACTIVE_EXPIRE_CYCLE_ACCEPTABLE_STALE-\n                                    effort;\n\n    /* This function has some global state in order to continue the work\n     * incrementally across calls. */\n    static unsigned int current_db = 0; /* Last DB tested. */\n    // 检查是否已经超时。\n    static int timelimit_exit = 0;      /* Time limit hit in previous call? */\n    // 上一次快速检查数据起始时间。\n    static long long last_fast_cycle = 0; /* When last fast cycle ran. */\n\n    // iteration 迭代检查个数，每 16 次循环遍历，确认一下是否检查超时。\n    int j, iteration = 0;\n    // 每次周期检查的数据库个数。redis 默认有 16 个库。\n    int dbs_per_call = CRON_DBS_PER_CALL;\n    long long start = ustime(), timelimit, elapsed;\n\n    /* When clients are paused the dataset should be static not just from the\n     * POV of clients not being able to write, but also from the POV of\n     * expires and evictions of keys not being performed. */\n    /* 如果链接已经停止了，那么要保留现场，不允许修改数据，也不允许到期淘汰数据。\n     * 使用命令 ‘pause’ 暂停 redis 工作或者主服务正在进行从服务的故障转移。*/\n    if (clientsArePaused()) return;\n\n    if (type == ACTIVE_EXPIRE_CYCLE_FAST) {\n        /* 检查还没超时，但是到期数据密集度已经达到了可以接受的范围，不要快速检查了，\n           毕竟它是快速的，留给其它方式的检查。*/\n        if (!timelimit_exit &&\n            server.stat_expired_stale_perc < config_cycle_acceptable_stale)\n            return;\n        /* 限制快速检查频次，在两个 config_cycle_fast_duration 内，只能执行一次快速检查。 */\n        if (start < last_fast_cycle + (long long)config_cycle_fast_duration*2)\n            return;\n\n        last_fast_cycle = start;\n    }\n\n    /* We usually should test CRON_DBS_PER_CALL per iteration, with\n     * two exceptions:\n     *\n     * 1) Don't test more DBs than we have.\n     * 2) If last time we hit the time limit, we want to scan all DBs\n     * in this iteration, as there is work to do in some DB and we don't want\n     * expired keys to use memory for too much time. */\n    if (dbs_per_call > server.dbnum || timelimit_exit)\n        dbs_per_call = server.dbnum;\n\n    /* 检查过期数据，但是不能太损耗资源，得有个限制。server.hz 默认为 10\n      hz 是执行后台任务的频率，越大表明执行的次数越频繁，一般用默认值 10 */\n    timelimit = config_cycle_slow_time_perc*1000000/server.hz/100;\n    timelimit_exit = 0;\n    if (timelimit <= 0) timelimit = 1;\n    // 如果是快速模式，更改检查周期时间。\n    if (type == ACTIVE_EXPIRE_CYCLE_FAST)\n        timelimit = config_cycle_fast_duration; /* in microseconds. */\n\n\n    /* 过期数据一般是异步方式，检查到过期数据，都是从字典中移除键值信息，\n     * 避免再次使用，但是数据回收放在后台回收，不是实时的，有数据有可能还存在数据库里。*/\n    // 检查数据个数。\n    long total_sampled = 0;\n    // 检查数据，数据已经过期的个数。\n    long total_expired = 0;\n\n    for (j = 0; j < dbs_per_call && timelimit_exit == 0; j++) {\n        /* Expired and checked in a single loop. */\n        unsigned long expired, sampled;\n\n        redisDb *db = server.db+(current_db % server.dbnum);\n\n        /* Increment the DB now so we are sure if we run out of time\n         * in the current DB we'll restart from the next. This allows to\n         * distribute the time evenly across DBs. */\n        current_db++;\n\n        /* Continue to expire if at the end of the cycle there are still\n         * a big percentage of keys to expire, compared to the number of keys\n         * we scanned. The percentage, stored in config_cycle_acceptable_stale\n         * is not fixed, but depends on the Redis configured \"expire effort\". */\n        // 遍历数据库检查过期数据，直到超出检查周期时间，或者过期数据比例已经很少了。\n        do {\n            // num 数据量，slots 哈希表大小（字典数据如果正在迁移，双表大小）\n            unsigned long num, slots;\n            long long now, ttl_sum;\n            int ttl_samples;\n            iteration++;\n\n            /* If there is nothing to expire try next DB ASAP. */\n            if ((num = dictSize(db->expires)) == 0) {\n                db->avg_ttl = 0;\n                break;\n            }\n            slots = dictSlots(db->expires);\n            now = mstime();\n\n            /* 过期存储数据结构是字典，数据经过处理后，字典存储的数据可能已经很少，\n            * 但是字典还是大字典，这样遍历数据有效命中率会很低，处理起来会浪费资源，\n            * 后面的访问会很快触发字典的缩容，缩容后再进行处理效率更高。*/\n            if (num && slots > DICT_HT_INITIAL_SIZE &&\n                (num*100/slots < 1)) break;\n\n            // 过期的数据个数。\n            expired = 0;\n            // 检查的数据个数。\n            sampled = 0;\n            // 没有过期的数据时间差之和。\n            ttl_sum = 0;\n            // 没有过期的数据个数。\n            ttl_samples = 0;\n\n            // 每次检查的数据限制。\n            if (num > config_keys_per_loop)\n                num = config_keys_per_loop;\n\n            /* 哈希表本质上是一个数组，可能有键值碰撞的数据，用链表将碰撞数据串联起来，\n            * 放在一个数组下标下，也就是放在哈希表的一个桶里。max_buckets 是最大能检查的桶个数。\n            * 跳过空桶，不处理。*/\n            long max_buckets = num*20;\n            // 当前已经检查哈希表桶的个数。\n            long checked_buckets = 0;\n            // 一个桶上有可能有多个数据。所以检查从两方面限制：一个是数据量，一个是桶的数量。\n            while (sampled < num && checked_buckets < max_buckets) {\n                for (int table = 0; table < 2; table++) {\n                    // 如果 dict 没有正在进行扩容，不需要检查它的第二张表了。\n                    if (table == 1 && !dictIsRehashing(db->expires)) break;\n\n                    unsigned long idx = db->expires_cursor;\n                    idx &= db->expires->ht[table].sizemask;\n                    dictEntry *de = db->expires->ht[table].table[idx];\n                    long long ttl;\n\n                    // 检查数据是否已经超时。\n                    checked_buckets++;\n                    while(de) {\n                        /* Get the next entry now since this entry may get\n                         * deleted. */\n                        dictEntry *e = de;\n                        de = de->next;\n\n                        ttl = dictGetSignedIntegerVal(e)-now;\n                        // 如果数据过期了，进行回收处理。\n                        if (activeExpireCycleTryExpire(db,e,now)) expired++;\n                        if (ttl > 0) {\n                            /* We want the average TTL of keys yet\n                             * not expired. */\n                            ttl_sum += ttl;\n                            ttl_samples++;\n                        }\n                        sampled++;\n                    }\n                }\n                db->expires_cursor++;\n            }\n            total_expired += expired;\n            total_sampled += sampled;\n\n            /* Update the average TTL stats for this database. */\n            if (ttl_samples) {\n                long long avg_ttl = ttl_sum/ttl_samples;\n\n                /* Do a simple running average with a few samples.\n                 * We just use the current estimate with a weight of 2%\n                 * and the previous estimate with a weight of 98%. */\n                if (db->avg_ttl == 0) db->avg_ttl = avg_ttl;\n                // 对没过期的数据，平均过期时间进行采样，上一次统计的平均时间占 98 %，本次占 2%。\n                db->avg_ttl = (db->avg_ttl/50)*49 + (avg_ttl/50);\n            }\n\n            /* We can't block forever here even if there are many keys to\n             * expire. So after a given amount of milliseconds return to the\n             * caller waiting for the other active expire cycle. */\n            /* 避免检查周期太长，当前数据库每 16 次循环迭代检查，检查是否超时，超时退出。*/\n            if ((iteration & 0xf) == 0) { /* check once every 16 iterations. */\n                elapsed = ustime()-start;\n                if (elapsed > timelimit) {\n                    timelimit_exit = 1;\n                    server.stat_expired_time_cap_reached_count++;\n                    break;\n                }\n            }\n            /* 当前数据库，如果没有检查到数据，或者过期数据已经达到可接受比例\n             * 就退出该数据库检查，进入到下一个数据库检查。*/\n        } while (sampled == 0 ||\n                 (expired*100/sampled) > config_cycle_acceptable_stale);\n    }\n\n    elapsed = ustime()-start;\n    server.stat_expire_cycle_time_used += elapsed;\n    latencyAddSampleIfNeeded(\"expire-cycle\",elapsed/1000);\n\n    // 添加统计信息\n    double current_perc;\n    if (total_sampled) {\n        current_perc = (double)total_expired/total_sampled;\n    } else\n        current_perc = 0;\n    // 通过累加每次检查的过期概率影响，保存过期数据占数据比例。\n    server.stat_expired_stale_perc = (current_perc*0.05)+\n                                     (server.stat_expired_stale_perc*0.95);\n}\n```\n\n# AOF、RDB 和复制功能对过期键的处理\n\n## RDB\n\n**生成 RDB 文件**\n\n在执行 save 命令或 bgsave 命令创建一个新的 RDB文件时，程序会对数据库中的键进行检查，已过期的键就不会被保存到新创建的 RDB文件中\n\n**载入 RDB 文件**\n\n**主服务器**：载入 RDB 文件时，会对键进行检查，过期的键会被忽略\n\n**从服务器**：载入 RDB文件时，所有键都会载入。但是会在主从同步的时候，清空从服务器的数据库，所以过期的键载入也不会造成啥影响\n\n## AOF\n\n**AOF 文件写入**\n\n当过期键被惰性删除或定期删除后，程序会向 AOF 文件追加一条 del 命令，来显示的记录该键已经被删除\n\n**AOF 重写**\n\n重启过程会对键进行检查，如果过期就不会被保存到重写后的 AOF 文件中\n\n## 复制\n\n**从服务器的过期键删除动作由主服务器控制**\n\n主服务器在删除一个过期键后，会显示地向所有从服务器发送一个 del 命令，告知从服务器删除这个过期键\n\n从服务器收到在执行客户端发送的读命令时，即使碰到过期键也不会将其删除，只有在收到主服务器的 del 命令后，才会删除，这样就能保证主从服务器的数据一致性\n\n# 疑问点？\n\n1. 如果主从服务器链接断开怎么办？\n2. 如果发生网络抖动，主服务器发送的 del 命令没有传递到从服务器怎么办？\n\n其实上面两个问题 Redis 开发者已经考虑到了，只是主从复制涉及到的知识点还挺多，下面我就简单的说下解决的思路，后面会再分享一篇主从复制的文件\n\n## 如果主从服务器链接断开怎么办？\n\nRedis 采用 PSYNC 命令来执行复制时的同步操作，当从服务器在断开后重新连接主服务器时，主服务器会把从服务器断线期间执行的写命令发送给从服务器，然后从服务器接收并执行这些写命令，这样主从服务器就会达到一致性。\n\n那主服务器如何判断从服务器断开链接的过程需要哪些命令？\n\n主服务器会维护一个固定长度的先进先出的队列，即复制积压缓冲区，缓冲区中保存着主服务器的写命令和命令对应的偏移量，在主服务器给从服务器传播命令时，同时也会往复制积压缓冲区中写命令。\n\n从服务器在向主服务器发送 PSYNC 命令时，同时会带上它的最新写命令的偏移量，这样主服务器通过对比偏移量，就可以知道从服务器从哪里断开的了\n\n## 如果发生网络抖动，主服务器发送的 del 命令没有传递到从服务器怎么办？\n\n其实主从服务器之间会有心跳检测机制，主从服务器通过发送和接收 REPLCONF ACK 命令来检查两者之间的网络连接是否正常。\n\n当从服务器向主服务器发送 REPLCONF ACK 命令时，主服务器会对比自己的偏移量和从服务器发过来的偏移量。\n\n如果从服务器的偏移量小于自己的偏移量，主服务器会从复制积压缓冲区中找到从服务器缺少的数据，并将数据发送给从服务器，这样就达到了数据一致性\n","html":"<div data-node-id=\"20220428141727-pj65yay\" data-node-index=\"0\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">Redis可以对Key设置过期时间，如果Key到过期时间，Redis是如何删除的？</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-kmd7gpx\" data-node-index=\"1\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">Redis会将过期时间的键和过期时间存放到一个字典当中。当我们查询一个键时，redis首先检查是否在过期字典当中，如果存在，则获取其过期时间，然后将过期时间和当前时间进行对比，如果比当前时间大则认定过期，否则则认定没有过期。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-kv10ei7\" data-node-index=\"2\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">Redis采用惰性删除+定期删除</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-xfrcavp\" data-node-index=\"3\" data-type=\"NodeTable\" class=\"table\" updated=\"20220428141727\"><div contenteditable=\"false\"><table contenteditable=\"true\" spellcheck=\"false\"><colgroup><col /><col /><col /></colgroup><thead><tr><th align=\"center\" id=\"\">删除模式</th><th align=\"center\" id=\"\">优点</th><th align=\"center\" id=\"\">缺点</th></tr></thead><tbody><tr><td align=\"center\" id=\"\">惰性删除</td><td align=\"center\" id=\"\">对 CPU友好，<br />我们只会在使用该键时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。</td><td align=\"center\" id=\"\">如果一个键已经过期，但是一直没有使用，<br />该键就会一直存在内存中，内存永远不会释放。<br />如有较多这样的过期键，容易造成内存泄漏。</td></tr><tr><td align=\"center\" id=\"\">定期删除</td><td align=\"center\" id=\"\">可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。<br />另外定期删除，也能有效释放过期键占用的内存。</td><td align=\"center\" id=\"\">难以确定删除操作执行的时长和频率。<br />如果执行的太频繁对CPU不友好。<br />如果执行频率过低，那又和惰性删除一样了，<br />过期键占用的内存不会及时得到释放。<br />另外最重要的是，在获取某个键时，如果某个键的过期时间已经到了，但是还没执行定期删除，那么就会返回这个键的值，这是业务不能忍受的错误。</td></tr></tbody></table><div class=\"protyle-action__table\"><div class=\"table__resize\"></div><div class=\"table__select\"></div></div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h1\" data-node-id=\"20220428141727-o0rija8\" data-node-index=\"4\" data-type=\"NodeHeading\" class=\"h1\" updated=\"20220428144732\"><div contenteditable=\"true\" spellcheck=\"false\">惰性删除</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-jgmpnms\" data-node-index=\"5\" data-type=\"NodeCodeBlock\" class=\"render-node\" updated=\"20220428141727\" data-content=\"flowchart TD;\n\tA(所有读写数据库的命令) --&gt; B(调用expireIfNeeded方法)\n\tB--&gt;C{输入键已过期?}\n\tC--&gt;|是|D(删除键)\n\tC--&gt;|否|E(执行实际流程)\n\tD--&gt;E\" data-subtype=\"mermaid\"><div spin=\"1\"></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-q6uhlhn\" data-node-index=\"6\" data-type=\"NodeCodeBlock\" class=\"code-block\" updated=\"20220428141727\"><div class=\"protyle-action\"><span class=\"protyle-action--first protyle-action__language\" contenteditable=\"false\">c</span><span class=\"fn__flex-1\"></span><span class=\"protyle-icon protyle-icon--first protyle-action__copy\"><svg><use xlink:href=\"#iconCopy\"></use></svg></span><span class=\"protyle-icon protyle-icon--last protyle-action__menu\"><svg><use xlink:href=\"#iconMore\"></use></svg></span></div><div contenteditable=\"true\" spellcheck=\"false\">int expireIfNeeded(redisDb *db, robj *key) {\n    // 键未过期返回0\n    if (!keyIsExpired(db,key)) return 0;\n    // 如果运行在从节点上，直接返回1，因为从节点不执行删除操作\n    if (server.masterhost != NULL) return 1;\n    // 运行到这里，表示键带有过期时间且运行在主节点上\n    // 删除过期键个数\n    server.stat_expiredkeys++;\n    // 向从节点和AOF文件传播过期信息\n    propagateExpire(db,key,server.lazyfree_lazy_expire);\n    // 发送事件通知\n    notifyKeyspaceEvent(NOTIFY_EXPIRED,\n        &quot;expired&quot;,key,db-&gt;id);\n    // 根据配置（默认是同步删除）判断是否采用惰性删除（这里的惰性删除是指采用后台线程处理删除操做，这样会减少卡顿）\n    int retval = server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :\n                                               dbSyncDelete(db,key);\n    if (retval) signalModifiedKey(NULL,db,key);\n    return retval;\n}\n</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h1\" data-node-id=\"20220428141727-wq9axfb\" data-node-index=\"7\" data-type=\"NodeHeading\" class=\"h1\" updated=\"20220428144736\"><div contenteditable=\"true\" spellcheck=\"false\">定期删除</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-vle1qy9\" data-node-index=\"8\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">定期策略是每隔一段时间执行一次删除过期键的操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU 时间的影响，同时也减少了内存浪费</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-wuuz4i7\" data-node-index=\"9\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">Redis 默认会每秒进行 10 次（redis.conf 中通过 hz 配置）过期扫描，扫描并不是遍历过期字典中的所有键，而是采用了如下方法</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"o\" data-node-id=\"20220428141727-ast0dpn\" data-node-index=\"10\" data-type=\"NodeList\" class=\"list\" updated=\"20220428141727\"><div data-marker=\"1.\" data-subtype=\"o\" data-node-id=\"20220428141727-7mzqbia\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action protyle-action--order\" contenteditable=\"false\" draggable=\"true\">1.</div><div data-node-id=\"20220428141727-jm4zdhv\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">从过期字典中随机取出 20 个键(ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP)</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"2.\" data-subtype=\"o\" data-node-id=\"20220428141727-d1vpxzp\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action protyle-action--order\" contenteditable=\"false\" draggable=\"true\">2.</div><div data-node-id=\"20220428141727-w4eh0kb\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">删除这 20 个键中过期的键</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"3.\" data-subtype=\"o\" data-node-id=\"20220428141727-95dt0hf\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action protyle-action--order\" contenteditable=\"false\" draggable=\"true\">3.</div><div data-node-id=\"20220428141727-on9jild\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">如果过期键的比例超过 25% ，重复步骤 1 和 2</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-es3hyji\" data-node-index=\"11\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">为了保证扫描不会出现循环过度，导致线程卡死现象，还增加了扫描时间的上限，默认是 25 毫秒(ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC)（即默认在慢模式下，如果是快模式，扫描上限是 1 毫秒）</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-zw8dhdh\" data-node-index=\"12\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">从定期回收策略的慢速检查中，我们可以看到，redis 处理到期数据，通过采样，判断到期数据的密集度。到期数据越密集，处理时间越多。我们使用中，不应该把大量数据设置在同一个时间段到期。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-33zv14s\" data-node-index=\"13\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">底层源码实现:</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-gamicxk\" data-node-index=\"14\" data-type=\"NodeCodeBlock\" class=\"code-block\" updated=\"20220428141727\"><div class=\"protyle-action\"><span class=\"protyle-action--first protyle-action__language\" contenteditable=\"false\">c</span><span class=\"fn__flex-1\"></span><span class=\"protyle-icon protyle-icon--first protyle-action__copy\"><svg><use xlink:href=\"#iconCopy\"></use></svg></span><span class=\"protyle-icon protyle-icon--last protyle-action__menu\"><svg><use xlink:href=\"#iconMore\"></use></svg></span></div><div contenteditable=\"true\" spellcheck=\"false\">void activeExpireCycle(int type) {\n    /* Adjust the running parameters according to the configured expire\n     * effort. The default effort is 1, and the maximum configurable effort\n     * is 10. */\n    unsigned long\n    // 努力力度，默认 1，也就是遍历过期字典的力度，力度越大，遍历数量越多，但是性能损耗更多。\n    effort = server.active_expire_effort-1, /* Rescale from 0 to 9. */\n    // 每次循环遍历键值个数。力度越大，遍历个数越多。\n    config_keys_per_loop = ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP +\n                           ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP/4*effort,\n    // 快速遍历时间范围，力度越大，给予遍历时间越多。\n    config_cycle_fast_duration = ACTIVE_EXPIRE_CYCLE_FAST_DURATION +\n                                 ACTIVE_EXPIRE_CYCLE_FAST_DURATION/4*effort,\n    // 慢速遍历检查时间片\n    config_cycle_slow_time_perc = ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC +\n                                  2*effort,\n    // 已经到期数据 / 检查数据 比例。达到可以接受的比例。\n    config_cycle_acceptable_stale = ACTIVE_EXPIRE_CYCLE_ACCEPTABLE_STALE-\n                                    effort;\n\n    /* This function has some global state in order to continue the work\n     * incrementally across calls. */\n    static unsigned int current_db = 0; /* Last DB tested. */\n    // 检查是否已经超时。\n    static int timelimit_exit = 0;      /* Time limit hit in previous call? */\n    // 上一次快速检查数据起始时间。\n    static long long last_fast_cycle = 0; /* When last fast cycle ran. */\n\n    // iteration 迭代检查个数，每 16 次循环遍历，确认一下是否检查超时。\n    int j, iteration = 0;\n    // 每次周期检查的数据库个数。redis 默认有 16 个库。\n    int dbs_per_call = CRON_DBS_PER_CALL;\n    long long start = ustime(), timelimit, elapsed;\n\n    /* When clients are paused the dataset should be static not just from the\n     * POV of clients not being able to write, but also from the POV of\n     * expires and evictions of keys not being performed. */\n    /* 如果链接已经停止了，那么要保留现场，不允许修改数据，也不允许到期淘汰数据。\n     * 使用命令 ‘pause’ 暂停 redis 工作或者主服务正在进行从服务的故障转移。*/\n    if (clientsArePaused()) return;\n\n    if (type == ACTIVE_EXPIRE_CYCLE_FAST) {\n        /* 检查还没超时，但是到期数据密集度已经达到了可以接受的范围，不要快速检查了，\n           毕竟它是快速的，留给其它方式的检查。*/\n        if (!timelimit_exit &amp;&amp;\n            server.stat_expired_stale_perc &lt; config_cycle_acceptable_stale)\n            return;\n        /* 限制快速检查频次，在两个 config_cycle_fast_duration 内，只能执行一次快速检查。 */\n        if (start &lt; last_fast_cycle + (long long)config_cycle_fast_duration*2)\n            return;\n\n        last_fast_cycle = start;\n    }\n\n    /* We usually should test CRON_DBS_PER_CALL per iteration, with\n     * two exceptions:\n     *\n     * 1) Don't test more DBs than we have.\n     * 2) If last time we hit the time limit, we want to scan all DBs\n     * in this iteration, as there is work to do in some DB and we don't want\n     * expired keys to use memory for too much time. */\n    if (dbs_per_call &gt; server.dbnum || timelimit_exit)\n        dbs_per_call = server.dbnum;\n\n    /* 检查过期数据，但是不能太损耗资源，得有个限制。server.hz 默认为 10\n      hz 是执行后台任务的频率，越大表明执行的次数越频繁，一般用默认值 10 */\n    timelimit = config_cycle_slow_time_perc*1000000/server.hz/100;\n    timelimit_exit = 0;\n    if (timelimit &lt;= 0) timelimit = 1;\n    // 如果是快速模式，更改检查周期时间。\n    if (type == ACTIVE_EXPIRE_CYCLE_FAST)\n        timelimit = config_cycle_fast_duration; /* in microseconds. */\n\n\n    /* 过期数据一般是异步方式，检查到过期数据，都是从字典中移除键值信息，\n     * 避免再次使用，但是数据回收放在后台回收，不是实时的，有数据有可能还存在数据库里。*/\n    // 检查数据个数。\n    long total_sampled = 0;\n    // 检查数据，数据已经过期的个数。\n    long total_expired = 0;\n\n    for (j = 0; j &lt; dbs_per_call &amp;&amp; timelimit_exit == 0; j++) {\n        /* Expired and checked in a single loop. */\n        unsigned long expired, sampled;\n\n        redisDb *db = server.db+(current_db % server.dbnum);\n\n        /* Increment the DB now so we are sure if we run out of time\n         * in the current DB we'll restart from the next. This allows to\n         * distribute the time evenly across DBs. */\n        current_db++;\n\n        /* Continue to expire if at the end of the cycle there are still\n         * a big percentage of keys to expire, compared to the number of keys\n         * we scanned. The percentage, stored in config_cycle_acceptable_stale\n         * is not fixed, but depends on the Redis configured &quot;expire effort&quot;. */\n        // 遍历数据库检查过期数据，直到超出检查周期时间，或者过期数据比例已经很少了。\n        do {\n            // num 数据量，slots 哈希表大小（字典数据如果正在迁移，双表大小）\n            unsigned long num, slots;\n            long long now, ttl_sum;\n            int ttl_samples;\n            iteration++;\n\n            /* If there is nothing to expire try next DB ASAP. */\n            if ((num = dictSize(db-&gt;expires)) == 0) {\n                db-&gt;avg_ttl = 0;\n                break;\n            }\n            slots = dictSlots(db-&gt;expires);\n            now = mstime();\n\n            /* 过期存储数据结构是字典，数据经过处理后，字典存储的数据可能已经很少，\n            * 但是字典还是大字典，这样遍历数据有效命中率会很低，处理起来会浪费资源，\n            * 后面的访问会很快触发字典的缩容，缩容后再进行处理效率更高。*/\n            if (num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE &amp;&amp;\n                (num*100/slots &lt; 1)) break;\n\n            // 过期的数据个数。\n            expired = 0;\n            // 检查的数据个数。\n            sampled = 0;\n            // 没有过期的数据时间差之和。\n            ttl_sum = 0;\n            // 没有过期的数据个数。\n            ttl_samples = 0;\n\n            // 每次检查的数据限制。\n            if (num &gt; config_keys_per_loop)\n                num = config_keys_per_loop;\n\n            /* 哈希表本质上是一个数组，可能有键值碰撞的数据，用链表将碰撞数据串联起来，\n            * 放在一个数组下标下，也就是放在哈希表的一个桶里。max_buckets 是最大能检查的桶个数。\n            * 跳过空桶，不处理。*/\n            long max_buckets = num*20;\n            // 当前已经检查哈希表桶的个数。\n            long checked_buckets = 0;\n            // 一个桶上有可能有多个数据。所以检查从两方面限制：一个是数据量，一个是桶的数量。\n            while (sampled &lt; num &amp;&amp; checked_buckets &lt; max_buckets) {\n                for (int table = 0; table &lt; 2; table++) {\n                    // 如果 dict 没有正在进行扩容，不需要检查它的第二张表了。\n                    if (table == 1 &amp;&amp; !dictIsRehashing(db-&gt;expires)) break;\n\n                    unsigned long idx = db-&gt;expires_cursor;\n                    idx &amp;= db-&gt;expires-&gt;ht[table].sizemask;\n                    dictEntry *de = db-&gt;expires-&gt;ht[table].table[idx];\n                    long long ttl;\n\n                    // 检查数据是否已经超时。\n                    checked_buckets++;\n                    while(de) {\n                        /* Get the next entry now since this entry may get\n                         * deleted. */\n                        dictEntry *e = de;\n                        de = de-&gt;next;\n\n                        ttl = dictGetSignedIntegerVal(e)-now;\n                        // 如果数据过期了，进行回收处理。\n                        if (activeExpireCycleTryExpire(db,e,now)) expired++;\n                        if (ttl &gt; 0) {\n                            /* We want the average TTL of keys yet\n                             * not expired. */\n                            ttl_sum += ttl;\n                            ttl_samples++;\n                        }\n                        sampled++;\n                    }\n                }\n                db-&gt;expires_cursor++;\n            }\n            total_expired += expired;\n            total_sampled += sampled;\n\n            /* Update the average TTL stats for this database. */\n            if (ttl_samples) {\n                long long avg_ttl = ttl_sum/ttl_samples;\n\n                /* Do a simple running average with a few samples.\n                 * We just use the current estimate with a weight of 2%\n                 * and the previous estimate with a weight of 98%. */\n                if (db-&gt;avg_ttl == 0) db-&gt;avg_ttl = avg_ttl;\n                // 对没过期的数据，平均过期时间进行采样，上一次统计的平均时间占 98 %，本次占 2%。\n                db-&gt;avg_ttl = (db-&gt;avg_ttl/50)*49 + (avg_ttl/50);\n            }\n\n            /* We can't block forever here even if there are many keys to\n             * expire. So after a given amount of milliseconds return to the\n             * caller waiting for the other active expire cycle. */\n            /* 避免检查周期太长，当前数据库每 16 次循环迭代检查，检查是否超时，超时退出。*/\n            if ((iteration &amp; 0xf) == 0) { /* check once every 16 iterations. */\n                elapsed = ustime()-start;\n                if (elapsed &gt; timelimit) {\n                    timelimit_exit = 1;\n                    server.stat_expired_time_cap_reached_count++;\n                    break;\n                }\n            }\n            /* 当前数据库，如果没有检查到数据，或者过期数据已经达到可接受比例\n             * 就退出该数据库检查，进入到下一个数据库检查。*/\n        } while (sampled == 0 ||\n                 (expired*100/sampled) &gt; config_cycle_acceptable_stale);\n    }\n\n    elapsed = ustime()-start;\n    server.stat_expire_cycle_time_used += elapsed;\n    latencyAddSampleIfNeeded(&quot;expire-cycle&quot;,elapsed/1000);\n\n    // 添加统计信息\n    double current_perc;\n    if (total_sampled) {\n        current_perc = (double)total_expired/total_sampled;\n    } else\n        current_perc = 0;\n    // 通过累加每次检查的过期概率影响，保存过期数据占数据比例。\n    server.stat_expired_stale_perc = (current_perc*0.05)+\n                                     (server.stat_expired_stale_perc*0.95);\n}\n</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h1\" data-node-id=\"20220428141727-gr8a4lk\" data-node-index=\"15\" data-type=\"NodeHeading\" class=\"h1\" updated=\"20220428144742\"><div contenteditable=\"true\" spellcheck=\"false\">AOF、RDB 和复制功能对过期键的处理</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h2\" data-node-id=\"20220428141727-xhxrdyf\" data-node-index=\"16\" data-type=\"NodeHeading\" class=\"h2\" updated=\"20220428144748\"><div contenteditable=\"true\" spellcheck=\"false\">RDB</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-kci1epf\" data-node-index=\"17\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><strong id=\"\">生成 RDB 文件</strong></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-eb1x8yn\" data-node-index=\"18\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">在执行 save 命令或 bgsave 命令创建一个新的 RDB文件时，程序会对数据库中的键进行检查，已过期的键就不会被保存到新创建的 RDB文件中</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-ly74ruy\" data-node-index=\"19\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><strong id=\"\">载入 RDB 文件</strong></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-vuzsu9k\" data-node-index=\"20\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><strong id=\"\">主服务器</strong>：载入 RDB 文件时，会对键进行检查，过期的键会被忽略</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-z18oy4j\" data-node-index=\"21\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><strong id=\"\">从服务器</strong>：载入 RDB文件时，所有键都会载入。但是会在主从同步的时候，清空从服务器的数据库，所以过期的键载入也不会造成啥影响</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h2\" data-node-id=\"20220428141727-z7l5azb\" data-node-index=\"22\" data-type=\"NodeHeading\" class=\"h2\" updated=\"20220428144753\"><div contenteditable=\"true\" spellcheck=\"false\">AOF</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-ogbzpo0\" data-node-index=\"23\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><strong id=\"\">AOF 文件写入</strong></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-3hqs7n8\" data-node-index=\"24\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">当过期键被惰性删除或定期删除后，程序会向 AOF 文件追加一条 del 命令，来显示的记录该键已经被删除</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-n3unc1b\" data-node-index=\"25\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><strong id=\"\">AOF 重写</strong></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-gert9kp\" data-node-index=\"26\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">重启过程会对键进行检查，如果过期就不会被保存到重写后的 AOF 文件中</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h2\" data-node-id=\"20220428141727-vdap5h4\" data-node-index=\"27\" data-type=\"NodeHeading\" class=\"h2\" updated=\"20220428144757\"><div contenteditable=\"true\" spellcheck=\"false\">复制</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-omwqpgy\" data-node-index=\"28\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><strong id=\"\">从服务器的过期键删除动作由主服务器控制</strong></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-fosrmdc\" data-node-index=\"29\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">主服务器在删除一个过期键后，会显示地向所有从服务器发送一个 del 命令，告知从服务器删除这个过期键</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-kly1a30\" data-node-index=\"30\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">从服务器收到在执行客户端发送的读命令时，即使碰到过期键也不会将其删除，只有在收到主服务器的 del 命令后，才会删除，这样就能保证主从服务器的数据一致性</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h1\" data-node-id=\"20220428141727-5x39avu\" data-node-index=\"31\" data-type=\"NodeHeading\" class=\"h1\" updated=\"20220428144801\"><div contenteditable=\"true\" spellcheck=\"false\">疑问点？</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"o\" data-node-id=\"20220428141727-gm1iwtz\" data-node-index=\"32\" data-type=\"NodeList\" class=\"list\" updated=\"20220428141727\"><div data-marker=\"1.\" data-subtype=\"o\" data-node-id=\"20220428141727-a852lqb\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action protyle-action--order\" contenteditable=\"false\" draggable=\"true\">1.</div><div data-node-id=\"20220428141727-3vvilf4\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">如果主从服务器链接断开怎么办？</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"2.\" data-subtype=\"o\" data-node-id=\"20220428141727-8h6vw71\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action protyle-action--order\" contenteditable=\"false\" draggable=\"true\">2.</div><div data-node-id=\"20220428141727-jej7qhb\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">如果发生网络抖动，主服务器发送的 del 命令没有传递到从服务器怎么办？</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-dn59g93\" data-node-index=\"33\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">其实上面两个问题 Redis 开发者已经考虑到了，只是主从复制涉及到的知识点还挺多，下面我就简单的说下解决的思路，后面会再分享一篇主从复制的文件</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h2\" data-node-id=\"20220428141727-4505lb0\" data-node-index=\"34\" data-type=\"NodeHeading\" class=\"h2\" updated=\"20220428144806\"><div contenteditable=\"true\" spellcheck=\"false\">如果主从服务器链接断开怎么办？</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-4syqoyp\" data-node-index=\"35\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">Redis 采用 PSYNC 命令来执行复制时的同步操作，当从服务器在断开后重新连接主服务器时，主服务器会把从服务器断线期间执行的写命令发送给从服务器，然后从服务器接收并执行这些写命令，这样主从服务器就会达到一致性。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-nmvv53y\" data-node-index=\"36\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">那主服务器如何判断从服务器断开链接的过程需要哪些命令？</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-2hf7lve\" data-node-index=\"37\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">主服务器会维护一个固定长度的先进先出的队列，即复制积压缓冲区，缓冲区中保存着主服务器的写命令和命令对应的偏移量，在主服务器给从服务器传播命令时，同时也会往复制积压缓冲区中写命令。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-ocevspo\" data-node-index=\"38\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">从服务器在向主服务器发送 PSYNC 命令时，同时会带上它的最新写命令的偏移量，这样主服务器通过对比偏移量，就可以知道从服务器从哪里断开的了</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h2\" data-node-id=\"20220428141727-4x9rpfk\" data-node-index=\"39\" data-type=\"NodeHeading\" class=\"h2\" updated=\"20220428144808\"><div contenteditable=\"true\" spellcheck=\"false\">如果发生网络抖动，主服务器发送的 del 命令没有传递到从服务器怎么办？</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-swz21mi\" data-node-index=\"40\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">其实主从服务器之间会有心跳检测机制，主从服务器通过发送和接收 REPLCONF ACK 命令来检查两者之间的网络连接是否正常。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-9hue7e3\" data-node-index=\"41\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">当从服务器向主服务器发送 REPLCONF ACK 命令时，主服务器会对比自己的偏移量和从服务器发过来的偏移量。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-89fas5r\" data-node-index=\"42\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">如果从服务器的偏移量小于自己的偏移量，主服务器会从复制积压缓冲区中找到从服务器缺少的数据，并将数据发送给从服务器，这样就达到了数据一致性</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div>","field":{"slug":"/topic/redis/Redis集群/Redis数据删除策略","topic":"redis"},"frontmatter":{"title":"Redis数据删除策略","tags":["redis","Redis集群"],"date":"2022-04-28","description":"Redis数据删除策略 Redis可以对Key设置过期时间，如果Key到过期时间，Redis是如何删除的？ Redis会将过期时间的键和过期时间存放到一个字典当中。当我们查询一个键时，redis首先检查是否在过期字典当中，如果存在，则获取其..."}},"topic":{"title":"redis","tree":"{\"title\":\"redis\",\"id\":\"20220428141727-a3p03i0\",\"parentId\":\"\",\"href\":\"/topic/redis\",\"path\":\"/topic/redis\",\"children\":[{\"title\":\"Redis为什么这么快\",\"id\":\"20220428141727-jbyo2wp\",\"type\":\"d\",\"href\":\"/topic/redis/Redis为什么这么快\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis为什么这么快\",\"parentPath\":\"/topic/redis\",\"sort\":1,\"children\":[{\"title\":\"完全基于内存\",\"id\":\"20220428141727-m8thckv\",\"type\":\"h\",\"href\":\"/topic/redis/Redis为什么这么快#完全基于内存\",\"parentId\":\"20220428141727-jbyo2wp\",\"path\":\"/topic/redis/Redis为什么这么快\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":2},{\"title\":\"数据结构简单\",\"id\":\"20220428141727-0532nq9\",\"type\":\"h\",\"href\":\"/topic/redis/Redis为什么这么快#数据结构简单\",\"parentId\":\"20220428141727-jbyo2wp\",\"path\":\"/topic/redis/Redis为什么这么快\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":2},{\"title\":\"工作线程采用单线程，避免了线程上下文切换所带来的损耗\",\"id\":\"20220428141727-kw7bg9v\",\"type\":\"h\",\"href\":\"/topic/redis/Redis为什么这么快#工作线程采用单线程，避免了线程上下文切换所带来的损耗\",\"parentId\":\"20220428141727-jbyo2wp\",\"path\":\"/topic/redis/Redis为什么这么快\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":2},{\"title\":\"对于客户端的连接采用多路复用和非阻塞I/O\",\"id\":\"20220428141727-m7ruuk1\",\"type\":\"h\",\"href\":\"/topic/redis/Redis为什么这么快#对于客户端的连接采用多路复用和非阻塞I/O\",\"parentId\":\"20220428141727-jbyo2wp\",\"path\":\"/topic/redis/Redis为什么这么快\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":2},{\"title\":\"redis单线程的问题\",\"id\":\"20220428141728-w6wf4kq\",\"type\":\"d\",\"href\":\"/topic/redis/Redis为什么这么快/redis单线程的问题\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis为什么这么快/redis单线程的问题\",\"parentPath\":\"/topic/redis/Redis为什么这么快\",\"sort\":11,\"children\":[],\"level\":2}],\"level\":1},{\"title\":\"Redis基本数据结构\",\"id\":\"20220428141727-imsmasu\",\"type\":\"d\",\"href\":\"/topic/redis/Redis基本数据结构\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"sort\":2,\"children\":[{\"title\":\"常用的\",\"id\":\"20220428141727-1gclyg6\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#常用的\",\"parentId\":\"20220428141727-imsmasu\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"string\",\"id\":\"20220428141727-u2m7nzt\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#string\",\"parentId\":\"20220428141727-1gclyg6\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"hash\",\"id\":\"20220428141727-po0l8p4\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#hash\",\"parentId\":\"20220428141727-1gclyg6\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"list\",\"id\":\"20220428141727-nyjx5v1\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#list\",\"parentId\":\"20220428141727-1gclyg6\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"set\",\"id\":\"20220428141727-ujl3jkq\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#set\",\"parentId\":\"20220428141727-1gclyg6\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"zset\",\"id\":\"20220428141727-8lh8dqt\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#zset\",\"parentId\":\"20220428141727-1gclyg6\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"扩展结构\",\"id\":\"20220428141727-9xu8ei1\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#扩展结构\",\"parentId\":\"20220428141727-imsmasu\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"bitmap\",\"id\":\"20220428141727-89gt7iy\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#bitmap\",\"parentId\":\"20220428141727-9xu8ei1\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"hyperloglog\",\"id\":\"20220428141727-08upaib\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#hyperloglog\",\"parentId\":\"20220428141727-9xu8ei1\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"GEO\",\"id\":\"20220428141727-6z03dvm\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#GEO\",\"parentId\":\"20220428141727-9xu8ei1\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"扩展功能\",\"id\":\"20220428141727-x5n4s7y\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#扩展功能\",\"parentId\":\"20220428141727-imsmasu\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"pub/sub\",\"id\":\"20220428141727-zay76x9\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#pub/sub\",\"parentId\":\"20220428141727-x5n4s7y\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"pipeline\",\"id\":\"20220428141727-m3750uw\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#pipeline\",\"parentId\":\"20220428141727-x5n4s7y\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"Lua 脚本\",\"id\":\"20220428141727-6rc0qt7\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#Lua 脚本\",\"parentId\":\"20220428141727-x5n4s7y\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"事务\",\"id\":\"20220428141727-8i9gpxn\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#事务\",\"parentId\":\"20220428141727-x5n4s7y\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"String的底层实现\",\"id\":\"20220428141728-d2hmuxd\",\"type\":\"d\",\"href\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"sort\":1,\"children\":[{\"title\":\"SDS 结构\",\"id\":\"20220428141728-y2039os\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/String的底层实现#SDS 结构\",\"parentId\":\"20220428141728-d2hmuxd\",\"path\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":3},{\"title\":\"相对于C语言的优势\",\"id\":\"20220428141728-8t63ohh\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/String的底层实现#相对于C语言的优势\",\"parentId\":\"20220428141728-d2hmuxd\",\"path\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[{\"title\":\"统计长度时间复杂度 O(1)\",\"id\":\"20220428141728-xeqpgol\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/String的底层实现#统计长度时间复杂度 O(1)\",\"parentId\":\"20220428141728-8t63ohh\",\"path\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":4},{\"title\":\"数据溢出\",\"id\":\"20220428141728-coew455\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/String的底层实现#数据溢出\",\"parentId\":\"20220428141728-8t63ohh\",\"path\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":4},{\"title\":\"内存重分配策略\",\"id\":\"20220428141728-mbwnou1\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/String的底层实现#内存重分配策略\",\"parentId\":\"20220428141728-8t63ohh\",\"path\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":4},{\"title\":\"数据格式多样性\",\"id\":\"20220428141728-5h2se0u\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/String的底层实现#数据格式多样性\",\"parentId\":\"20220428141728-8t63ohh\",\"path\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"三大编码\",\"id\":\"20220428141728-t4votze\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/String的底层实现#三大编码\",\"parentId\":\"20220428141728-d2hmuxd\",\"path\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"List的底层实现\",\"id\":\"20220428141727-skh553t\",\"type\":\"d\",\"href\":\"/topic/redis/Redis基本数据结构/List的底层实现\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis基本数据结构/List的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"sort\":2,\"children\":[],\"level\":2},{\"title\":\"Hash的底层实现\",\"id\":\"20220428141727-g51ewzt\",\"type\":\"d\",\"href\":\"/topic/redis/Redis基本数据结构/Hash的底层实现\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis基本数据结构/Hash的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"sort\":3,\"children\":[{\"title\":\"ZipList编码的哈希对象\",\"id\":\"20220428141727-fo8pixs\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/Hash的底层实现#ZipList编码的哈希对象\",\"parentId\":\"20220428141727-g51ewzt\",\"path\":\"/topic/redis/Redis基本数据结构/Hash的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":3},{\"title\":\"hashtable对象\",\"id\":\"20220428141727-f7zok8f\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/Hash的底层实现#hashtable对象\",\"parentId\":\"20220428141727-g51ewzt\",\"path\":\"/topic/redis/Redis基本数据结构/Hash的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"Set的底层实现\",\"id\":\"20220428141728-5c6e914\",\"type\":\"d\",\"href\":\"/topic/redis/Redis基本数据结构/Set的底层实现\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis基本数据结构/Set的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"sort\":4,\"children\":[],\"level\":2},{\"title\":\"ZSet的底层实现\",\"id\":\"20220428141728-58eined\",\"type\":\"d\",\"href\":\"/topic/redis/Redis基本数据结构/ZSet的底层实现\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis基本数据结构/ZSet的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"sort\":5,\"children\":[{\"title\":\"跳表是什么?\",\"id\":\"20220428141728-9by553n\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/ZSet的底层实现#跳表是什么?\",\"parentId\":\"20220428141728-58eined\",\"path\":\"/topic/redis/Redis基本数据结构/ZSet的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[{\"title\":\"优缺点\",\"id\":\"20220428141728-rvbr2il\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/ZSet的底层实现#优缺点\",\"parentId\":\"20220428141728-9by553n\",\"path\":\"/topic/redis/Redis基本数据结构/ZSet的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2}],\"level\":1},{\"title\":\"Redis分布式缓存\",\"id\":\"20220428141727-3x1i5zp\",\"type\":\"d\",\"href\":\"/topic/redis/Redis分布式缓存\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"sort\":3,\"children\":[{\"title\":\"双写一致性\",\"id\":\"20220428141727-zahxna7\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#双写一致性\",\"parentId\":\"20220428141727-3x1i5zp\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":2},{\"title\":\"缓存更新策略\",\"id\":\"20220428141727-iqgn80l\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#缓存更新策略\",\"parentId\":\"20220428141727-3x1i5zp\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"最常见的策略\",\"id\":\"20220428141727-45wxv7a\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#最常见的策略\",\"parentId\":\"20220428141727-iqgn80l\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"优点剖析\",\"id\":\"20220428141727-tfanvhu\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#优点剖析\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"1. “先淘汰缓存，再写数据库” 合理\",\"id\":\"20220428141727-vzyp7bi\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#1. “先淘汰缓存，再写数据库” 合理\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"2. 异步刷新，补缺补漏\",\"id\":\"20220428141727-kbueoxr\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#2. 异步刷新，补缺补漏\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"缺点剖析\",\"id\":\"20220428141727-sd1lbh3\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#缺点剖析\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"1. 容灾不足\",\"id\":\"20220428141727-aff14q4\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#1. 容灾不足\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"2. 并发问题\",\"id\":\"20220428141727-7kjhtfn\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#2. 并发问题\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"方案总结\",\"id\":\"20220428141727-5w2loli\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#方案总结\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"写流程：\",\"id\":\"20220428141727-s959uv0\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#写流程：\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"读流程：\",\"id\":\"20220428141727-sceljri\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#读流程：\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"方案分析\",\"id\":\"20220428141727-7flpl0m\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#方案分析\",\"parentId\":\"20220428141727-iqgn80l\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"优点剖析\",\"id\":\"20220428141727-1cqjx66\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#优点剖析\",\"parentId\":\"20220428141727-7flpl0m\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"1. 容灾\",\"id\":\"20220428141727-w9bvsqf\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#1. 容灾\",\"parentId\":\"20220428141727-1cqjx66\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"缺点剖析\",\"id\":\"20220428141727-n1twxfd\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#缺点剖析\",\"parentId\":\"20220428141727-7flpl0m\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"1. 只适合简单业务，复杂业务容易发生并发问题\",\"id\":\"20220428141727-t5kobxh\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#1. 只适合简单业务，复杂业务容易发生并发问题\",\"parentId\":\"20220428141727-n1twxfd\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"缺点1的改进\",\"id\":\"20220428141727-bz5ta88\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#缺点1的改进\",\"parentId\":\"20220428141727-t5kobxh\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":6}],\"level\":5},{\"title\":\"2. 依然是并发问题\",\"id\":\"20220428141727-gysgmg1\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#2. 依然是并发问题\",\"parentId\":\"20220428141727-n1twxfd\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"方案总结\",\"id\":\"20220428141727-01sdgjy\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#方案总结\",\"parentId\":\"20220428141727-iqgn80l\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"写流程：\",\"id\":\"20220428141727-eglmgkf\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#写流程：\",\"parentId\":\"20220428141727-01sdgjy\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"读流程：\",\"id\":\"20220428141727-1vywbk4\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#读流程：\",\"parentId\":\"20220428141727-01sdgjy\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"方案分析\",\"id\":\"20220428141727-137lw2k\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#方案分析\",\"parentId\":\"20220428141727-iqgn80l\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"优点剖析\",\"id\":\"20220428141727-p0zad1o\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#优点剖析\",\"parentId\":\"20220428141727-137lw2k\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"1. 容灾完善\",\"id\":\"20220428141727-cawius6\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#1. 容灾完善\",\"parentId\":\"20220428141727-p0zad1o\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"写流程容灾分析\",\"id\":\"20220428141727-2d2z7fz\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#写流程容灾分析\",\"parentId\":\"20220428141727-cawius6\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":6},{\"title\":\"读流程容灾分析\",\"id\":\"20220428141727-4hr5okn\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#读流程容灾分析\",\"parentId\":\"20220428141727-cawius6\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":6}],\"level\":5},{\"title\":\"2. 无并发问题\",\"id\":\"20220428141727-uvwj2ga\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#2. 无并发问题\",\"parentId\":\"20220428141727-p0zad1o\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"缺点剖析\",\"id\":\"20220428141727-fmiz5zl\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#缺点剖析\",\"parentId\":\"20220428141727-137lw2k\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"1. 增加Cache_0强依赖\",\"id\":\"20220428141727-hr6lxu9\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#1. 增加Cache_0强依赖\",\"parentId\":\"20220428141727-fmiz5zl\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":5},{\"title\":\"2. 复杂度是比较高的\",\"id\":\"20220428141727-vbiftey\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#2. 复杂度是比较高的\",\"parentId\":\"20220428141727-fmiz5zl\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"方案总结\",\"id\":\"20220428141727-0an20z6\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#方案总结\",\"parentId\":\"20220428141727-iqgn80l\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"缓存击穿\",\"id\":\"20220428141728-p93afgy\",\"type\":\"d\",\"href\":\"/topic/redis/Redis分布式缓存/缓存击穿\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis分布式缓存/缓存击穿\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"sort\":1,\"children\":[{\"title\":\"解决方案\",\"id\":\"20220428141728-27esyuz\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存/缓存击穿#解决方案\",\"parentId\":\"20220428141728-p93afgy\",\"path\":\"/topic/redis/Redis分布式缓存/缓存击穿\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"children\":[{\"title\":\"不过期\",\"id\":\"20220428141728-foxjedm\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存/缓存击穿#不过期\",\"parentId\":\"20220428141728-27esyuz\",\"path\":\"/topic/redis/Redis分布式缓存/缓存击穿\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"children\":[],\"level\":4},{\"title\":\"互斥锁\",\"id\":\"20220428141728-68zg08m\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存/缓存击穿#互斥锁\",\"parentId\":\"20220428141728-27esyuz\",\"path\":\"/topic/redis/Redis分布式缓存/缓存击穿\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"缓存穿透\",\"id\":\"20220428141728-64iljj5\",\"type\":\"d\",\"href\":\"/topic/redis/Redis分布式缓存/缓存穿透\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis分布式缓存/缓存穿透\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"sort\":3,\"children\":[{\"title\":\"接口校验\",\"id\":\"20220428141728-wny00tb\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存/缓存穿透#接口校验\",\"parentId\":\"20220428141728-64iljj5\",\"path\":\"/topic/redis/Redis分布式缓存/缓存穿透\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"children\":[],\"level\":3},{\"title\":\"空对象缓存或者缺省值\",\"id\":\"20220428141728-6wjc642\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存/缓存穿透#空对象缓存或者缺省值\",\"parentId\":\"20220428141728-64iljj5\",\"path\":\"/topic/redis/Redis分布式缓存/缓存穿透\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"children\":[],\"level\":3},{\"title\":\"布隆过滤器\",\"id\":\"20220428141728-r9yad28\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存/缓存穿透#布隆过滤器\",\"parentId\":\"20220428141728-64iljj5\",\"path\":\"/topic/redis/Redis分布式缓存/缓存穿透\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"缓存雪崩\",\"id\":\"20220428141728-9ti4duq\",\"type\":\"d\",\"href\":\"/topic/redis/Redis分布式缓存/缓存雪崩\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis分布式缓存/缓存雪崩\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"sort\":4,\"children\":[{\"title\":\"解决方案\",\"id\":\"20220428141728-zu9jxq3\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存/缓存雪崩#解决方案\",\"parentId\":\"20220428141728-9ti4duq\",\"path\":\"/topic/redis/Redis分布式缓存/缓存雪崩\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"children\":[{\"title\":\"三步骤\",\"id\":\"20220428141728-0vnf8gp\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存/缓存雪崩#三步骤\",\"parentId\":\"20220428141728-zu9jxq3\",\"path\":\"/topic/redis/Redis分布式缓存/缓存雪崩\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"缓存预热\",\"id\":\"20220428141728-fz10tn2\",\"type\":\"d\",\"href\":\"/topic/redis/Redis分布式缓存/缓存预热\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis分布式缓存/缓存预热\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"sort\":7,\"children\":[],\"level\":2}],\"level\":1},{\"title\":\"Redis的分布式锁\",\"id\":\"20220428141727-sgydg0x\",\"type\":\"d\",\"href\":\"/topic/redis/Redis的分布式锁\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis的分布式锁\",\"parentPath\":\"/topic/redis\",\"sort\":4,\"children\":[{\"title\":\"利用redis实现分布式锁\",\"id\":\"20220428141727-e4nwnv1\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁#利用redis实现分布式锁\",\"parentId\":\"20220428141727-sgydg0x\",\"path\":\"/topic/redis/Redis的分布式锁\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"三个重要因素\",\"id\":\"20220428141727-zthzzjq\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁#三个重要因素\",\"parentId\":\"20220428141727-e4nwnv1\",\"path\":\"/topic/redis/Redis的分布式锁\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"涉及命令\",\"id\":\"20220428141727-hs1yg88\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁#涉及命令\",\"parentId\":\"20220428141727-e4nwnv1\",\"path\":\"/topic/redis/Redis的分布式锁\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"实现思想\",\"id\":\"20220428141727-5jo3h6s\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁#实现思想\",\"parentId\":\"20220428141727-sgydg0x\",\"path\":\"/topic/redis/Redis的分布式锁\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"业务执行的时间大于redis锁过期的时间\",\"id\":\"20220428141727-q83o36l\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁#业务执行的时间大于redis锁过期的时间\",\"parentId\":\"20220428141727-5jo3h6s\",\"path\":\"/topic/redis/Redis的分布式锁\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"redis部署模式的影响\",\"id\":\"20220428141727-9xczwbf\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁#redis部署模式的影响\",\"parentId\":\"20220428141727-5jo3h6s\",\"path\":\"/topic/redis/Redis的分布式锁\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"原子性问题\",\"id\":\"20220428141727-u4jomll\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁#原子性问题\",\"parentId\":\"20220428141727-5jo3h6s\",\"path\":\"/topic/redis/Redis的分布式锁\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"看门狗模式\",\"id\":\"20220428141728-gdeeql2\",\"type\":\"d\",\"href\":\"/topic/redis/Redis的分布式锁/看门狗模式\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis的分布式锁/看门狗模式\",\"parentPath\":\"/topic/redis/Redis的分布式锁\",\"sort\":1,\"children\":[],\"level\":2},{\"title\":\"Redlock\",\"id\":\"20220428141728-qbzn1tc\",\"type\":\"d\",\"href\":\"/topic/redis/Redis的分布式锁/Redlock\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis的分布式锁/Redlock\",\"parentPath\":\"/topic/redis/Redis的分布式锁\",\"sort\":2,\"children\":[{\"title\":\"问题1\",\"id\":\"20220428141728-lg0r797\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁/Redlock#问题1\",\"parentId\":\"20220428141728-qbzn1tc\",\"path\":\"/topic/redis/Redis的分布式锁/Redlock\",\"parentPath\":\"/topic/redis/Redis的分布式锁\",\"children\":[],\"level\":3},{\"title\":\"问题2\",\"id\":\"20220428141728-nhr8fen\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁/Redlock#问题2\",\"parentId\":\"20220428141728-qbzn1tc\",\"path\":\"/topic/redis/Redis的分布式锁/Redlock\",\"parentPath\":\"/topic/redis/Redis的分布式锁\",\"children\":[],\"level\":3},{\"title\":\"问题3\",\"id\":\"20220428141728-5jc3ave\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁/Redlock#问题3\",\"parentId\":\"20220428141728-qbzn1tc\",\"path\":\"/topic/redis/Redis的分布式锁/Redlock\",\"parentPath\":\"/topic/redis/Redis的分布式锁\",\"children\":[],\"level\":3}],\"level\":2}],\"level\":1},{\"title\":\"Redis集群\",\"id\":\"20220428141727-awm7yu5\",\"type\":\"d\",\"href\":\"/topic/redis/Redis集群\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"sort\":6,\"children\":[{\"title\":\"三种集群方案\",\"id\":\"20220428141727-id6w37y\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#三种集群方案\",\"parentId\":\"20220428141727-awm7yu5\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":2},{\"title\":\"主从复制模式\",\"id\":\"20220428141727-01yokji\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#主从复制模式\",\"parentId\":\"20220428141727-awm7yu5\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"原理\",\"id\":\"20220428141727-2xgqon2\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#原理\",\"parentId\":\"20220428141727-01yokji\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"redis主从复制的坑\",\"id\":\"20220428141727-h04f0fa\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#redis主从复制的坑\",\"parentId\":\"20220428141727-01yokji\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"哨兵模式\",\"id\":\"20220428141727-jxcatge\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#哨兵模式\",\"parentId\":\"20220428141727-awm7yu5\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"哨兵模式的作用\",\"id\":\"20220428141727-3jb6vil\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#哨兵模式的作用\",\"parentId\":\"20220428141727-jxcatge\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"故障切换的过程\",\"id\":\"20220428141727-uscl9hh\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#故障切换的过程\",\"parentId\":\"20220428141727-jxcatge\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"哨兵模式的工作方式：\",\"id\":\"20220428141727-fe5liq6\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#哨兵模式的工作方式：\",\"parentId\":\"20220428141727-jxcatge\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"哨兵模式的优缺点\",\"id\":\"20220428141727-fq18erp\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#哨兵模式的优缺点\",\"parentId\":\"20220428141727-jxcatge\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"Cluster 集群模式（Redis官方）\",\"id\":\"20220428141727-z0udk1o\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#Cluster 集群模式（Redis官方）\",\"parentId\":\"20220428141727-awm7yu5\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"集群的数据分片\",\"id\":\"20220428141727-zez6jhc\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#集群的数据分片\",\"parentId\":\"20220428141727-z0udk1o\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"Redis 集群的主从复制模型\",\"id\":\"20220428141727-guu9h2l\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#Redis 集群的主从复制模型\",\"parentId\":\"20220428141727-z0udk1o\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"集群的特点\",\"id\":\"20220428141727-a9a9ogo\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#集群的特点\",\"parentId\":\"20220428141727-z0udk1o\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"Redis数据淘汰策略\",\"id\":\"20220428141727-oaw8wmd\",\"type\":\"d\",\"href\":\"/topic/redis/Redis集群/Redis数据淘汰策略\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis集群/Redis数据淘汰策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"sort\":5,\"children\":[{\"title\":\"Redis的内存淘汰策略，有以下几种\",\"id\":\"20220428141727-aort8cn\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据淘汰策略#Redis的内存淘汰策略，有以下几种\",\"parentId\":\"20220428141727-oaw8wmd\",\"path\":\"/topic/redis/Redis集群/Redis数据淘汰策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":3},{\"title\":\"数据库中有 3000w 的数据，而 Redis 中只有 100w 数据，如何保证 Redis 中存放的都是热点数据\",\"id\":\"20220428141727-egla613\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据淘汰策略#数据库中有 3000w 的数据，而 Redis 中只有 100w 数据，如何保证 Redis 中存放的都是热点数据\",\"parentId\":\"20220428141727-oaw8wmd\",\"path\":\"/topic/redis/Redis集群/Redis数据淘汰策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"redis持久化\",\"id\":\"20220428141728-ahu8hnn\",\"type\":\"d\",\"href\":\"/topic/redis/Redis集群/redis持久化\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"sort\":8,\"children\":[{\"title\":\"策略\",\"id\":\"20220428141728-h8spnbe\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#策略\",\"parentId\":\"20220428141728-ahu8hnn\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":3},{\"title\":\"AOF持久化\",\"id\":\"20220428141728-8sb3e90\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#AOF持久化\",\"parentId\":\"20220428141728-ahu8hnn\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[{\"title\":\"执行流程\",\"id\":\"20220428141728-xdy9wq3\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#执行流程\",\"parentId\":\"20220428141728-8sb3e90\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4},{\"title\":\"怎么防止AOF文件越来越大？\",\"id\":\"20220428141728-2fjjnsi\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#怎么防止AOF文件越来越大？\",\"parentId\":\"20220428141728-8sb3e90\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[{\"title\":\"AOF文件追加阻塞？\",\"id\":\"20220428141728-jggnla6\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#AOF文件追加阻塞？\",\"parentId\":\"20220428141728-2fjjnsi\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"RDB持久化\",\"id\":\"20220428141728-3uk1dzb\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#RDB持久化\",\"parentId\":\"20220428141728-ahu8hnn\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[{\"title\":\"执行流程\",\"id\":\"20220428141728-b6xujxs\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#执行流程\",\"parentId\":\"20220428141728-3uk1dzb\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"混合持久化（Redis4.0+）\",\"id\":\"20220428141728-z9bdsb4\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#混合持久化（Redis4.0+）\",\"parentId\":\"20220428141728-ahu8hnn\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[{\"title\":\"执行流程\",\"id\":\"20220428141728-flzi42f\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#执行流程\",\"parentId\":\"20220428141728-z9bdsb4\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"Redis的数据恢复策略\",\"id\":\"20220428141728-x9y47t6\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#Redis的数据恢复策略\",\"parentId\":\"20220428141728-ahu8hnn\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":3},{\"title\":\"Redis持久化策略该如何进行选择\",\"id\":\"20220428141728-54y3bdq\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#Redis持久化策略该如何进行选择\",\"parentId\":\"20220428141728-ahu8hnn\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[{\"title\":\"1.不需要考虑数据丢失的情况\",\"id\":\"20220428141728-ujbrmwt\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#1.不需要考虑数据丢失的情况\",\"parentId\":\"20220428141728-54y3bdq\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4},{\"title\":\"2.单机实例情况下\",\"id\":\"20220428141728-zahznfw\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#2.单机实例情况下\",\"parentId\":\"20220428141728-54y3bdq\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4},{\"title\":\"3.在主从环境下\",\"id\":\"20220428141728-jbd8vij\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#3.在主从环境下\",\"parentId\":\"20220428141728-54y3bdq\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[{\"title\":\"那么在从服务器进行数据热备份的情况下，是否还需要持久化呢？\",\"id\":\"20220428141728-sjs8krt\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#那么在从服务器进行数据热备份的情况下，是否还需要持久化呢？\",\"parentId\":\"20220428141728-jbd8vij\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":5},{\"title\":\"4.异地灾备\",\"id\":\"20220428141728-aryf17w\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#4.异地灾备\",\"parentId\":\"20220428141728-jbd8vij\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"Redis数据删除策略\",\"id\":\"20220428141727-pvzi1zo\",\"type\":\"d\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"sort\":13,\"children\":[{\"title\":\"惰性删除\",\"id\":\"20220428141727-o0rija8\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#惰性删除\",\"parentId\":\"20220428141727-pvzi1zo\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":3},{\"title\":\"定期删除\",\"id\":\"20220428141727-wq9axfb\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#定期删除\",\"parentId\":\"20220428141727-pvzi1zo\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":3},{\"title\":\"AOF、RDB 和复制功能对过期键的处理\",\"id\":\"20220428141727-gr8a4lk\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#AOF、RDB 和复制功能对过期键的处理\",\"parentId\":\"20220428141727-pvzi1zo\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[{\"title\":\"RDB\",\"id\":\"20220428141727-xhxrdyf\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#RDB\",\"parentId\":\"20220428141727-gr8a4lk\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4},{\"title\":\"AOF\",\"id\":\"20220428141727-z7l5azb\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#AOF\",\"parentId\":\"20220428141727-gr8a4lk\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4},{\"title\":\"复制\",\"id\":\"20220428141727-vdap5h4\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#复制\",\"parentId\":\"20220428141727-gr8a4lk\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"疑问点？\",\"id\":\"20220428141727-5x39avu\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#疑问点？\",\"parentId\":\"20220428141727-pvzi1zo\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[{\"title\":\"如果主从服务器链接断开怎么办？\",\"id\":\"20220428141727-4505lb0\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#如果主从服务器链接断开怎么办？\",\"parentId\":\"20220428141727-5x39avu\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4},{\"title\":\"如果发生网络抖动，主服务器发送的 del 命令没有传递到从服务器怎么办？\",\"id\":\"20220428141727-4x9rpfk\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#如果发生网络抖动，主服务器发送的 del 命令没有传递到从服务器怎么办？\",\"parentId\":\"20220428141727-5x39avu\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2}],\"level\":1}],\"level\":0}"}},"pageContext":{"slug":"/topic/redis/Redis集群/Redis数据删除策略","topic":"redis"}},"staticQueryHashes":["1284643331","2841359383"]}