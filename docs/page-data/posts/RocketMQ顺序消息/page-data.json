{
    "componentChunkName": "component---src-templates-article-page-template-tsx",
    "path": "/posts/RocketMQ顺序消息",
    "result": {"pageContext":{"id":"/posts/RocketMQ顺序消息","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"RocketMQ顺序消息"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"消息有序指的是可以按照消息的发送顺序来消费(FIFO)。RocketMQ可以严格的保证消息有序，可以分为分区有序或者全局有序。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"电商的订单创建，以订单ID作为Sharding Key，那么同一个订单相关的创建订单消息、订单支付消息、订单退款消息、订单物流消息都会按照发布的先后顺序来消费。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"基本原理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在默认的情况下消息发送会采取Round Robin轮询方式把消息发送到不同的queue(分区队列)；"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"而消费消息的时候从多个queue上拉取消息，这种情况发送和消费是不能保证顺序。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如下图所示:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://image.ztianzeng.com/uPic/20220509173821.png","alt":""},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://image.ztianzeng.com/uPic/20220509173700.png","alt":""},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但是如果控制发送的顺序消息只依次发送到同一个queue中，消费的时候只从这个queue上依次拉取，则就保证了顺序。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"当发送和消费参与的queue只有一个，则是全局有序；如果多个queue参与，则为分区有序，即相对每个queue，消息都是有序的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://image.ztianzeng.com/uPic/20220509173907.png","alt":""},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"下面用订单进行分区有序的示例:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"一个订单的顺序流程是：创建、付款、推送、完成。订单号相同的消息会被先后发送到同一个队列中，消费时，同一个OrderId获取到的肯定是同一个队列。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public class Producer {\n   public static void main(String[] args) throws Exception {\n       DefaultMQProducer producer = new DefaultMQProducer(\"please_rename_unique_group_name\");\n       producer.setNamesrvAddr(\"127.0.0.1:9876\");\n       producer.start();\n       String[] tags = new String[]{\"TagA\", \"TagC\", \"TagD\"};\n       // 订单列表\n       List<OrderStep> orderList = new Producer().buildOrders();\n       Date date = new Date();\n       SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n       String dateStr = sdf.format(date);\n       for (int i = 0; i < 10; i++) {\n           // 加个时间前缀\n           String body = dateStr + \" Hello RocketMQ \" + orderList.get(i);\n           Message msg = new Message(\"TopicTest\", tags[i % tags.length], \"KEY\" + i, body.getBytes());\n\n           SendResult sendResult = producer.send(msg, new MessageQueueSelector() {\n               @Override\n               public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {\n                   Long id = (Long) arg;  //根据订单id选择发送queue\n                   long index = id % mqs.size();\n                   return mqs.get((int) index);\n               }\n           }, orderList.get(i).getOrderId());//订单id\n\n           System.out.printf(\"SendResult status:%s, queueId:%d, body:%s%n\",\n               sendResult.getSendStatus(),\n               sendResult.getMessageQueue().getQueueId(),\n               body);\n       }\n       producer.shutdown();\n   }\n\n   /**\n    * 订单的步骤\n    */\n   @Data\n   private static class OrderStep {\n       private long orderId;\n       private String desc;\n   }\n\n   /**\n    * 生成模拟订单数据\n    */\n   private List<OrderStep> buildOrders() {\n       List<OrderStep> orderList = new ArrayList<OrderStep>();\n       OrderStep orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103111039L);\n       orderDemo.setDesc(\"创建\");\n       orderList.add(orderDemo);\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103111065L);\n       orderDemo.setDesc(\"创建\");\n       orderList.add(orderDemo);\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103111039L);\n       orderDemo.setDesc(\"付款\");\n       orderList.add(orderDemo);\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103117235L);\n       orderDemo.setDesc(\"创建\");\n       orderList.add(orderDemo);\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103111065L);\n       orderDemo.setDesc(\"付款\");\n       orderList.add(orderDemo);\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103117235L);\n       orderDemo.setDesc(\"付款\");\n       orderList.add(orderDemo);\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103111065L);\n       orderDemo.setDesc(\"完成\");\n       orderList.add(orderDemo);\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103111039L);\n       orderDemo.setDesc(\"推送\");\n       orderList.add(orderDemo);\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103117235L);\n       orderDemo.setDesc(\"完成\");\n       orderList.add(orderDemo);\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103111039L);\n       orderDemo.setDesc(\"完成\");\n       orderList.add(orderDemo);\n       return orderList;\n   }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这是消费者的代码:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public class ConsumerInOrder {\n   public static void main(String[] args) throws Exception {\n       DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"please_rename_unique_group_name_3\");\n       consumer.setNamesrvAddr(\"127.0.0.1:9876\");\n       /**\n        * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费<br>\n        * 如果非第一次启动，那么按照上次消费的位置继续消费\n        */\n       consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n       consumer.subscribe(\"TopicTest\", \"TagA || TagC || TagD\");\n       consumer.registerMessageListener(new MessageListenerOrderly() {\n           Random random = new Random();\n\n           @Override\n           public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {\n               context.setAutoCommit(true);\n               for (MessageExt msg : msgs) {\n                   // 可以看到每个queue有唯一的consume线程来消费, 订单对每个queue(分区)有序\n                   System.out.println(\"consumeThread=\" + Thread.currentThread().getName() + \"queueId=\" + msg.getQueueId() + \", content:\" + new String(msg.getBody()));\n               }\n               try {\n                   //模拟业务逻辑处理中...\n                   TimeUnit.SECONDS.sleep(random.nextInt(10));\n               } catch (Exception e) {\n                   e.printStackTrace();\n               }\n               return ConsumeOrderlyStatus.SUCCESS;\n           }\n       });\n       consumer.start();\n       System.out.println(\"Consumer Started.\");\n   }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"可以看出来，生产者那边需要实现"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"MessageQueueSelector"}]},{"type":"text","value":"完成队列的选举，而消费者需要实现"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"MessageListenerOrderly"}]},{"type":"text","value":"以完成消息的顺序消费"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"问题"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果我们整个RocketMQ搭建的环境是，单个NameServer当个Broker的话，初始MessageQueue的队列为4。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"有ID为13, 整个时候Hash情况如下图所示:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://image.ztianzeng.com/uPic/20220510133921.png","alt":""},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们由于业务的增长，新增了一个Broker，Broker非成倍数扩容，导致逻辑队列的QueueId无法路由到原有队列中，就变成了这样"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://image.ztianzeng.com/uPic/20220510141046.png","alt":""},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"解决方案"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"成倍扩容"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"成倍扩容，实现扩容前后，同样的 key，hash 到原队列，或者 hash 到新扩容的队列。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因为可以参考HashMap的成倍扩容原理，消息要么在原队列上，要么在原有队列上+扩容的长度，由于RocketMQ的特性，他们的QueueId是一致的，所以可以顺序消费"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"一致性Hash"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"用一致性Hash来计算需要放置的MessageQueue队列"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"自定义负载算法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"实现一个自定义的队列负载算法，需要传入一个队列的总队列个数，在负载均衡过程中如果发现数量不对时将消息先暂存到数据库，并将这些失败的队列信息存储到redis中，在发送新消息时，如果计算的负载队列是失败的队列，并且当前的队列信息已经恢复到当前初始值，则先判断数据库中是否有待发送到消息，如果有，则继续将消息发送到数据库，并开启一个线程，将数据库中的消息发送到mq中，这样后续的消息就会继续进入到MQ"}]}],"data":{"quirksMode":false}},"headings":[{"depth":1,"value":"RocketMQ顺序消息","slug":"rocketmq顺序消息"},{"depth":1,"value":"基本原理","slug":"基本原理-1"},{"depth":1,"value":"问题","slug":"问题"},{"depth":1,"value":"解决方案","slug":"解决方案"},{"depth":2,"value":"成倍扩容","slug":"成倍扩容"},{"depth":2,"value":"一致性Hash","slug":"一致性hash"},{"depth":2,"value":"自定义负载算法","slug":"自定义负载算法"}]}},
    "staticQueryHashes": ["928362550"]}