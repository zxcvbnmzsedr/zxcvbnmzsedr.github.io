(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{388:function(t,a,s){"use strict";s.r(a);var r=s(6),v=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"对比自旋和非自旋获取锁的流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对比自旋和非自旋获取锁的流程"}},[t._v("#")]),t._v(" 对比自旋和非自旋获取锁的流程")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://www.shiyitopo.tech/uPic/%E8%87%AA%E6%97%8B%E9%94%81%E9%80%BB%E8%BE%91.svg",alt:"自旋锁逻辑"}})]),t._v(" "),a("h2",{attrs:{id:"自旋锁的好处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自旋锁的好处"}},[t._v("#")]),t._v(" 自旋锁的好处")]),t._v(" "),a("p",[t._v("首先，阻塞和唤醒线程都是需要高昂的开销的，如果同步代码块中的内容不复杂，那么可能转换线程带来的开销比实际业务代码执行的开销还要大。")]),t._v(" "),a("p",[t._v("在很多场景下，可能我们的同步代码块的内容并不多，所以需要的执行时间也很短，如果我们仅仅为了这点时间就去切换线程状态，那么其实不如让线程不切换状态，而是让它自旋地尝试获取锁，等待其他线程释放锁，有时我只需要稍等一下，就可以避免上下文切换等开销，提高了效率。")]),t._v(" "),a("p",[t._v("用一句话总结自旋锁的好处，那就是自旋锁用循环去不停地尝试获取锁，让线程始终处于 Runnable 状态，节省了线程状态切换带来的开销。")]),t._v(" "),a("h2",{attrs:{id:"自旋锁的缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自旋锁的缺点"}},[t._v("#")]),t._v(" 自旋锁的缺点")]),t._v(" "),a("p",[t._v("虽然避免了线程切换的开销，但是它在避免线程切换开销的同时也带来了新的开销，因为它需要不停得去尝试获取锁。")]),t._v(" "),a("p",[t._v("如果这把锁一直不能被释放，那么这种尝试只是无用的尝试，会白白浪费处理器资源。")]),t._v(" "),a("p",[t._v("也就是说，虽然一开始自旋锁的开销低于线程切换，但是随着时间的增加，这种开销也是水涨船高，后期甚至会超过线程切换的开销，得不偿失。")]),t._v(" "),a("h2",{attrs:{id:"适用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#适用场景"}},[t._v("#")]),t._v(" 适用场景")]),t._v(" "),a("p",[t._v("首先，自旋锁适用于并发度不是特别高的场景，以及临界区比较短小的情况，这样我们可以利用避免线程切换来提高效率。")]),t._v(" "),a("p",[t._v("可是如果临界区很大，线程一旦拿到锁，很久才会释放的话，那就不合适用自旋锁，因为自旋会一直占用 CPU 却无法拿到锁，白白消耗资源。")])])}),[],!1,null,null,null);a.default=v.exports}}]);