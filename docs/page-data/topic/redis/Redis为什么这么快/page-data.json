{
    "componentChunkName": "component---src-templates-topic-page-template-tsx",
    "path": "/topic/redis/Redis为什么这么快",
    "result": {"pageContext":{"id":"/topic/redis/Redis为什么这么快","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"完全基于内存"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　所有的运算都是内存级别的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"数据结构简单"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　Redis中所有的数据结构都是重新设计过的，这些重新设计的数据结构大部分时间复杂度都是O(1)。 举例：string这个类型没有采用C原生的string，而是重新设计了一套sds(simple dynamic string)的结构"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"工作线程采用单线程，避免了线程上下文切换所带来的损耗"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　redis的作者认为，性能瓶颈是在于内存或者网络带宽并非cpu，所以多线程并不会带来更大的提升（其实是作者懒，强行解释）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”。\n这也是Redis对外提供键值存储服务的主要流程。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　6.0之后，Redis的其他功能， 比如持久化、异步删除、集群数据同步等等，其实是由额外的线程执行的。 因此说，Redis工作线程是单线程的，但是，整个Redis来说，是多线程的(多线程默认是关闭的)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"对于客户端的连接采用多路复用和非阻塞I/O"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　Redis使用I/O多路复用功能来监听多个socket连接客户端， 这样就可以使用一个线程连接来处理多个请求，减少线程切换带来的开销，同时也避免了 I/O 阻塞操作"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"style","properties":{"className":["grvsc-styles"]},"children":[{"type":"text","value":"\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n"}]}],"data":{"quirksMode":false}},"html":"<h1 id=\"完全基于内存\">完全基于内存</h1>\n<p updated=\"20220722161128\">　　所有的运算都是内存级别的。</p>\n<h1 id=\"数据结构简单\">数据结构简单</h1>\n<p updated=\"20220722161128\">　　Redis中所有的数据结构都是重新设计过的，这些重新设计的数据结构大部分时间复杂度都是O(1)。 举例：string这个类型没有采用C原生的string，而是重新设计了一套sds(simple dynamic string)的结构</p>\n<h1 id=\"工作线程采用单线程-避免了线程上下文切换所带来的损耗\">工作线程采用单线程，避免了线程上下文切换所带来的损耗</h1>\n<p updated=\"20220722161128\">　　redis的作者认为，性能瓶颈是在于内存或者网络带宽并非cpu，所以多线程并不会带来更大的提升（其实是作者懒，强行解释）。</p>\n<p updated=\"20220722161128\">　　Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”。<br />\n这也是Redis对外提供键值存储服务的主要流程。</p>\n<p updated=\"20220722161128\">　　6.0之后，Redis的其他功能， 比如持久化、异步删除、集群数据同步等等，其实是由额外的线程执行的。 因此说，Redis工作线程是单线程的，但是，整个Redis来说，是多线程的(多线程默认是关闭的).</p>\n<h1 id=\"对于客户端的连接采用多路复用和非阻塞I-O\">对于客户端的连接采用多路复用和非阻塞I/O</h1>\n<p updated=\"20220722161128\">　　Redis使用I/O多路复用功能来监听多个socket连接客户端， 这样就可以使用一个线程连接来处理多个请求，减少线程切换带来的开销，同时也避免了 I/O 阻塞操作</p>\n","articleNode":{"field":{"contentType":"topic","topic":"redis"},"frontmatter":{"id":"/topic/redis/Redis为什么这么快","title":"Redis为什么这么快","date":"2022-04-28 14:17","absolute_path":"/topic/redis/Redis为什么这么快"},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"完全基于内存"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　所有的运算都是内存级别的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"数据结构简单"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　Redis中所有的数据结构都是重新设计过的，这些重新设计的数据结构大部分时间复杂度都是O(1)。 举例：string这个类型没有采用C原生的string，而是重新设计了一套sds(simple dynamic string)的结构"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"工作线程采用单线程，避免了线程上下文切换所带来的损耗"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　redis的作者认为，性能瓶颈是在于内存或者网络带宽并非cpu，所以多线程并不会带来更大的提升（其实是作者懒，强行解释）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”。\n这也是Redis对外提供键值存储服务的主要流程。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　6.0之后，Redis的其他功能， 比如持久化、异步删除、集群数据同步等等，其实是由额外的线程执行的。 因此说，Redis工作线程是单线程的，但是，整个Redis来说，是多线程的(多线程默认是关闭的)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"对于客户端的连接采用多路复用和非阻塞I/O"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　Redis使用I/O多路复用功能来监听多个socket连接客户端， 这样就可以使用一个线程连接来处理多个请求，减少线程切换带来的开销，同时也避免了 I/O 阻塞操作"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"style","properties":{"className":["grvsc-styles"]},"children":[{"type":"text","value":"\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n"}]}],"data":{"quirksMode":false}},"html":"<h1 id=\"完全基于内存\">完全基于内存</h1>\n<p updated=\"20220722161128\">　　所有的运算都是内存级别的。</p>\n<h1 id=\"数据结构简单\">数据结构简单</h1>\n<p updated=\"20220722161128\">　　Redis中所有的数据结构都是重新设计过的，这些重新设计的数据结构大部分时间复杂度都是O(1)。 举例：string这个类型没有采用C原生的string，而是重新设计了一套sds(simple dynamic string)的结构</p>\n<h1 id=\"工作线程采用单线程-避免了线程上下文切换所带来的损耗\">工作线程采用单线程，避免了线程上下文切换所带来的损耗</h1>\n<p updated=\"20220722161128\">　　redis的作者认为，性能瓶颈是在于内存或者网络带宽并非cpu，所以多线程并不会带来更大的提升（其实是作者懒，强行解释）。</p>\n<p updated=\"20220722161128\">　　Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”。<br />\n这也是Redis对外提供键值存储服务的主要流程。</p>\n<p updated=\"20220722161128\">　　6.0之后，Redis的其他功能， 比如持久化、异步删除、集群数据同步等等，其实是由额外的线程执行的。 因此说，Redis工作线程是单线程的，但是，整个Redis来说，是多线程的(多线程默认是关闭的).</p>\n<h1 id=\"对于客户端的连接采用多路复用和非阻塞I-O\">对于客户端的连接采用多路复用和非阻塞I/O</h1>\n<p updated=\"20220722161128\">　　Redis使用I/O多路复用功能来监听多个socket连接客户端， 这样就可以使用一个线程连接来处理多个请求，减少线程切换带来的开销，同时也避免了 I/O 阻塞操作</p>\n","headings":[{"depth":1,"value":"完全基于内存"},{"depth":1,"value":"数据结构简单"},{"depth":1,"value":"工作线程采用单线程，避免了线程上下文切换所带来的损耗"},{"depth":1,"value":"对于客户端的连接采用多路复用和非阻塞I/O"}],"path":"/topic/redis/Redis为什么这么快"},"tree":{"title":"redis","id":"20220428141727-a3p03i0","parentId":"","href":"/topic/redis","path":"/topic/redis","children":[{"title":"Redis为什么这么快","id":"20220428141727-jbyo2wp","type":"d","href":"/topic/redis/Redis为什么这么快","parentId":"","path":"/topic/redis/Redis为什么这么快","parentPath":"/topic/redis","sort":1,"children":[{"title":"完全基于内存","id":"20220428141727-m8thckv","type":"h","href":"/topic/redis/Redis为什么这么快#完全基于内存","parentId":"20220428141727-jbyo2wp","path":"/topic/redis/Redis为什么这么快","parentPath":"/topic/redis","children":[],"level":2},{"title":"数据结构简单","id":"20220428141727-0532nq9","type":"h","href":"/topic/redis/Redis为什么这么快#数据结构简单","parentId":"20220428141727-jbyo2wp","path":"/topic/redis/Redis为什么这么快","parentPath":"/topic/redis","children":[],"level":2},{"title":"工作线程采用单线程，避免了线程上下文切换所带来的损耗","id":"20220428141727-kw7bg9v","type":"h","href":"/topic/redis/Redis为什么这么快#工作线程采用单线程，避免了线程上下文切换所带来的损耗","parentId":"20220428141727-jbyo2wp","path":"/topic/redis/Redis为什么这么快","parentPath":"/topic/redis","children":[],"level":2},{"title":"对于客户端的连接采用多路复用和非阻塞I/O","id":"20220428141727-m7ruuk1","type":"h","href":"/topic/redis/Redis为什么这么快#对于客户端的连接采用多路复用和非阻塞I/O","parentId":"20220428141727-jbyo2wp","path":"/topic/redis/Redis为什么这么快","parentPath":"/topic/redis","children":[],"level":2},{"title":"redis单线程的问题","id":"20220428141728-w6wf4kq","type":"d","href":"/topic/redis/Redis为什么这么快/redis单线程的问题","parentId":"","path":"/topic/redis/Redis为什么这么快/redis单线程的问题","parentPath":"/topic/redis/Redis为什么这么快","sort":11,"children":[],"level":2}],"level":1},{"title":"Redis基本数据结构","id":"20220428141727-imsmasu","type":"d","href":"/topic/redis/Redis基本数据结构","parentId":"","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","sort":2,"children":[{"title":"常用的","id":"20220428141727-1gclyg6","type":"h","href":"/topic/redis/Redis基本数据结构#常用的","parentId":"20220428141727-imsmasu","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[{"title":"string","id":"20220428141727-u2m7nzt","type":"h","href":"/topic/redis/Redis基本数据结构#string","parentId":"20220428141727-1gclyg6","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[],"level":3},{"title":"hash","id":"20220428141727-po0l8p4","type":"h","href":"/topic/redis/Redis基本数据结构#hash","parentId":"20220428141727-1gclyg6","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[],"level":3},{"title":"list","id":"20220428141727-nyjx5v1","type":"h","href":"/topic/redis/Redis基本数据结构#list","parentId":"20220428141727-1gclyg6","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[],"level":3},{"title":"set","id":"20220428141727-ujl3jkq","type":"h","href":"/topic/redis/Redis基本数据结构#set","parentId":"20220428141727-1gclyg6","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[],"level":3},{"title":"zset","id":"20220428141727-8lh8dqt","type":"h","href":"/topic/redis/Redis基本数据结构#zset","parentId":"20220428141727-1gclyg6","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[],"level":3}],"level":2},{"title":"扩展结构","id":"20220428141727-9xu8ei1","type":"h","href":"/topic/redis/Redis基本数据结构#扩展结构","parentId":"20220428141727-imsmasu","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[{"title":"bitmap","id":"20220428141727-89gt7iy","type":"h","href":"/topic/redis/Redis基本数据结构#bitmap","parentId":"20220428141727-9xu8ei1","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[],"level":3},{"title":"hyperloglog","id":"20220428141727-08upaib","type":"h","href":"/topic/redis/Redis基本数据结构#hyperloglog","parentId":"20220428141727-9xu8ei1","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[],"level":3},{"title":"GEO","id":"20220428141727-6z03dvm","type":"h","href":"/topic/redis/Redis基本数据结构#GEO","parentId":"20220428141727-9xu8ei1","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[],"level":3}],"level":2},{"title":"扩展功能","id":"20220428141727-x5n4s7y","type":"h","href":"/topic/redis/Redis基本数据结构#扩展功能","parentId":"20220428141727-imsmasu","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[{"title":"pub/sub","id":"20220428141727-zay76x9","type":"h","href":"/topic/redis/Redis基本数据结构#pub/sub","parentId":"20220428141727-x5n4s7y","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[],"level":3},{"title":"pipeline","id":"20220428141727-m3750uw","type":"h","href":"/topic/redis/Redis基本数据结构#pipeline","parentId":"20220428141727-x5n4s7y","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[],"level":3},{"title":"Lua 脚本","id":"20220428141727-6rc0qt7","type":"h","href":"/topic/redis/Redis基本数据结构#Lua 脚本","parentId":"20220428141727-x5n4s7y","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[],"level":3},{"title":"事务","id":"20220428141727-8i9gpxn","type":"h","href":"/topic/redis/Redis基本数据结构#事务","parentId":"20220428141727-x5n4s7y","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[],"level":3}],"level":2},{"title":"String的底层实现","id":"20220428141728-d2hmuxd","type":"d","href":"/topic/redis/Redis基本数据结构/String的底层实现","parentId":"","path":"/topic/redis/Redis基本数据结构/String的底层实现","parentPath":"/topic/redis/Redis基本数据结构","sort":1,"children":[{"title":"SDS 结构","id":"20220428141728-y2039os","type":"h","href":"/topic/redis/Redis基本数据结构/String的底层实现#SDS 结构","parentId":"20220428141728-d2hmuxd","path":"/topic/redis/Redis基本数据结构/String的底层实现","parentPath":"/topic/redis/Redis基本数据结构","children":[],"level":3},{"title":"相对于C语言的优势","id":"20220428141728-8t63ohh","type":"h","href":"/topic/redis/Redis基本数据结构/String的底层实现#相对于C语言的优势","parentId":"20220428141728-d2hmuxd","path":"/topic/redis/Redis基本数据结构/String的底层实现","parentPath":"/topic/redis/Redis基本数据结构","children":[{"title":"统计长度时间复杂度 O(1)","id":"20220428141728-xeqpgol","type":"h","href":"/topic/redis/Redis基本数据结构/String的底层实现#统计长度时间复杂度 O(1)","parentId":"20220428141728-8t63ohh","path":"/topic/redis/Redis基本数据结构/String的底层实现","parentPath":"/topic/redis/Redis基本数据结构","children":[],"level":4},{"title":"数据溢出","id":"20220428141728-coew455","type":"h","href":"/topic/redis/Redis基本数据结构/String的底层实现#数据溢出","parentId":"20220428141728-8t63ohh","path":"/topic/redis/Redis基本数据结构/String的底层实现","parentPath":"/topic/redis/Redis基本数据结构","children":[],"level":4},{"title":"内存重分配策略","id":"20220428141728-mbwnou1","type":"h","href":"/topic/redis/Redis基本数据结构/String的底层实现#内存重分配策略","parentId":"20220428141728-8t63ohh","path":"/topic/redis/Redis基本数据结构/String的底层实现","parentPath":"/topic/redis/Redis基本数据结构","children":[],"level":4},{"title":"数据格式多样性","id":"20220428141728-5h2se0u","type":"h","href":"/topic/redis/Redis基本数据结构/String的底层实现#数据格式多样性","parentId":"20220428141728-8t63ohh","path":"/topic/redis/Redis基本数据结构/String的底层实现","parentPath":"/topic/redis/Redis基本数据结构","children":[],"level":4}],"level":3},{"title":"三大编码","id":"20220428141728-t4votze","type":"h","href":"/topic/redis/Redis基本数据结构/String的底层实现#三大编码","parentId":"20220428141728-d2hmuxd","path":"/topic/redis/Redis基本数据结构/String的底层实现","parentPath":"/topic/redis/Redis基本数据结构","children":[],"level":3}],"level":2},{"title":"List的底层实现","id":"20220428141727-skh553t","type":"d","href":"/topic/redis/Redis基本数据结构/List的底层实现","parentId":"","path":"/topic/redis/Redis基本数据结构/List的底层实现","parentPath":"/topic/redis/Redis基本数据结构","sort":2,"children":[],"level":2},{"title":"Hash的底层实现","id":"20220428141727-g51ewzt","type":"d","href":"/topic/redis/Redis基本数据结构/Hash的底层实现","parentId":"","path":"/topic/redis/Redis基本数据结构/Hash的底层实现","parentPath":"/topic/redis/Redis基本数据结构","sort":3,"children":[{"title":"ZipList编码的哈希对象","id":"20220428141727-fo8pixs","type":"h","href":"/topic/redis/Redis基本数据结构/Hash的底层实现#ZipList编码的哈希对象","parentId":"20220428141727-g51ewzt","path":"/topic/redis/Redis基本数据结构/Hash的底层实现","parentPath":"/topic/redis/Redis基本数据结构","children":[],"level":3},{"title":"hashtable对象","id":"20220428141727-f7zok8f","type":"h","href":"/topic/redis/Redis基本数据结构/Hash的底层实现#hashtable对象","parentId":"20220428141727-g51ewzt","path":"/topic/redis/Redis基本数据结构/Hash的底层实现","parentPath":"/topic/redis/Redis基本数据结构","children":[],"level":3}],"level":2},{"title":"Set的底层实现","id":"20220428141728-5c6e914","type":"d","href":"/topic/redis/Redis基本数据结构/Set的底层实现","parentId":"","path":"/topic/redis/Redis基本数据结构/Set的底层实现","parentPath":"/topic/redis/Redis基本数据结构","sort":4,"children":[],"level":2},{"title":"ZSet的底层实现","id":"20220428141728-58eined","type":"d","href":"/topic/redis/Redis基本数据结构/ZSet的底层实现","parentId":"","path":"/topic/redis/Redis基本数据结构/ZSet的底层实现","parentPath":"/topic/redis/Redis基本数据结构","sort":5,"children":[{"title":"跳表是什么?","id":"20220428141728-9by553n","type":"h","href":"/topic/redis/Redis基本数据结构/ZSet的底层实现#跳表是什么?","parentId":"20220428141728-58eined","path":"/topic/redis/Redis基本数据结构/ZSet的底层实现","parentPath":"/topic/redis/Redis基本数据结构","children":[{"title":"优缺点","id":"20220428141728-rvbr2il","type":"h","href":"/topic/redis/Redis基本数据结构/ZSet的底层实现#优缺点","parentId":"20220428141728-9by553n","path":"/topic/redis/Redis基本数据结构/ZSet的底层实现","parentPath":"/topic/redis/Redis基本数据结构","children":[],"level":4}],"level":3}],"level":2}],"level":1},{"title":"Redis分布式缓存","id":"20220428141727-3x1i5zp","type":"d","href":"/topic/redis/Redis分布式缓存","parentId":"","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","sort":3,"children":[{"title":"双写一致性","id":"20220428141727-zahxna7","type":"h","href":"/topic/redis/Redis分布式缓存#双写一致性","parentId":"20220428141727-3x1i5zp","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":2},{"title":"缓存更新策略","id":"20220428141727-iqgn80l","type":"h","href":"/topic/redis/Redis分布式缓存#缓存更新策略","parentId":"20220428141727-3x1i5zp","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[{"title":"最常见的策略","id":"20220428141727-45wxv7a","type":"h","href":"/topic/redis/Redis分布式缓存#最常见的策略","parentId":"20220428141727-iqgn80l","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[{"title":"优点剖析","id":"20220428141727-tfanvhu","type":"h","href":"/topic/redis/Redis分布式缓存#优点剖析","parentId":"20220428141727-45wxv7a","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":4},{"title":"1. “先淘汰缓存，再写数据库” 合理","id":"20220428141727-vzyp7bi","type":"h","href":"/topic/redis/Redis分布式缓存#1. “先淘汰缓存，再写数据库” 合理","parentId":"20220428141727-45wxv7a","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":4},{"title":"2. 异步刷新，补缺补漏","id":"20220428141727-kbueoxr","type":"h","href":"/topic/redis/Redis分布式缓存#2. 异步刷新，补缺补漏","parentId":"20220428141727-45wxv7a","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":4},{"title":"缺点剖析","id":"20220428141727-sd1lbh3","type":"h","href":"/topic/redis/Redis分布式缓存#缺点剖析","parentId":"20220428141727-45wxv7a","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":4},{"title":"1. 容灾不足","id":"20220428141727-aff14q4","type":"h","href":"/topic/redis/Redis分布式缓存#1. 容灾不足","parentId":"20220428141727-45wxv7a","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":4},{"title":"2. 并发问题","id":"20220428141727-7kjhtfn","type":"h","href":"/topic/redis/Redis分布式缓存#2. 并发问题","parentId":"20220428141727-45wxv7a","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":4},{"title":"方案总结","id":"20220428141727-5w2loli","type":"h","href":"/topic/redis/Redis分布式缓存#方案总结","parentId":"20220428141727-45wxv7a","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":4},{"title":"写流程：","id":"20220428141727-s959uv0","type":"h","href":"/topic/redis/Redis分布式缓存#写流程：","parentId":"20220428141727-45wxv7a","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":4},{"title":"读流程：","id":"20220428141727-sceljri","type":"h","href":"/topic/redis/Redis分布式缓存#读流程：","parentId":"20220428141727-45wxv7a","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":4}],"level":3},{"title":"方案分析","id":"20220428141727-7flpl0m","type":"h","href":"/topic/redis/Redis分布式缓存#方案分析","parentId":"20220428141727-iqgn80l","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[{"title":"优点剖析","id":"20220428141727-1cqjx66","type":"h","href":"/topic/redis/Redis分布式缓存#优点剖析","parentId":"20220428141727-7flpl0m","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[{"title":"1. 容灾","id":"20220428141727-w9bvsqf","type":"h","href":"/topic/redis/Redis分布式缓存#1. 容灾","parentId":"20220428141727-1cqjx66","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":5}],"level":4},{"title":"缺点剖析","id":"20220428141727-n1twxfd","type":"h","href":"/topic/redis/Redis分布式缓存#缺点剖析","parentId":"20220428141727-7flpl0m","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[{"title":"1. 只适合简单业务，复杂业务容易发生并发问题","id":"20220428141727-t5kobxh","type":"h","href":"/topic/redis/Redis分布式缓存#1. 只适合简单业务，复杂业务容易发生并发问题","parentId":"20220428141727-n1twxfd","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[{"title":"缺点1的改进","id":"20220428141727-bz5ta88","type":"h","href":"/topic/redis/Redis分布式缓存#缺点1的改进","parentId":"20220428141727-t5kobxh","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":6}],"level":5},{"title":"2. 依然是并发问题","id":"20220428141727-gysgmg1","type":"h","href":"/topic/redis/Redis分布式缓存#2. 依然是并发问题","parentId":"20220428141727-n1twxfd","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":5}],"level":4}],"level":3},{"title":"方案总结","id":"20220428141727-01sdgjy","type":"h","href":"/topic/redis/Redis分布式缓存#方案总结","parentId":"20220428141727-iqgn80l","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[{"title":"写流程：","id":"20220428141727-eglmgkf","type":"h","href":"/topic/redis/Redis分布式缓存#写流程：","parentId":"20220428141727-01sdgjy","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":4},{"title":"读流程：","id":"20220428141727-1vywbk4","type":"h","href":"/topic/redis/Redis分布式缓存#读流程：","parentId":"20220428141727-01sdgjy","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":4}],"level":3},{"title":"方案分析","id":"20220428141727-137lw2k","type":"h","href":"/topic/redis/Redis分布式缓存#方案分析","parentId":"20220428141727-iqgn80l","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[{"title":"优点剖析","id":"20220428141727-p0zad1o","type":"h","href":"/topic/redis/Redis分布式缓存#优点剖析","parentId":"20220428141727-137lw2k","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[{"title":"1. 容灾完善","id":"20220428141727-cawius6","type":"h","href":"/topic/redis/Redis分布式缓存#1. 容灾完善","parentId":"20220428141727-p0zad1o","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[{"title":"写流程容灾分析","id":"20220428141727-2d2z7fz","type":"h","href":"/topic/redis/Redis分布式缓存#写流程容灾分析","parentId":"20220428141727-cawius6","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":6},{"title":"读流程容灾分析","id":"20220428141727-4hr5okn","type":"h","href":"/topic/redis/Redis分布式缓存#读流程容灾分析","parentId":"20220428141727-cawius6","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":6}],"level":5},{"title":"2. 无并发问题","id":"20220428141727-uvwj2ga","type":"h","href":"/topic/redis/Redis分布式缓存#2. 无并发问题","parentId":"20220428141727-p0zad1o","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":5}],"level":4},{"title":"缺点剖析","id":"20220428141727-fmiz5zl","type":"h","href":"/topic/redis/Redis分布式缓存#缺点剖析","parentId":"20220428141727-137lw2k","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[{"title":"1. 增加Cache_0强依赖","id":"20220428141727-hr6lxu9","type":"h","href":"/topic/redis/Redis分布式缓存#1. 增加Cache_0强依赖","parentId":"20220428141727-fmiz5zl","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":5},{"title":"2. 复杂度是比较高的","id":"20220428141727-vbiftey","type":"h","href":"/topic/redis/Redis分布式缓存#2. 复杂度是比较高的","parentId":"20220428141727-fmiz5zl","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":5}],"level":4}],"level":3},{"title":"方案总结","id":"20220428141727-0an20z6","type":"h","href":"/topic/redis/Redis分布式缓存#方案总结","parentId":"20220428141727-iqgn80l","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":3}],"level":2},{"title":"缓存击穿","id":"20220428141728-p93afgy","type":"d","href":"/topic/redis/Redis分布式缓存/缓存击穿","parentId":"","path":"/topic/redis/Redis分布式缓存/缓存击穿","parentPath":"/topic/redis/Redis分布式缓存","sort":1,"children":[{"title":"解决方案","id":"20220428141728-27esyuz","type":"h","href":"/topic/redis/Redis分布式缓存/缓存击穿#解决方案","parentId":"20220428141728-p93afgy","path":"/topic/redis/Redis分布式缓存/缓存击穿","parentPath":"/topic/redis/Redis分布式缓存","children":[{"title":"不过期","id":"20220428141728-foxjedm","type":"h","href":"/topic/redis/Redis分布式缓存/缓存击穿#不过期","parentId":"20220428141728-27esyuz","path":"/topic/redis/Redis分布式缓存/缓存击穿","parentPath":"/topic/redis/Redis分布式缓存","children":[],"level":4},{"title":"互斥锁","id":"20220428141728-68zg08m","type":"h","href":"/topic/redis/Redis分布式缓存/缓存击穿#互斥锁","parentId":"20220428141728-27esyuz","path":"/topic/redis/Redis分布式缓存/缓存击穿","parentPath":"/topic/redis/Redis分布式缓存","children":[],"level":4}],"level":3}],"level":2},{"title":"缓存穿透","id":"20220428141728-64iljj5","type":"d","href":"/topic/redis/Redis分布式缓存/缓存穿透","parentId":"","path":"/topic/redis/Redis分布式缓存/缓存穿透","parentPath":"/topic/redis/Redis分布式缓存","sort":3,"children":[{"title":"接口校验","id":"20220428141728-wny00tb","type":"h","href":"/topic/redis/Redis分布式缓存/缓存穿透#接口校验","parentId":"20220428141728-64iljj5","path":"/topic/redis/Redis分布式缓存/缓存穿透","parentPath":"/topic/redis/Redis分布式缓存","children":[],"level":3},{"title":"空对象缓存或者缺省值","id":"20220428141728-6wjc642","type":"h","href":"/topic/redis/Redis分布式缓存/缓存穿透#空对象缓存或者缺省值","parentId":"20220428141728-64iljj5","path":"/topic/redis/Redis分布式缓存/缓存穿透","parentPath":"/topic/redis/Redis分布式缓存","children":[],"level":3},{"title":"布隆过滤器","id":"20220428141728-r9yad28","type":"h","href":"/topic/redis/Redis分布式缓存/缓存穿透#布隆过滤器","parentId":"20220428141728-64iljj5","path":"/topic/redis/Redis分布式缓存/缓存穿透","parentPath":"/topic/redis/Redis分布式缓存","children":[],"level":3}],"level":2},{"title":"缓存雪崩","id":"20220428141728-9ti4duq","type":"d","href":"/topic/redis/Redis分布式缓存/缓存雪崩","parentId":"","path":"/topic/redis/Redis分布式缓存/缓存雪崩","parentPath":"/topic/redis/Redis分布式缓存","sort":4,"children":[{"title":"解决方案","id":"20220428141728-zu9jxq3","type":"h","href":"/topic/redis/Redis分布式缓存/缓存雪崩#解决方案","parentId":"20220428141728-9ti4duq","path":"/topic/redis/Redis分布式缓存/缓存雪崩","parentPath":"/topic/redis/Redis分布式缓存","children":[{"title":"三步骤","id":"20220428141728-0vnf8gp","type":"h","href":"/topic/redis/Redis分布式缓存/缓存雪崩#三步骤","parentId":"20220428141728-zu9jxq3","path":"/topic/redis/Redis分布式缓存/缓存雪崩","parentPath":"/topic/redis/Redis分布式缓存","children":[],"level":4}],"level":3}],"level":2},{"title":"缓存预热","id":"20220428141728-fz10tn2","type":"d","href":"/topic/redis/Redis分布式缓存/缓存预热","parentId":"","path":"/topic/redis/Redis分布式缓存/缓存预热","parentPath":"/topic/redis/Redis分布式缓存","sort":7,"children":[],"level":2}],"level":1},{"title":"Redis的分布式锁","id":"20220428141727-sgydg0x","type":"d","href":"/topic/redis/Redis的分布式锁","parentId":"","path":"/topic/redis/Redis的分布式锁","parentPath":"/topic/redis","sort":4,"children":[{"title":"利用redis实现分布式锁","id":"20220428141727-e4nwnv1","type":"h","href":"/topic/redis/Redis的分布式锁#利用redis实现分布式锁","parentId":"20220428141727-sgydg0x","path":"/topic/redis/Redis的分布式锁","parentPath":"/topic/redis","children":[{"title":"三个重要因素","id":"20220428141727-zthzzjq","type":"h","href":"/topic/redis/Redis的分布式锁#三个重要因素","parentId":"20220428141727-e4nwnv1","path":"/topic/redis/Redis的分布式锁","parentPath":"/topic/redis","children":[],"level":3},{"title":"涉及命令","id":"20220428141727-hs1yg88","type":"h","href":"/topic/redis/Redis的分布式锁#涉及命令","parentId":"20220428141727-e4nwnv1","path":"/topic/redis/Redis的分布式锁","parentPath":"/topic/redis","children":[],"level":3}],"level":2},{"title":"实现思想","id":"20220428141727-5jo3h6s","type":"h","href":"/topic/redis/Redis的分布式锁#实现思想","parentId":"20220428141727-sgydg0x","path":"/topic/redis/Redis的分布式锁","parentPath":"/topic/redis","children":[{"title":"业务执行的时间大于redis锁过期的时间","id":"20220428141727-q83o36l","type":"h","href":"/topic/redis/Redis的分布式锁#业务执行的时间大于redis锁过期的时间","parentId":"20220428141727-5jo3h6s","path":"/topic/redis/Redis的分布式锁","parentPath":"/topic/redis","children":[],"level":3},{"title":"redis部署模式的影响","id":"20220428141727-9xczwbf","type":"h","href":"/topic/redis/Redis的分布式锁#redis部署模式的影响","parentId":"20220428141727-5jo3h6s","path":"/topic/redis/Redis的分布式锁","parentPath":"/topic/redis","children":[],"level":3},{"title":"原子性问题","id":"20220428141727-u4jomll","type":"h","href":"/topic/redis/Redis的分布式锁#原子性问题","parentId":"20220428141727-5jo3h6s","path":"/topic/redis/Redis的分布式锁","parentPath":"/topic/redis","children":[],"level":3}],"level":2},{"title":"看门狗模式","id":"20220428141728-gdeeql2","type":"d","href":"/topic/redis/Redis的分布式锁/看门狗模式","parentId":"","path":"/topic/redis/Redis的分布式锁/看门狗模式","parentPath":"/topic/redis/Redis的分布式锁","sort":1,"children":[],"level":2},{"title":"Redlock","id":"20220428141728-qbzn1tc","type":"d","href":"/topic/redis/Redis的分布式锁/Redlock","parentId":"","path":"/topic/redis/Redis的分布式锁/Redlock","parentPath":"/topic/redis/Redis的分布式锁","sort":2,"children":[{"title":"问题1","id":"20220428141728-lg0r797","type":"h","href":"/topic/redis/Redis的分布式锁/Redlock#问题1","parentId":"20220428141728-qbzn1tc","path":"/topic/redis/Redis的分布式锁/Redlock","parentPath":"/topic/redis/Redis的分布式锁","children":[],"level":3},{"title":"问题2","id":"20220428141728-nhr8fen","type":"h","href":"/topic/redis/Redis的分布式锁/Redlock#问题2","parentId":"20220428141728-qbzn1tc","path":"/topic/redis/Redis的分布式锁/Redlock","parentPath":"/topic/redis/Redis的分布式锁","children":[],"level":3},{"title":"问题3","id":"20220428141728-5jc3ave","type":"h","href":"/topic/redis/Redis的分布式锁/Redlock#问题3","parentId":"20220428141728-qbzn1tc","path":"/topic/redis/Redis的分布式锁/Redlock","parentPath":"/topic/redis/Redis的分布式锁","children":[],"level":3}],"level":2}],"level":1},{"title":"Redis集群","id":"20220428141727-awm7yu5","type":"d","href":"/topic/redis/Redis集群","parentId":"","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","sort":6,"children":[{"title":"三种集群方案","id":"20220428141727-id6w37y","type":"h","href":"/topic/redis/Redis集群#三种集群方案","parentId":"20220428141727-awm7yu5","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[],"level":2},{"title":"主从复制模式","id":"20220428141727-01yokji","type":"h","href":"/topic/redis/Redis集群#主从复制模式","parentId":"20220428141727-awm7yu5","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[{"title":"原理","id":"20220428141727-2xgqon2","type":"h","href":"/topic/redis/Redis集群#原理","parentId":"20220428141727-01yokji","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[],"level":3},{"title":"redis主从复制的坑","id":"20220428141727-h04f0fa","type":"h","href":"/topic/redis/Redis集群#redis主从复制的坑","parentId":"20220428141727-01yokji","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[],"level":3}],"level":2},{"title":"哨兵模式","id":"20220428141727-jxcatge","type":"h","href":"/topic/redis/Redis集群#哨兵模式","parentId":"20220428141727-awm7yu5","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[{"title":"哨兵模式的作用","id":"20220428141727-3jb6vil","type":"h","href":"/topic/redis/Redis集群#哨兵模式的作用","parentId":"20220428141727-jxcatge","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[],"level":3},{"title":"故障切换的过程","id":"20220428141727-uscl9hh","type":"h","href":"/topic/redis/Redis集群#故障切换的过程","parentId":"20220428141727-jxcatge","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[],"level":3},{"title":"哨兵模式的工作方式：","id":"20220428141727-fe5liq6","type":"h","href":"/topic/redis/Redis集群#哨兵模式的工作方式：","parentId":"20220428141727-jxcatge","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[],"level":3},{"title":"哨兵模式的优缺点","id":"20220428141727-fq18erp","type":"h","href":"/topic/redis/Redis集群#哨兵模式的优缺点","parentId":"20220428141727-jxcatge","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[],"level":3}],"level":2},{"title":"Cluster 集群模式（Redis官方）","id":"20220428141727-z0udk1o","type":"h","href":"/topic/redis/Redis集群#Cluster 集群模式（Redis官方）","parentId":"20220428141727-awm7yu5","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[{"title":"集群的数据分片","id":"20220428141727-zez6jhc","type":"h","href":"/topic/redis/Redis集群#集群的数据分片","parentId":"20220428141727-z0udk1o","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[],"level":3},{"title":"Redis 集群的主从复制模型","id":"20220428141727-guu9h2l","type":"h","href":"/topic/redis/Redis集群#Redis 集群的主从复制模型","parentId":"20220428141727-z0udk1o","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[],"level":3},{"title":"集群的特点","id":"20220428141727-a9a9ogo","type":"h","href":"/topic/redis/Redis集群#集群的特点","parentId":"20220428141727-z0udk1o","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[],"level":3}],"level":2},{"title":"Redis数据淘汰策略","id":"20220428141727-oaw8wmd","type":"d","href":"/topic/redis/Redis集群/Redis数据淘汰策略","parentId":"","path":"/topic/redis/Redis集群/Redis数据淘汰策略","parentPath":"/topic/redis/Redis集群","sort":5,"children":[{"title":"Redis的内存淘汰策略，有以下几种","id":"20220428141727-aort8cn","type":"h","href":"/topic/redis/Redis集群/Redis数据淘汰策略#Redis的内存淘汰策略，有以下几种","parentId":"20220428141727-oaw8wmd","path":"/topic/redis/Redis集群/Redis数据淘汰策略","parentPath":"/topic/redis/Redis集群","children":[],"level":3},{"title":"数据库中有 3000w 的数据，而 Redis 中只有 100w 数据，如何保证 Redis 中存放的都是热点数据","id":"20220428141727-egla613","type":"h","href":"/topic/redis/Redis集群/Redis数据淘汰策略#数据库中有 3000w 的数据，而 Redis 中只有 100w 数据，如何保证 Redis 中存放的都是热点数据","parentId":"20220428141727-oaw8wmd","path":"/topic/redis/Redis集群/Redis数据淘汰策略","parentPath":"/topic/redis/Redis集群","children":[],"level":3}],"level":2},{"title":"redis持久化","id":"20220428141728-ahu8hnn","type":"d","href":"/topic/redis/Redis集群/redis持久化","parentId":"","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","sort":8,"children":[{"title":"策略","id":"20220428141728-h8spnbe","type":"h","href":"/topic/redis/Redis集群/redis持久化#策略","parentId":"20220428141728-ahu8hnn","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[],"level":3},{"title":"AOF持久化","id":"20220428141728-8sb3e90","type":"h","href":"/topic/redis/Redis集群/redis持久化#AOF持久化","parentId":"20220428141728-ahu8hnn","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[{"title":"执行流程","id":"20220428141728-xdy9wq3","type":"h","href":"/topic/redis/Redis集群/redis持久化#执行流程","parentId":"20220428141728-8sb3e90","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[],"level":4},{"title":"怎么防止AOF文件越来越大？","id":"20220428141728-2fjjnsi","type":"h","href":"/topic/redis/Redis集群/redis持久化#怎么防止AOF文件越来越大？","parentId":"20220428141728-8sb3e90","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[{"title":"AOF文件追加阻塞？","id":"20220428141728-jggnla6","type":"h","href":"/topic/redis/Redis集群/redis持久化#AOF文件追加阻塞？","parentId":"20220428141728-2fjjnsi","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[],"level":5}],"level":4}],"level":3},{"title":"RDB持久化","id":"20220428141728-3uk1dzb","type":"h","href":"/topic/redis/Redis集群/redis持久化#RDB持久化","parentId":"20220428141728-ahu8hnn","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[{"title":"执行流程","id":"20220428141728-b6xujxs","type":"h","href":"/topic/redis/Redis集群/redis持久化#执行流程","parentId":"20220428141728-3uk1dzb","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[],"level":4}],"level":3},{"title":"混合持久化（Redis4.0+）","id":"20220428141728-z9bdsb4","type":"h","href":"/topic/redis/Redis集群/redis持久化#混合持久化（Redis4.0+）","parentId":"20220428141728-ahu8hnn","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[{"title":"执行流程","id":"20220428141728-flzi42f","type":"h","href":"/topic/redis/Redis集群/redis持久化#执行流程","parentId":"20220428141728-z9bdsb4","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[],"level":4}],"level":3},{"title":"Redis的数据恢复策略","id":"20220428141728-x9y47t6","type":"h","href":"/topic/redis/Redis集群/redis持久化#Redis的数据恢复策略","parentId":"20220428141728-ahu8hnn","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[],"level":3},{"title":"Redis持久化策略该如何进行选择","id":"20220428141728-54y3bdq","type":"h","href":"/topic/redis/Redis集群/redis持久化#Redis持久化策略该如何进行选择","parentId":"20220428141728-ahu8hnn","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[{"title":"1.不需要考虑数据丢失的情况","id":"20220428141728-ujbrmwt","type":"h","href":"/topic/redis/Redis集群/redis持久化#1.不需要考虑数据丢失的情况","parentId":"20220428141728-54y3bdq","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[],"level":4},{"title":"2.单机实例情况下","id":"20220428141728-zahznfw","type":"h","href":"/topic/redis/Redis集群/redis持久化#2.单机实例情况下","parentId":"20220428141728-54y3bdq","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[],"level":4},{"title":"3.在主从环境下","id":"20220428141728-jbd8vij","type":"h","href":"/topic/redis/Redis集群/redis持久化#3.在主从环境下","parentId":"20220428141728-54y3bdq","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[{"title":"那么在从服务器进行数据热备份的情况下，是否还需要持久化呢？","id":"20220428141728-sjs8krt","type":"h","href":"/topic/redis/Redis集群/redis持久化#那么在从服务器进行数据热备份的情况下，是否还需要持久化呢？","parentId":"20220428141728-jbd8vij","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[],"level":5},{"title":"4.异地灾备","id":"20220428141728-aryf17w","type":"h","href":"/topic/redis/Redis集群/redis持久化#4.异地灾备","parentId":"20220428141728-jbd8vij","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[],"level":5}],"level":4}],"level":3}],"level":2},{"title":"Redis数据删除策略","id":"20220428141727-pvzi1zo","type":"d","href":"/topic/redis/Redis集群/Redis数据删除策略","parentId":"","path":"/topic/redis/Redis集群/Redis数据删除策略","parentPath":"/topic/redis/Redis集群","sort":13,"children":[{"title":"惰性删除","id":"20220428141727-o0rija8","type":"h","href":"/topic/redis/Redis集群/Redis数据删除策略#惰性删除","parentId":"20220428141727-pvzi1zo","path":"/topic/redis/Redis集群/Redis数据删除策略","parentPath":"/topic/redis/Redis集群","children":[],"level":3},{"title":"定期删除","id":"20220428141727-wq9axfb","type":"h","href":"/topic/redis/Redis集群/Redis数据删除策略#定期删除","parentId":"20220428141727-pvzi1zo","path":"/topic/redis/Redis集群/Redis数据删除策略","parentPath":"/topic/redis/Redis集群","children":[],"level":3},{"title":"AOF、RDB 和复制功能对过期键的处理","id":"20220428141727-gr8a4lk","type":"h","href":"/topic/redis/Redis集群/Redis数据删除策略#AOF、RDB 和复制功能对过期键的处理","parentId":"20220428141727-pvzi1zo","path":"/topic/redis/Redis集群/Redis数据删除策略","parentPath":"/topic/redis/Redis集群","children":[{"title":"RDB","id":"20220428141727-xhxrdyf","type":"h","href":"/topic/redis/Redis集群/Redis数据删除策略#RDB","parentId":"20220428141727-gr8a4lk","path":"/topic/redis/Redis集群/Redis数据删除策略","parentPath":"/topic/redis/Redis集群","children":[],"level":4},{"title":"AOF","id":"20220428141727-z7l5azb","type":"h","href":"/topic/redis/Redis集群/Redis数据删除策略#AOF","parentId":"20220428141727-gr8a4lk","path":"/topic/redis/Redis集群/Redis数据删除策略","parentPath":"/topic/redis/Redis集群","children":[],"level":4},{"title":"复制","id":"20220428141727-vdap5h4","type":"h","href":"/topic/redis/Redis集群/Redis数据删除策略#复制","parentId":"20220428141727-gr8a4lk","path":"/topic/redis/Redis集群/Redis数据删除策略","parentPath":"/topic/redis/Redis集群","children":[],"level":4}],"level":3},{"title":"疑问点？","id":"20220428141727-5x39avu","type":"h","href":"/topic/redis/Redis集群/Redis数据删除策略#疑问点？","parentId":"20220428141727-pvzi1zo","path":"/topic/redis/Redis集群/Redis数据删除策略","parentPath":"/topic/redis/Redis集群","children":[{"title":"如果主从服务器链接断开怎么办？","id":"20220428141727-4505lb0","type":"h","href":"/topic/redis/Redis集群/Redis数据删除策略#如果主从服务器链接断开怎么办？","parentId":"20220428141727-5x39avu","path":"/topic/redis/Redis集群/Redis数据删除策略","parentPath":"/topic/redis/Redis集群","children":[],"level":4},{"title":"如果发生网络抖动，主服务器发送的 del 命令没有传递到从服务器怎么办？","id":"20220428141727-4x9rpfk","type":"h","href":"/topic/redis/Redis集群/Redis数据删除策略#如果发生网络抖动，主服务器发送的 del 命令没有传递到从服务器怎么办？","parentId":"20220428141727-5x39avu","path":"/topic/redis/Redis集群/Redis数据删除策略","parentPath":"/topic/redis/Redis集群","children":[],"level":4}],"level":3}],"level":2}],"level":1}],"level":0},"headings":[{"depth":1,"value":"完全基于内存","slug":"完全基于内存"},{"depth":1,"value":"数据结构简单","slug":"数据结构简单"},{"depth":1,"value":"工作线程采用单线程，避免了线程上下文切换所带来的损耗","slug":"工作线程采用单线程避免了线程上下文切换所带来的损耗"},{"depth":1,"value":"对于客户端的连接采用多路复用和非阻塞I/O","slug":"对于客户端的连接采用多路复用和非阻塞io"}]}},
    "staticQueryHashes": ["630634786","928362550"]}