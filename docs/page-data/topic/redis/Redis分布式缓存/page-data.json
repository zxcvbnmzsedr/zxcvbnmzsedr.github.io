{"componentChunkName":"component---src-templates-topic-post-template-js","path":"/topic/redis/Redis分布式缓存","result":{"data":{"siYuan":{"excerpt":"Redis分布式缓存 用redis作为最基本的功能，缓存mysql中的数据，加快响应速度 双写一致性 双写一致性，是redis做为缓存的时候一道非常经典的问题 因为无论先操作db还是cache，都会有各自的问题，根本原因是cache和db的...","raw":"# Redis分布式缓存\n\n用redis作为最基本的功能，缓存mysql中的数据，加快响应速度\n\n# 双写一致性\n\n双写一致性，是redis做为缓存的时候一道非常经典的问题\n\n因为无论先操作db还是cache，都会有各自的问题，根本原因是cache和db的更新不是一个原子操作，因此总会有不一致的问题。\n\n一致性可以分为三个等级:\n\n1. 强一致性\n\n   + 这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大\n2. 弱一致性\n\n   + 这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态\n3. 最终一致性\n\n   + 最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型\n\n# 缓存更新策略\n\n## 最常见的策略\n\n![img](https://www.shiyitopo.tech/uPic/db-and-cache-01-01.jpg)\n\n#### 优点剖析\n\n#### 1. “先淘汰缓存，再写数据库” 合理\n\n为什么说这也算优点呢？试想一下\n\n如果把写流程改一下：**先更新缓存，再更新DB**。 如果我们更新缓存成功，而更新数据库失败，就会导致缓存中的数据是错误的，而我们大部分的业务一般能忍受数据延迟，但是数据错误这是无法接受的，所以先淘汰缓存是比较合理的。 如果把写流程改一下：**不删缓存，先更新DB，再更新缓存**。 如果我们更新DB成功，而更新缓存失败，则会导致缓存中就会一直是旧的数据（也算是一种错误数据），所以先淘汰缓存是比较合理的。\n\n#### 2. 异步刷新，补缺补漏\n\n在很多业务场景中，缓存只是辅助，**所以在很多业务中，缓存的读写失败不会影响主流程**，啥意思呢？就是说很多情况下，即使操作缓存失败（比如步骤1.1中的’DEL缓存失败’），程序还是会继续往下走（继续步骤1.2 更新数据库)，所以这个时候异步刷新就能在一定程度上，对1.1的失败进行错误数据的修补\n\n#### 缺点剖析\n\n#### 1. 容灾不足\n\n> 在分布式领域，“Everything will fails”，任何可能出现问题的地方都会出现问题\n>\n\n我们来分析一下写流程，第一步，’DEL缓存失败’怎么办？流程是否还继续走？如果继续执行，那么从’更新完DB’到异步’刷新缓存’缓存期间，数据处于滞后状态。而且如果缓存处于不可写状态，那么异步刷新那步也可能会失败，那缓存就会长期处于旧数据，问题就比较严重了\n\n如果A线程更新数据库内容失败，导致B线程请求再次访问缓存时，发现redis里面没数据，缓存缺失，再去读取mysql时， 从数据库中读取到旧值\n\n#### 2. 并发问题\n\n**写写并发：**试想一下，同时有多个服务器的多个线程进行’步骤1.2更新DB’，更新DB完成之后，它们就要进行异步刷缓存，我们都知道多服务器的异步操作，是无法保证顺序的，所以后面的刷新操作存在相互覆盖的并发问题，**也就是说，存在先更新的DB操作，反而很晚才去刷新缓存**，那这个时候，数据也是错的\n\n**读写并发：**再试想一下，服务器A在进行’读操作’，，在A服务器刚完成2.2时，服务器B在进行’写操作’，假设B服务器1.3完成之后，服务器A的1.3才被执行，这个时候就相当于更新前的老数据写入缓存，最终数据还是错的\n\n#### 方案总结\n\n适合大部分的业务场景，很多人都在用，香还是很香的，实现起来也简单。\n**适合使用的场景：并发量、一致性要求都不是很高的情况**。\n我觉得这个方案有一个比较大的缺陷在于**刷新缓存有可能会失败，而失败之后缓存中数据就一直会处于错误状态，所以它并不能保证数据的最终一致性**\n\n为了保证“数据最终一致性”，我们引入binlog，通过解析binlog来刷新缓存，这样即使刷新失败，依然可以进行日志回放，再次刷新缓存\n\n![img](https://www.shiyitopo.tech/uPic/db-and-cache-02-01.jpg)\n\n### 写流程：\n\n第一步先删除缓存，删除之后再更新DB，我们监听从库(资源少的话主库也ok)的binlog，通过分析binlog我们解析出需要需要刷新的数据，然后读主库把最新的数据写入缓存。\n\n> 这里需要提一下：最后刷新前的读主库或者读从库，甚至不读库直接通过binlog解析出需要的数据都是ok的，这由业务决定，**比如刷新的数据只是表的一行，那直接通过binlog就完全能解析出来；然而如果需要刷新的数据来自多行，多张表，甚至多个库的话，那就需要读主库或是从库才行**\n>\n\n### 读流程：\n\n第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据刷回缓存\n\n## 方案分析\n\n### 优点剖析\n\n#### 1. 容灾\n\n写步骤1.4或1.5 如果失败，可以进行日志回放，再次重试。\n无论步骤1.1是否删除成功，后续的刷新操作是有保证的\n\n> 妈耶，怎么就一个优点，讲道理这个其实很常用的，那我们再来看看缺点\n>\n\n### 缺点剖析\n\n> 分析缺点之前，我们先来看一下知识点\n>\n> 1. 对于同一张表的同一条记录的更新，Databus会以串行形式的通知下游服务，也就是说，只有当我们正确返回后，它才会推送该记录的下一次更新。\n> 2. 对于同一张表的不同记录的更新， Databus会以事件时间为顺序的通知下游服务，但并不会等待我们返回后才推送下一条，也就是说它是非串行的。\n> 3. 对于不同表，根据其下游的消费速度，不同表之间没有明确的时间顺序。\n>\n\n#### 1. 只适合简单业务，复杂业务容易发生并发问题\n\n这里先来解释一下这里说的“简单业务”是啥意思？\n\n> 简单业务：每次需要刷新的数据，都来自**单表单行**。\n>\n\n为什么复杂业务就不行呢？我举个例子\n我们假设 **一个订单 = A表信息 + B表信息**\n\n![img](https://www.shiyitopo.tech/uPic/db-and-cache-02-02.jpg)\n\n由于A表先变化，经过1，2，3步后，线程1获取了A’B （A表是新数据，B表的老数据），当线程1还没来得及刷新缓存时，并发发生了：\n\n此时，B表发生了更新，经过4，5，6，7将最新的数据A’B’写入缓存，此时此刻缓存数据是符合要求的。\n\n但是，后来线程1进行了第8步，将A’B写入数据，使得缓存最终结果 与 DB 不一致。\n\n##### 缺点1的改进\n\n- **针对单库多表单次更新的改进：利用事务**\n\n![](https://www.shiyitopo.tech/uPic/db-and-cache-02-03.jpg)\n\n当AB表的更新发生在一个事务内时，不管线程1、线程2如何读取，他们都能获取两张表的最新数据，所以刷新缓存的数据都是符合要求的。\n\n> 但是这种方案具有局限性：那就是只对单次更新有效，或者说更新频率低的情况下才适应，比如我们并发的单独更新C表，并发问题依然会发生。\n>\n\n所以**这种方案只针对多表单次更新的情况**。\n\n- **针对多表多次更新的改进：增量更新**\n\n![img](https://www.shiyitopo.tech/uPic/db-and-cache-02-04.jpg)\n\n每张表的更新，在同步缓存时，只获取该表的字段覆盖缓存。\n\n这样，线程1，线程2总能获取对应表最新的字段，而且Databus对于同表同行会以串行的形式通知下游，所以能保证缓存的最终一致性。\n\n> 这里有一点需要提一下：更新“某张表多行记录“时，这个操作要在一个事务内，不然并发问题依然存在，正如前面分析的\n>\n\n#### 2. 依然是并发问题\n\n即使对于**缺点1**我们提出了改进方案，虽然它解决了部分问题，但在极端场景下依然存在并发问题。\n这个场景，就是**缓存中没有数据**的情况：\n\n- **读的时候，缓存中的数据已失效，此时又发生了更新**\n- **数据更新的时候，缓存中的数据已失效，此时又发生了更新**\n\n这个时候，我们在上面提到的“增量更新”就不起作用了，我们需要读取**所有的表**来拼凑出初始数据，那这个时候又涉及到**读所有表的操作**了，那我们在**缺点1**中提到的并发问题会再次发生\n\n## 方案总结\n\n**适合使用的场景：业务简单，读写QPS比较低的情况**。\n今天这个方案呢，优缺点都比较明显，binlog用来刷新缓存是一个很棒的选择，它天然的顺序性用来做同步操作很具有优势；其实**它的并发问题来自于Canal 或 Databus。拿Databus来说，由于不同行、表、库的binlog的消费并不是时间串行的**，那怎么解决这个问题呢\n\n> 强一致性，包含两种含义：\n>\n> - 缓存和DB数据一致\n> - 缓存中没有数据（或者说：不会去读缓存中的老版本数据）\n>\n\n首先我们来分析一下，既然已经实现了“**最终一致性**”，那它和“**强一致性**”的区别是什么呢？没错，就是“**时间差**”，所以：\n\n> “**最终一致性方案**” + “**时间差**” = “**强一致性方案**”\n>\n\n那我们的工作呢，就是加上时间差，实现方式：**我们加一个缓存，将近期被修改的数据进行标记锁定。读的时候，标记锁定的数据强行走DB，没锁定的数据，先走缓存**\n\n![img](https://www.shiyitopo.tech/uPic/db-and-cache-04-01.jpg)\n\n### 写流程：\n\n我们把修改的数据通过Cache_0标记“正在被修改”，如果标记成功，则继续往下走；**那如果标记失败，则要放弃这次修改。**\n\n> 何为标记锁定呢？比如你可以设定一个有效期为10S的key，Key存在即为锁定。一般来说10S对于后面的同步操作来说基本是够了~\n>\n\n**如果说，还想更严谨一点，怕DB主从延迟太久、MQ延迟太久，或Databus监听的从库挂机之类的情况，我们可以考虑增加一个监控定时任务**。\n比如我们增加一个时间间隔2S的worker的去对比以下两个数据：\n\n- **时间1： 最后修改数据库的时间**\n  **VS**\n- **时间2： 最后由更新引起的’MQ刷新缓存对应数据的实际更新数据库’的时间**\n\n> 数据1： 可由步骤1.1获得，并存储\n> 数据2： 需要由binlog中解析获得，需要透传到MQ，这样后面就能存储了\n> 这里提一下：如果多库的情况的话，存储这两个key需要与库一一对应\n>\n\n如果 时间1 VS 时间2 相差超过5S，那我们就自动把相应的缓存分片读降级。\n\n### 读流程：\n\n先读Cache_0，看看要读的数据是否被标记，如果被标记，则直接读主库；\n\n## 方案分析\n\n### 优点剖析\n\n#### 1. 容灾完善\n\n我们一步一步来分析：\n\n###### 写流程容灾分析\n\n- **写1.1 标记失败**：没关系，放弃整个更新操作\n- **写1.3 DEL缓存失败**：没关系，后面会覆盖\n- **写1.5 写MQ失败**：没关系，Databus或Canal都会重试\n- **消费MQ的：1.6 || 1.7 失败**：没关系，重新消费即可\n\n###### 读流程容灾分析\n\n- **读2.1 读Cache_0失败**：没关系，直接读主库\n- **读2.3 异步写MQ失败**：没关系，缓存为空，是OK的，下次还读库就好了\n\n#### 2. 无并发问题\n\n这个方案让“读库 + 刷缓存”的操作串行化，这就不存在老数据覆盖新数据的并发问题了\n\n### 缺点剖析\n\n#### 1. 增加Cache_0强依赖\n\n这个其实有点没办法，你要强一致性，必然要牺牲一些的。\n但是呢，你这个可以吧Cache_0设计成多机器多分片，这样的话，即使部分分片挂了，也只有小部分流量透过Cache直接打到DB上，这是完全是可接受的\n\n#### 2. 复杂度是比较高的\n\n涉及到Databus、MQ、定时任务等等组件，实现起来复杂度还是有的\n\n## 方案总结\n\nOK，到此呢，我们已经实现了**“数据库和缓存强一致性”**，这个系列就先这样啦，等我学到了更好的方案，再来分享~\n\n\nhttps://blog.kido.site/2018/11/24/db-and-cache-preface/\n","html":"<div data-node-id=\"20220428141727-ffjmgfw\" data-node-index=\"0\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">用redis作为最基本的功能，缓存mysql中的数据，加快响应速度</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h1\" data-node-id=\"20220428141727-zahxna7\" data-node-index=\"1\" data-type=\"NodeHeading\" class=\"h1\" updated=\"20220428144243\"><div contenteditable=\"true\" spellcheck=\"false\">双写一致性</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-vyhttn7\" data-node-index=\"2\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">双写一致性，是redis做为缓存的时候一道非常经典的问题</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-t18hr2w\" data-node-index=\"3\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">因为无论先操作db还是cache，都会有各自的问题，根本原因是cache和db的更新不是一个原子操作，因此总会有不一致的问题。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-mite3jw\" data-node-index=\"4\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">一致性可以分为三个等级:</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"o\" data-node-id=\"20220428141727-s3tybvl\" data-node-index=\"5\" data-type=\"NodeList\" class=\"list\" updated=\"20220428141727\"><div data-marker=\"1.\" data-subtype=\"o\" data-node-id=\"20220428141727-z7j3xlz\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action protyle-action--order\" contenteditable=\"false\" draggable=\"true\">1.</div><div data-node-id=\"20220428141727-4s787yv\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">强一致性</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"u\" data-node-id=\"20220428141727-3td8361\" data-type=\"NodeList\" class=\"list\" updated=\"20220428141727\"><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141727-jr4oplx\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141727-vdwxxy5\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"2.\" data-subtype=\"o\" data-node-id=\"20220428141727-b5lbf20\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action protyle-action--order\" contenteditable=\"false\" draggable=\"true\">2.</div><div data-node-id=\"20220428141727-5mlxwi4\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">弱一致性</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"u\" data-node-id=\"20220428141727-3kk2ft1\" data-type=\"NodeList\" class=\"list\" updated=\"20220428141727\"><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141727-n4xrpv7\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141727-cwajrqh\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"3.\" data-subtype=\"o\" data-node-id=\"20220428141727-ty7e7cy\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action protyle-action--order\" contenteditable=\"false\" draggable=\"true\">3.</div><div data-node-id=\"20220428141727-fnxulc0\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">最终一致性</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"u\" data-node-id=\"20220428141727-n00tz00\" data-type=\"NodeList\" class=\"list\" updated=\"20220428141727\"><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141727-su82awt\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141727-28kolvo\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h1\" data-node-id=\"20220428141727-iqgn80l\" data-node-index=\"6\" data-type=\"NodeHeading\" class=\"h1\" updated=\"20220428144246\"><div contenteditable=\"true\" spellcheck=\"false\">缓存更新策略</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h2\" data-node-id=\"20220428141727-45wxv7a\" data-node-index=\"7\" data-type=\"NodeHeading\" class=\"h2\" updated=\"20220428144319\"><div contenteditable=\"true\" spellcheck=\"false\">最常见的策略</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-hwrt7fd\" data-node-index=\"8\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><span contenteditable=\"false\" data-type=\"img\" class=\"img\"><span> </span><span><span class=\"protyle-action protyle-icons\"><span class=\"protyle-icon protyle-icon--only\"><svg class=\"svg\"><use xlink:href=\"#iconMore\"></use></svg></span></span><img src=\"https://www.shiyitopo.tech/uPic/db-and-cache-01-01.jpg\" data-src=\"https://www.shiyitopo.tech/uPic/db-and-cache-01-01.jpg\" alt=\"img\" /><span class=\"protyle-action__drag\"></span><span class=\"protyle-action__title\"></span></span><span> </span></span></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h4\" data-node-id=\"20220428141727-tfanvhu\" data-node-index=\"9\" data-type=\"NodeHeading\" class=\"h4\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">优点剖析</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h4\" data-node-id=\"20220428141727-vzyp7bi\" data-node-index=\"10\" data-type=\"NodeHeading\" class=\"h4\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">1. “先淘汰缓存，再写数据库” 合理</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-ggdx95y\" data-node-index=\"11\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">为什么说这也算优点呢？试想一下</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-a25iejg\" data-node-index=\"12\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">如果把写流程改一下：<strong id=\"\">先更新缓存，再更新DB</strong>。 如果我们更新缓存成功，而更新数据库失败，就会导致缓存中的数据是错误的，而我们大部分的业务一般能忍受数据延迟，但是数据错误这是无法接受的，所以先淘汰缓存是比较合理的。 如果把写流程改一下：<strong id=\"\">不删缓存，先更新DB，再更新缓存</strong>。 如果我们更新DB成功，而更新缓存失败，则会导致缓存中就会一直是旧的数据（也算是一种错误数据），所以先淘汰缓存是比较合理的。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h4\" data-node-id=\"20220428141727-kbueoxr\" data-node-index=\"13\" data-type=\"NodeHeading\" class=\"h4\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">2. 异步刷新，补缺补漏</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-zyif39n\" data-node-index=\"14\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">在很多业务场景中，缓存只是辅助，<strong id=\"\">所以在很多业务中，缓存的读写失败不会影响主流程</strong>，啥意思呢？就是说很多情况下，即使操作缓存失败（比如步骤1.1中的’DEL缓存失败’），程序还是会继续往下走（继续步骤1.2 更新数据库)，所以这个时候异步刷新就能在一定程度上，对1.1的失败进行错误数据的修补</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h4\" data-node-id=\"20220428141727-sd1lbh3\" data-node-index=\"15\" data-type=\"NodeHeading\" class=\"h4\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">缺点剖析</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h4\" data-node-id=\"20220428141727-aff14q4\" data-node-index=\"16\" data-type=\"NodeHeading\" class=\"h4\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">1. 容灾不足</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-jyj0kpj\" data-node-index=\"17\" data-type=\"NodeBlockquote\" class=\"bq\" updated=\"20220428141727\"><div data-node-id=\"20220428141727-13yuhb5\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">在分布式领域，“Everything will fails”，任何可能出现问题的地方都会出现问题</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-jml9zyq\" data-node-index=\"18\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">我们来分析一下写流程，第一步，’DEL缓存失败’怎么办？流程是否还继续走？如果继续执行，那么从’更新完DB’到异步’刷新缓存’缓存期间，数据处于滞后状态。而且如果缓存处于不可写状态，那么异步刷新那步也可能会失败，那缓存就会长期处于旧数据，问题就比较严重了</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-n4x6vy3\" data-node-index=\"19\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">如果A线程更新数据库内容失败，导致B线程请求再次访问缓存时，发现redis里面没数据，缓存缺失，再去读取mysql时， 从数据库中读取到旧值</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h4\" data-node-id=\"20220428141727-7kjhtfn\" data-node-index=\"20\" data-type=\"NodeHeading\" class=\"h4\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">2. 并发问题</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-ye3nqbh\" data-node-index=\"21\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><strong id=\"\">写写并发：</strong>试想一下，同时有多个服务器的多个线程进行’步骤1.2更新DB’，更新DB完成之后，它们就要进行异步刷缓存，我们都知道多服务器的异步操作，是无法保证顺序的，所以后面的刷新操作存在相互覆盖的并发问题，<strong id=\"\">也就是说，存在先更新的DB操作，反而很晚才去刷新缓存</strong>，那这个时候，数据也是错的</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-h8kcq8j\" data-node-index=\"22\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><strong id=\"\">读写并发：</strong>再试想一下，服务器A在进行’读操作’，，在A服务器刚完成2.2时，服务器B在进行’写操作’，假设B服务器1.3完成之后，服务器A的1.3才被执行，这个时候就相当于更新前的老数据写入缓存，最终数据还是错的</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h4\" data-node-id=\"20220428141727-5w2loli\" data-node-index=\"23\" data-type=\"NodeHeading\" class=\"h4\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">方案总结</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-dp235b4\" data-node-index=\"24\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">适合大部分的业务场景，很多人都在用，香还是很香的，实现起来也简单。\n<strong id=\"\">适合使用的场景：并发量、一致性要求都不是很高的情况</strong>。\n我觉得这个方案有一个比较大的缺陷在于<strong id=\"\">刷新缓存有可能会失败，而失败之后缓存中数据就一直会处于错误状态，所以它并不能保证数据的最终一致性</strong></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-c2g6xfh\" data-node-index=\"25\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">为了保证“数据最终一致性”，我们引入binlog，通过解析binlog来刷新缓存，这样即使刷新失败，依然可以进行日志回放，再次刷新缓存</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-dddy9f8\" data-node-index=\"26\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><span contenteditable=\"false\" data-type=\"img\" class=\"img\"><span> </span><span><span class=\"protyle-action protyle-icons\"><span class=\"protyle-icon protyle-icon--only\"><svg class=\"svg\"><use xlink:href=\"#iconMore\"></use></svg></span></span><img src=\"https://www.shiyitopo.tech/uPic/db-and-cache-02-01.jpg\" data-src=\"https://www.shiyitopo.tech/uPic/db-and-cache-02-01.jpg\" alt=\"img\" /><span class=\"protyle-action__drag\"></span><span class=\"protyle-action__title\"></span></span><span> </span></span></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h3\" data-node-id=\"20220428141727-s959uv0\" data-node-index=\"27\" data-type=\"NodeHeading\" class=\"h3\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">写流程：</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-5pn4yzv\" data-node-index=\"28\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">第一步先删除缓存，删除之后再更新DB，我们监听从库(资源少的话主库也ok)的binlog，通过分析binlog我们解析出需要需要刷新的数据，然后读主库把最新的数据写入缓存。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-r5pw0a1\" data-node-index=\"29\" data-type=\"NodeBlockquote\" class=\"bq\" updated=\"20220428141727\"><div data-node-id=\"20220428141727-pke76v3\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">这里需要提一下：最后刷新前的读主库或者读从库，甚至不读库直接通过binlog解析出需要的数据都是ok的，这由业务决定，<strong id=\"\">比如刷新的数据只是表的一行，那直接通过binlog就完全能解析出来；然而如果需要刷新的数据来自多行，多张表，甚至多个库的话，那就需要读主库或是从库才行</strong></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h3\" data-node-id=\"20220428141727-sceljri\" data-node-index=\"30\" data-type=\"NodeHeading\" class=\"h3\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">读流程：</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-qmirae2\" data-node-index=\"31\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据刷回缓存</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h2\" data-node-id=\"20220428141727-7flpl0m\" data-node-index=\"32\" data-type=\"NodeHeading\" class=\"h2\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">方案分析</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h3\" data-node-id=\"20220428141727-1cqjx66\" data-node-index=\"33\" data-type=\"NodeHeading\" class=\"h3\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">优点剖析</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h4\" data-node-id=\"20220428141727-w9bvsqf\" data-node-index=\"34\" data-type=\"NodeHeading\" class=\"h4\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">1. 容灾</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-s53y7aw\" data-node-index=\"35\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">写步骤1.4或1.5 如果失败，可以进行日志回放，再次重试。\n无论步骤1.1是否删除成功，后续的刷新操作是有保证的</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-qpm8e2k\" data-node-index=\"36\" data-type=\"NodeBlockquote\" class=\"bq\" updated=\"20220428141727\"><div data-node-id=\"20220428141727-oaa77fn\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">妈耶，怎么就一个优点，讲道理这个其实很常用的，那我们再来看看缺点</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h3\" data-node-id=\"20220428141727-n1twxfd\" data-node-index=\"37\" data-type=\"NodeHeading\" class=\"h3\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">缺点剖析</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-agitbvp\" data-node-index=\"38\" data-type=\"NodeBlockquote\" class=\"bq\" updated=\"20220428141727\"><div data-node-id=\"20220428141727-t82idj0\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">分析缺点之前，我们先来看一下知识点</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"o\" data-node-id=\"20220428141727-jbxze4m\" data-type=\"NodeList\" class=\"list\" updated=\"20220428141727\"><div data-marker=\"1.\" data-subtype=\"o\" data-node-id=\"20220428141727-dm6vbqo\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action protyle-action--order\" contenteditable=\"false\" draggable=\"true\">1.</div><div data-node-id=\"20220428141727-6yzh3id\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">对于同一张表的同一条记录的更新，Databus会以串行形式的通知下游服务，也就是说，只有当我们正确返回后，它才会推送该记录的下一次更新。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"2.\" data-subtype=\"o\" data-node-id=\"20220428141727-uyegx6c\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action protyle-action--order\" contenteditable=\"false\" draggable=\"true\">2.</div><div data-node-id=\"20220428141727-1aa0u7c\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">对于同一张表的不同记录的更新， Databus会以事件时间为顺序的通知下游服务，但并不会等待我们返回后才推送下一条，也就是说它是非串行的。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"3.\" data-subtype=\"o\" data-node-id=\"20220428141727-jzz9x3n\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action protyle-action--order\" contenteditable=\"false\" draggable=\"true\">3.</div><div data-node-id=\"20220428141727-8pxcenk\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">对于不同表，根据其下游的消费速度，不同表之间没有明确的时间顺序。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h4\" data-node-id=\"20220428141727-t5kobxh\" data-node-index=\"39\" data-type=\"NodeHeading\" class=\"h4\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">1. 只适合简单业务，复杂业务容易发生并发问题</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-skvmoyk\" data-node-index=\"40\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">这里先来解释一下这里说的“简单业务”是啥意思？</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-7c3ze16\" data-node-index=\"41\" data-type=\"NodeBlockquote\" class=\"bq\" updated=\"20220428141727\"><div data-node-id=\"20220428141727-ernq9yl\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">简单业务：每次需要刷新的数据，都来自<strong id=\"\">单表单行</strong>。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-hrh7ase\" data-node-index=\"42\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">为什么复杂业务就不行呢？我举个例子\n我们假设 <strong id=\"\">一个订单 = A表信息 + B表信息</strong></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-uq96rbm\" data-node-index=\"43\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><span contenteditable=\"false\" data-type=\"img\" class=\"img\"><span> </span><span><span class=\"protyle-action protyle-icons\"><span class=\"protyle-icon protyle-icon--only\"><svg class=\"svg\"><use xlink:href=\"#iconMore\"></use></svg></span></span><img src=\"https://www.shiyitopo.tech/uPic/db-and-cache-02-02.jpg\" data-src=\"https://www.shiyitopo.tech/uPic/db-and-cache-02-02.jpg\" alt=\"img\" /><span class=\"protyle-action__drag\"></span><span class=\"protyle-action__title\"></span></span><span> </span></span></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-mgygg88\" data-node-index=\"44\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">由于A表先变化，经过1，2，3步后，线程1获取了A’B （A表是新数据，B表的老数据），当线程1还没来得及刷新缓存时，并发发生了：</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-7miob61\" data-node-index=\"45\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">此时，B表发生了更新，经过4，5，6，7将最新的数据A’B’写入缓存，此时此刻缓存数据是符合要求的。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-z83dtrz\" data-node-index=\"46\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">但是，后来线程1进行了第8步，将A’B写入数据，使得缓存最终结果 与 DB 不一致。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h5\" data-node-id=\"20220428141727-bz5ta88\" data-node-index=\"47\" data-type=\"NodeHeading\" class=\"h5\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">缺点1的改进</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"u\" data-node-id=\"20220428141727-z8wclfy\" data-node-index=\"48\" data-type=\"NodeList\" class=\"list\" updated=\"20220428141727\"><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141727-y9s6afx\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141727-w73ptzf\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><strong id=\"\">针对单库多表单次更新的改进：利用事务</strong></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-rr0jdns\" data-node-index=\"49\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><span contenteditable=\"false\" data-type=\"img\" class=\"img\"><span> </span><span><span class=\"protyle-action protyle-icons\"><span class=\"protyle-icon protyle-icon--only\"><svg class=\"svg\"><use xlink:href=\"#iconMore\"></use></svg></span></span><img src=\"https://www.shiyitopo.tech/uPic/db-and-cache-02-03.jpg\" data-src=\"https://www.shiyitopo.tech/uPic/db-and-cache-02-03.jpg\" /><span class=\"protyle-action__drag\"></span><span class=\"protyle-action__title\"></span></span><span> </span></span></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-cj7q7kn\" data-node-index=\"50\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">当AB表的更新发生在一个事务内时，不管线程1、线程2如何读取，他们都能获取两张表的最新数据，所以刷新缓存的数据都是符合要求的。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-hq39euz\" data-node-index=\"51\" data-type=\"NodeBlockquote\" class=\"bq\" updated=\"20220428141727\"><div data-node-id=\"20220428141727-z8bb7co\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">但是这种方案具有局限性：那就是只对单次更新有效，或者说更新频率低的情况下才适应，比如我们并发的单独更新C表，并发问题依然会发生。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-ucqxm2f\" data-node-index=\"52\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">所以<strong id=\"\">这种方案只针对多表单次更新的情况</strong>。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"u\" data-node-id=\"20220428141727-3s5u3c0\" data-node-index=\"53\" data-type=\"NodeList\" class=\"list\" updated=\"20220428141727\"><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141727-ssct1tr\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141727-nk63l1c\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><strong id=\"\">针对多表多次更新的改进：增量更新</strong></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-qa2lrmj\" data-node-index=\"54\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><span contenteditable=\"false\" data-type=\"img\" class=\"img\"><span> </span><span><span class=\"protyle-action protyle-icons\"><span class=\"protyle-icon protyle-icon--only\"><svg class=\"svg\"><use xlink:href=\"#iconMore\"></use></svg></span></span><img src=\"https://www.shiyitopo.tech/uPic/db-and-cache-02-04.jpg\" data-src=\"https://www.shiyitopo.tech/uPic/db-and-cache-02-04.jpg\" alt=\"img\" /><span class=\"protyle-action__drag\"></span><span class=\"protyle-action__title\"></span></span><span> </span></span></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-byxuqmo\" data-node-index=\"55\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">每张表的更新，在同步缓存时，只获取该表的字段覆盖缓存。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-qsg5cem\" data-node-index=\"56\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">这样，线程1，线程2总能获取对应表最新的字段，而且Databus对于同表同行会以串行的形式通知下游，所以能保证缓存的最终一致性。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-5e1mkkf\" data-node-index=\"57\" data-type=\"NodeBlockquote\" class=\"bq\" updated=\"20220428141727\"><div data-node-id=\"20220428141727-2myu88k\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">这里有一点需要提一下：更新“某张表多行记录“时，这个操作要在一个事务内，不然并发问题依然存在，正如前面分析的</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h4\" data-node-id=\"20220428141727-gysgmg1\" data-node-index=\"58\" data-type=\"NodeHeading\" class=\"h4\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">2. 依然是并发问题</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-d9t15hr\" data-node-index=\"59\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">即使对于<strong id=\"\">缺点1</strong>我们提出了改进方案，虽然它解决了部分问题，但在极端场景下依然存在并发问题。\n这个场景，就是<strong id=\"\">缓存中没有数据</strong>的情况：</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"u\" data-node-id=\"20220428141727-b7w3d1u\" data-node-index=\"60\" data-type=\"NodeList\" class=\"list\" updated=\"20220428141727\"><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141727-yzy9hm7\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141727-fgqxk4o\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><strong id=\"\">读的时候，缓存中的数据已失效，此时又发生了更新</strong></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141727-brkxwl8\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141727-rskw8an\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><strong id=\"\">数据更新的时候，缓存中的数据已失效，此时又发生了更新</strong></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-f3tthwi\" data-node-index=\"61\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">这个时候，我们在上面提到的“增量更新”就不起作用了，我们需要读取<strong id=\"\">所有的表</strong>来拼凑出初始数据，那这个时候又涉及到<strong id=\"\">读所有表的操作</strong>了，那我们在<strong id=\"\">缺点1</strong>中提到的并发问题会再次发生</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h2\" data-node-id=\"20220428141727-01sdgjy\" data-node-index=\"62\" data-type=\"NodeHeading\" class=\"h2\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">方案总结</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-g66i64o\" data-node-index=\"63\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><strong id=\"\">适合使用的场景：业务简单，读写QPS比较低的情况</strong>。\n今天这个方案呢，优缺点都比较明显，binlog用来刷新缓存是一个很棒的选择，它天然的顺序性用来做同步操作很具有优势；其实<strong id=\"\">它的并发问题来自于Canal 或 Databus。拿Databus来说，由于不同行、表、库的binlog的消费并不是时间串行的</strong>，那怎么解决这个问题呢</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-ap6dvg2\" data-node-index=\"64\" data-type=\"NodeBlockquote\" class=\"bq\" updated=\"20220428141727\"><div data-node-id=\"20220428141727-xfhn8eh\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">强一致性，包含两种含义：</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"u\" data-node-id=\"20220428141727-swkr0wp\" data-type=\"NodeList\" class=\"list\" updated=\"20220428141727\"><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141727-apkrzqy\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141727-jf791ng\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">缓存和DB数据一致</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141727-fo7qzhb\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141727-qnh3vtb\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">缓存中没有数据（或者说：不会去读缓存中的老版本数据）</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-yoo5vhv\" data-node-index=\"65\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">首先我们来分析一下，既然已经实现了“<strong id=\"\">最终一致性</strong>”，那它和“<strong id=\"\">强一致性</strong>”的区别是什么呢？没错，就是“<strong id=\"\">时间差</strong>”，所以：</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-soqomp4\" data-node-index=\"66\" data-type=\"NodeBlockquote\" class=\"bq\" updated=\"20220428141727\"><div data-node-id=\"20220428141727-w87d7su\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">“<strong id=\"\">最终一致性方案</strong>” + “<strong id=\"\">时间差</strong>” = “<strong id=\"\">强一致性方案</strong>”</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-knyajsu\" data-node-index=\"67\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">那我们的工作呢，就是加上时间差，实现方式：<strong id=\"\">我们加一个缓存，将近期被修改的数据进行标记锁定。读的时候，标记锁定的数据强行走DB，没锁定的数据，先走缓存</strong></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-i59zlkt\" data-node-index=\"68\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><span contenteditable=\"false\" data-type=\"img\" class=\"img\"><span> </span><span><span class=\"protyle-action protyle-icons\"><span class=\"protyle-icon protyle-icon--only\"><svg class=\"svg\"><use xlink:href=\"#iconMore\"></use></svg></span></span><img src=\"https://www.shiyitopo.tech/uPic/db-and-cache-04-01.jpg\" data-src=\"https://www.shiyitopo.tech/uPic/db-and-cache-04-01.jpg\" alt=\"img\" /><span class=\"protyle-action__drag\"></span><span class=\"protyle-action__title\"></span></span><span> </span></span></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h3\" data-node-id=\"20220428141727-eglmgkf\" data-node-index=\"69\" data-type=\"NodeHeading\" class=\"h3\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">写流程：</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-5bsp0l4\" data-node-index=\"70\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">我们把修改的数据通过Cache_0标记“正在被修改”，如果标记成功，则继续往下走；<strong id=\"\">那如果标记失败，则要放弃这次修改。</strong></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-0qexy3k\" data-node-index=\"71\" data-type=\"NodeBlockquote\" class=\"bq\" updated=\"20220428141727\"><div data-node-id=\"20220428141727-xupiaw5\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">何为标记锁定呢？比如你可以设定一个有效期为10S的key，Key存在即为锁定。一般来说10S对于后面的同步操作来说基本是够了~</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-uzgemhd\" data-node-index=\"72\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><strong id=\"\">如果说，还想更严谨一点，怕DB主从延迟太久、MQ延迟太久，或Databus监听的从库挂机之类的情况，我们可以考虑增加一个监控定时任务</strong>。\n比如我们增加一个时间间隔2S的worker的去对比以下两个数据：</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"u\" data-node-id=\"20220428141727-mc5q9f2\" data-node-index=\"73\" data-type=\"NodeList\" class=\"list\" updated=\"20220428141727\"><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141727-h5ci2fq\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141727-sz2edst\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><strong id=\"\">时间1： 最后修改数据库的时间</strong>\n<strong id=\"\">VS</strong></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141727-0xec2bo\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141727-f2xk6h3\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><strong id=\"\">时间2： 最后由更新引起的’MQ刷新缓存对应数据的实际更新数据库’的时间</strong></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-k2g7h6l\" data-node-index=\"74\" data-type=\"NodeBlockquote\" class=\"bq\" updated=\"20220428141727\"><div data-node-id=\"20220428141727-be0e2o1\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">数据1： 可由步骤1.1获得，并存储\n数据2： 需要由binlog中解析获得，需要透传到MQ，这样后面就能存储了\n这里提一下：如果多库的情况的话，存储这两个key需要与库一一对应</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-77s0tap\" data-node-index=\"75\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">如果 时间1 VS 时间2 相差超过5S，那我们就自动把相应的缓存分片读降级。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h3\" data-node-id=\"20220428141727-1vywbk4\" data-node-index=\"76\" data-type=\"NodeHeading\" class=\"h3\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">读流程：</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-7tkrlas\" data-node-index=\"77\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">先读Cache_0，看看要读的数据是否被标记，如果被标记，则直接读主库；</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h2\" data-node-id=\"20220428141727-137lw2k\" data-node-index=\"78\" data-type=\"NodeHeading\" class=\"h2\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">方案分析</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h3\" data-node-id=\"20220428141727-p0zad1o\" data-node-index=\"79\" data-type=\"NodeHeading\" class=\"h3\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">优点剖析</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h4\" data-node-id=\"20220428141727-cawius6\" data-node-index=\"80\" data-type=\"NodeHeading\" class=\"h4\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">1. 容灾完善</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-eaqn2cv\" data-node-index=\"81\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">我们一步一步来分析：</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h6\" data-node-id=\"20220428141727-2d2z7fz\" data-node-index=\"82\" data-type=\"NodeHeading\" class=\"h6\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">写流程容灾分析</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"u\" data-node-id=\"20220428141727-toh9lbw\" data-node-index=\"83\" data-type=\"NodeList\" class=\"list\" updated=\"20220428141727\"><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141727-9082mju\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141727-v118xpj\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><strong id=\"\">写1.1 标记失败</strong>：没关系，放弃整个更新操作</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141727-j77cdww\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141727-wgvcgwy\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><strong id=\"\">写1.3 DEL缓存失败</strong>：没关系，后面会覆盖</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141727-nayf84x\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141727-708ucr3\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><strong id=\"\">写1.5 写MQ失败</strong>：没关系，Databus或Canal都会重试</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141727-idxw5jp\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141727-m18sd0m\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><strong id=\"\">消费MQ的：1.6 || 1.7 失败</strong>：没关系，重新消费即可</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h6\" data-node-id=\"20220428141727-4hr5okn\" data-node-index=\"84\" data-type=\"NodeHeading\" class=\"h6\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">读流程容灾分析</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"u\" data-node-id=\"20220428141727-msdi8n8\" data-node-index=\"85\" data-type=\"NodeList\" class=\"list\" updated=\"20220428141727\"><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141727-czd248l\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141727-vx0hn9n\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><strong id=\"\">读2.1 读Cache_0失败</strong>：没关系，直接读主库</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141727-a2oxanw\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141727\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141727-qiuforx\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\"><strong id=\"\">读2.3 异步写MQ失败</strong>：没关系，缓存为空，是OK的，下次还读库就好了</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h4\" data-node-id=\"20220428141727-uvwj2ga\" data-node-index=\"86\" data-type=\"NodeHeading\" class=\"h4\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">2. 无并发问题</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-w9wzd0z\" data-node-index=\"87\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">这个方案让“读库 + 刷缓存”的操作串行化，这就不存在老数据覆盖新数据的并发问题了</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h3\" data-node-id=\"20220428141727-fmiz5zl\" data-node-index=\"88\" data-type=\"NodeHeading\" class=\"h3\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">缺点剖析</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h4\" data-node-id=\"20220428141727-hr6lxu9\" data-node-index=\"89\" data-type=\"NodeHeading\" class=\"h4\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">1. 增加Cache_0强依赖</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-ge0vs9u\" data-node-index=\"90\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">这个其实有点没办法，你要强一致性，必然要牺牲一些的。\n但是呢，你这个可以吧Cache_0设计成多机器多分片，这样的话，即使部分分片挂了，也只有小部分流量透过Cache直接打到DB上，这是完全是可接受的</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h4\" data-node-id=\"20220428141727-vbiftey\" data-node-index=\"91\" data-type=\"NodeHeading\" class=\"h4\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">2. 复杂度是比较高的</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-6c4frvr\" data-node-index=\"92\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">涉及到Databus、MQ、定时任务等等组件，实现起来复杂度还是有的</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h2\" data-node-id=\"20220428141727-0an20z6\" data-node-index=\"93\" data-type=\"NodeHeading\" class=\"h2\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">方案总结</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-ls3po5j\" data-node-index=\"94\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">OK，到此呢，我们已经实现了<strong>“数据库和缓存强一致性”</strong>，这个系列就先这样啦，等我学到了更好的方案，再来分享~</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428144343-nqlgj9c\" data-node-index=\"95\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428144343\"><div contenteditable=\"true\" spellcheck=\"false\"></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141727-l0vfx6m\" data-node-index=\"96\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141727\"><div contenteditable=\"true\" spellcheck=\"false\">https://blog.kido.site/2018/11/24/db-and-cache-preface/</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div>","field":{"slug":"/topic/redis/Redis分布式缓存","topic":"redis"},"frontmatter":{"title":"Redis分布式缓存","tags":["redis"],"date":"2022-04-28","description":"Redis分布式缓存 用redis作为最基本的功能，缓存mysql中的数据，加快响应速度 双写一致性 双写一致性，是redis做为缓存的时候一道非常经典的问题 因为无论先操作db还是cache，都会有各自的问题，根本原因是cache和db的..."}},"topic":{"title":"redis","tree":"{\"title\":\"redis\",\"id\":\"20220428141727-a3p03i0\",\"parentId\":\"\",\"href\":\"/topic/redis\",\"path\":\"/topic/redis\",\"children\":[{\"title\":\"Redis为什么这么快\",\"id\":\"20220428141727-jbyo2wp\",\"type\":\"d\",\"href\":\"/topic/redis/Redis为什么这么快\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis为什么这么快\",\"parentPath\":\"/topic/redis\",\"sort\":1,\"children\":[{\"title\":\"完全基于内存\",\"id\":\"20220428141727-m8thckv\",\"type\":\"h\",\"href\":\"/topic/redis/Redis为什么这么快#完全基于内存\",\"parentId\":\"20220428141727-jbyo2wp\",\"path\":\"/topic/redis/Redis为什么这么快\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":2},{\"title\":\"数据结构简单\",\"id\":\"20220428141727-0532nq9\",\"type\":\"h\",\"href\":\"/topic/redis/Redis为什么这么快#数据结构简单\",\"parentId\":\"20220428141727-jbyo2wp\",\"path\":\"/topic/redis/Redis为什么这么快\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":2},{\"title\":\"工作线程采用单线程，避免了线程上下文切换所带来的损耗\",\"id\":\"20220428141727-kw7bg9v\",\"type\":\"h\",\"href\":\"/topic/redis/Redis为什么这么快#工作线程采用单线程，避免了线程上下文切换所带来的损耗\",\"parentId\":\"20220428141727-jbyo2wp\",\"path\":\"/topic/redis/Redis为什么这么快\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":2},{\"title\":\"对于客户端的连接采用多路复用和非阻塞I/O\",\"id\":\"20220428141727-m7ruuk1\",\"type\":\"h\",\"href\":\"/topic/redis/Redis为什么这么快#对于客户端的连接采用多路复用和非阻塞I/O\",\"parentId\":\"20220428141727-jbyo2wp\",\"path\":\"/topic/redis/Redis为什么这么快\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":2},{\"title\":\"redis单线程的问题\",\"id\":\"20220428141728-w6wf4kq\",\"type\":\"d\",\"href\":\"/topic/redis/Redis为什么这么快/redis单线程的问题\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis为什么这么快/redis单线程的问题\",\"parentPath\":\"/topic/redis/Redis为什么这么快\",\"sort\":11,\"children\":[],\"level\":2}],\"level\":1},{\"title\":\"Redis基本数据结构\",\"id\":\"20220428141727-imsmasu\",\"type\":\"d\",\"href\":\"/topic/redis/Redis基本数据结构\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"sort\":2,\"children\":[{\"title\":\"常用的\",\"id\":\"20220428141727-1gclyg6\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#常用的\",\"parentId\":\"20220428141727-imsmasu\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"string\",\"id\":\"20220428141727-u2m7nzt\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#string\",\"parentId\":\"20220428141727-1gclyg6\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"hash\",\"id\":\"20220428141727-po0l8p4\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#hash\",\"parentId\":\"20220428141727-1gclyg6\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"list\",\"id\":\"20220428141727-nyjx5v1\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#list\",\"parentId\":\"20220428141727-1gclyg6\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"set\",\"id\":\"20220428141727-ujl3jkq\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#set\",\"parentId\":\"20220428141727-1gclyg6\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"zset\",\"id\":\"20220428141727-8lh8dqt\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#zset\",\"parentId\":\"20220428141727-1gclyg6\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"扩展结构\",\"id\":\"20220428141727-9xu8ei1\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#扩展结构\",\"parentId\":\"20220428141727-imsmasu\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"bitmap\",\"id\":\"20220428141727-89gt7iy\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#bitmap\",\"parentId\":\"20220428141727-9xu8ei1\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"hyperloglog\",\"id\":\"20220428141727-08upaib\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#hyperloglog\",\"parentId\":\"20220428141727-9xu8ei1\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"GEO\",\"id\":\"20220428141727-6z03dvm\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#GEO\",\"parentId\":\"20220428141727-9xu8ei1\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"扩展功能\",\"id\":\"20220428141727-x5n4s7y\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#扩展功能\",\"parentId\":\"20220428141727-imsmasu\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"pub/sub\",\"id\":\"20220428141727-zay76x9\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#pub/sub\",\"parentId\":\"20220428141727-x5n4s7y\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"pipeline\",\"id\":\"20220428141727-m3750uw\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#pipeline\",\"parentId\":\"20220428141727-x5n4s7y\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"Lua 脚本\",\"id\":\"20220428141727-6rc0qt7\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#Lua 脚本\",\"parentId\":\"20220428141727-x5n4s7y\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"事务\",\"id\":\"20220428141727-8i9gpxn\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#事务\",\"parentId\":\"20220428141727-x5n4s7y\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"String的底层实现\",\"id\":\"20220428141728-d2hmuxd\",\"type\":\"d\",\"href\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"sort\":1,\"children\":[{\"title\":\"SDS 结构\",\"id\":\"20220428141728-y2039os\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/String的底层实现#SDS 结构\",\"parentId\":\"20220428141728-d2hmuxd\",\"path\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":3},{\"title\":\"相对于C语言的优势\",\"id\":\"20220428141728-8t63ohh\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/String的底层实现#相对于C语言的优势\",\"parentId\":\"20220428141728-d2hmuxd\",\"path\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[{\"title\":\"统计长度时间复杂度 O(1)\",\"id\":\"20220428141728-xeqpgol\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/String的底层实现#统计长度时间复杂度 O(1)\",\"parentId\":\"20220428141728-8t63ohh\",\"path\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":4},{\"title\":\"数据溢出\",\"id\":\"20220428141728-coew455\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/String的底层实现#数据溢出\",\"parentId\":\"20220428141728-8t63ohh\",\"path\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":4},{\"title\":\"内存重分配策略\",\"id\":\"20220428141728-mbwnou1\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/String的底层实现#内存重分配策略\",\"parentId\":\"20220428141728-8t63ohh\",\"path\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":4},{\"title\":\"数据格式多样性\",\"id\":\"20220428141728-5h2se0u\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/String的底层实现#数据格式多样性\",\"parentId\":\"20220428141728-8t63ohh\",\"path\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"三大编码\",\"id\":\"20220428141728-t4votze\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/String的底层实现#三大编码\",\"parentId\":\"20220428141728-d2hmuxd\",\"path\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"List的底层实现\",\"id\":\"20220428141727-skh553t\",\"type\":\"d\",\"href\":\"/topic/redis/Redis基本数据结构/List的底层实现\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis基本数据结构/List的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"sort\":2,\"children\":[],\"level\":2},{\"title\":\"Hash的底层实现\",\"id\":\"20220428141727-g51ewzt\",\"type\":\"d\",\"href\":\"/topic/redis/Redis基本数据结构/Hash的底层实现\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis基本数据结构/Hash的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"sort\":3,\"children\":[{\"title\":\"ZipList编码的哈希对象\",\"id\":\"20220428141727-fo8pixs\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/Hash的底层实现#ZipList编码的哈希对象\",\"parentId\":\"20220428141727-g51ewzt\",\"path\":\"/topic/redis/Redis基本数据结构/Hash的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":3},{\"title\":\"hashtable对象\",\"id\":\"20220428141727-f7zok8f\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/Hash的底层实现#hashtable对象\",\"parentId\":\"20220428141727-g51ewzt\",\"path\":\"/topic/redis/Redis基本数据结构/Hash的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"Set的底层实现\",\"id\":\"20220428141728-5c6e914\",\"type\":\"d\",\"href\":\"/topic/redis/Redis基本数据结构/Set的底层实现\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis基本数据结构/Set的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"sort\":4,\"children\":[],\"level\":2},{\"title\":\"ZSet的底层实现\",\"id\":\"20220428141728-58eined\",\"type\":\"d\",\"href\":\"/topic/redis/Redis基本数据结构/ZSet的底层实现\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis基本数据结构/ZSet的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"sort\":5,\"children\":[{\"title\":\"跳表是什么?\",\"id\":\"20220428141728-9by553n\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/ZSet的底层实现#跳表是什么?\",\"parentId\":\"20220428141728-58eined\",\"path\":\"/topic/redis/Redis基本数据结构/ZSet的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[{\"title\":\"优缺点\",\"id\":\"20220428141728-rvbr2il\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/ZSet的底层实现#优缺点\",\"parentId\":\"20220428141728-9by553n\",\"path\":\"/topic/redis/Redis基本数据结构/ZSet的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2}],\"level\":1},{\"title\":\"Redis分布式缓存\",\"id\":\"20220428141727-3x1i5zp\",\"type\":\"d\",\"href\":\"/topic/redis/Redis分布式缓存\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"sort\":3,\"children\":[{\"title\":\"双写一致性\",\"id\":\"20220428141727-zahxna7\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#双写一致性\",\"parentId\":\"20220428141727-3x1i5zp\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":2},{\"title\":\"缓存更新策略\",\"id\":\"20220428141727-iqgn80l\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#缓存更新策略\",\"parentId\":\"20220428141727-3x1i5zp\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"最常见的策略\",\"id\":\"20220428141727-45wxv7a\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#最常见的策略\",\"parentId\":\"20220428141727-iqgn80l\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"优点剖析\",\"id\":\"20220428141727-tfanvhu\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#优点剖析\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"1. “先淘汰缓存，再写数据库” 合理\",\"id\":\"20220428141727-vzyp7bi\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#1. “先淘汰缓存，再写数据库” 合理\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"2. 异步刷新，补缺补漏\",\"id\":\"20220428141727-kbueoxr\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#2. 异步刷新，补缺补漏\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"缺点剖析\",\"id\":\"20220428141727-sd1lbh3\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#缺点剖析\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"1. 容灾不足\",\"id\":\"20220428141727-aff14q4\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#1. 容灾不足\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"2. 并发问题\",\"id\":\"20220428141727-7kjhtfn\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#2. 并发问题\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"方案总结\",\"id\":\"20220428141727-5w2loli\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#方案总结\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"写流程：\",\"id\":\"20220428141727-s959uv0\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#写流程：\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"读流程：\",\"id\":\"20220428141727-sceljri\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#读流程：\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"方案分析\",\"id\":\"20220428141727-7flpl0m\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#方案分析\",\"parentId\":\"20220428141727-iqgn80l\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"优点剖析\",\"id\":\"20220428141727-1cqjx66\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#优点剖析\",\"parentId\":\"20220428141727-7flpl0m\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"1. 容灾\",\"id\":\"20220428141727-w9bvsqf\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#1. 容灾\",\"parentId\":\"20220428141727-1cqjx66\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"缺点剖析\",\"id\":\"20220428141727-n1twxfd\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#缺点剖析\",\"parentId\":\"20220428141727-7flpl0m\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"1. 只适合简单业务，复杂业务容易发生并发问题\",\"id\":\"20220428141727-t5kobxh\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#1. 只适合简单业务，复杂业务容易发生并发问题\",\"parentId\":\"20220428141727-n1twxfd\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"缺点1的改进\",\"id\":\"20220428141727-bz5ta88\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#缺点1的改进\",\"parentId\":\"20220428141727-t5kobxh\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":6}],\"level\":5},{\"title\":\"2. 依然是并发问题\",\"id\":\"20220428141727-gysgmg1\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#2. 依然是并发问题\",\"parentId\":\"20220428141727-n1twxfd\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"方案总结\",\"id\":\"20220428141727-01sdgjy\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#方案总结\",\"parentId\":\"20220428141727-iqgn80l\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"写流程：\",\"id\":\"20220428141727-eglmgkf\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#写流程：\",\"parentId\":\"20220428141727-01sdgjy\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"读流程：\",\"id\":\"20220428141727-1vywbk4\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#读流程：\",\"parentId\":\"20220428141727-01sdgjy\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"方案分析\",\"id\":\"20220428141727-137lw2k\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#方案分析\",\"parentId\":\"20220428141727-iqgn80l\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"优点剖析\",\"id\":\"20220428141727-p0zad1o\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#优点剖析\",\"parentId\":\"20220428141727-137lw2k\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"1. 容灾完善\",\"id\":\"20220428141727-cawius6\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#1. 容灾完善\",\"parentId\":\"20220428141727-p0zad1o\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"写流程容灾分析\",\"id\":\"20220428141727-2d2z7fz\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#写流程容灾分析\",\"parentId\":\"20220428141727-cawius6\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":6},{\"title\":\"读流程容灾分析\",\"id\":\"20220428141727-4hr5okn\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#读流程容灾分析\",\"parentId\":\"20220428141727-cawius6\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":6}],\"level\":5},{\"title\":\"2. 无并发问题\",\"id\":\"20220428141727-uvwj2ga\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#2. 无并发问题\",\"parentId\":\"20220428141727-p0zad1o\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"缺点剖析\",\"id\":\"20220428141727-fmiz5zl\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#缺点剖析\",\"parentId\":\"20220428141727-137lw2k\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"1. 增加Cache_0强依赖\",\"id\":\"20220428141727-hr6lxu9\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#1. 增加Cache_0强依赖\",\"parentId\":\"20220428141727-fmiz5zl\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":5},{\"title\":\"2. 复杂度是比较高的\",\"id\":\"20220428141727-vbiftey\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#2. 复杂度是比较高的\",\"parentId\":\"20220428141727-fmiz5zl\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"方案总结\",\"id\":\"20220428141727-0an20z6\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#方案总结\",\"parentId\":\"20220428141727-iqgn80l\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"缓存击穿\",\"id\":\"20220428141728-p93afgy\",\"type\":\"d\",\"href\":\"/topic/redis/Redis分布式缓存/缓存击穿\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis分布式缓存/缓存击穿\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"sort\":1,\"children\":[{\"title\":\"解决方案\",\"id\":\"20220428141728-27esyuz\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存/缓存击穿#解决方案\",\"parentId\":\"20220428141728-p93afgy\",\"path\":\"/topic/redis/Redis分布式缓存/缓存击穿\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"children\":[{\"title\":\"不过期\",\"id\":\"20220428141728-foxjedm\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存/缓存击穿#不过期\",\"parentId\":\"20220428141728-27esyuz\",\"path\":\"/topic/redis/Redis分布式缓存/缓存击穿\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"children\":[],\"level\":4},{\"title\":\"互斥锁\",\"id\":\"20220428141728-68zg08m\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存/缓存击穿#互斥锁\",\"parentId\":\"20220428141728-27esyuz\",\"path\":\"/topic/redis/Redis分布式缓存/缓存击穿\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"缓存穿透\",\"id\":\"20220428141728-64iljj5\",\"type\":\"d\",\"href\":\"/topic/redis/Redis分布式缓存/缓存穿透\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis分布式缓存/缓存穿透\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"sort\":3,\"children\":[{\"title\":\"接口校验\",\"id\":\"20220428141728-wny00tb\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存/缓存穿透#接口校验\",\"parentId\":\"20220428141728-64iljj5\",\"path\":\"/topic/redis/Redis分布式缓存/缓存穿透\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"children\":[],\"level\":3},{\"title\":\"空对象缓存或者缺省值\",\"id\":\"20220428141728-6wjc642\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存/缓存穿透#空对象缓存或者缺省值\",\"parentId\":\"20220428141728-64iljj5\",\"path\":\"/topic/redis/Redis分布式缓存/缓存穿透\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"children\":[],\"level\":3},{\"title\":\"布隆过滤器\",\"id\":\"20220428141728-r9yad28\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存/缓存穿透#布隆过滤器\",\"parentId\":\"20220428141728-64iljj5\",\"path\":\"/topic/redis/Redis分布式缓存/缓存穿透\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"缓存雪崩\",\"id\":\"20220428141728-9ti4duq\",\"type\":\"d\",\"href\":\"/topic/redis/Redis分布式缓存/缓存雪崩\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis分布式缓存/缓存雪崩\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"sort\":4,\"children\":[{\"title\":\"解决方案\",\"id\":\"20220428141728-zu9jxq3\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存/缓存雪崩#解决方案\",\"parentId\":\"20220428141728-9ti4duq\",\"path\":\"/topic/redis/Redis分布式缓存/缓存雪崩\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"children\":[{\"title\":\"三步骤\",\"id\":\"20220428141728-0vnf8gp\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存/缓存雪崩#三步骤\",\"parentId\":\"20220428141728-zu9jxq3\",\"path\":\"/topic/redis/Redis分布式缓存/缓存雪崩\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"缓存预热\",\"id\":\"20220428141728-fz10tn2\",\"type\":\"d\",\"href\":\"/topic/redis/Redis分布式缓存/缓存预热\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis分布式缓存/缓存预热\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"sort\":7,\"children\":[],\"level\":2}],\"level\":1},{\"title\":\"Redis的分布式锁\",\"id\":\"20220428141727-sgydg0x\",\"type\":\"d\",\"href\":\"/topic/redis/Redis的分布式锁\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis的分布式锁\",\"parentPath\":\"/topic/redis\",\"sort\":4,\"children\":[{\"title\":\"利用redis实现分布式锁\",\"id\":\"20220428141727-e4nwnv1\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁#利用redis实现分布式锁\",\"parentId\":\"20220428141727-sgydg0x\",\"path\":\"/topic/redis/Redis的分布式锁\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"三个重要因素\",\"id\":\"20220428141727-zthzzjq\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁#三个重要因素\",\"parentId\":\"20220428141727-e4nwnv1\",\"path\":\"/topic/redis/Redis的分布式锁\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"涉及命令\",\"id\":\"20220428141727-hs1yg88\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁#涉及命令\",\"parentId\":\"20220428141727-e4nwnv1\",\"path\":\"/topic/redis/Redis的分布式锁\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"实现思想\",\"id\":\"20220428141727-5jo3h6s\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁#实现思想\",\"parentId\":\"20220428141727-sgydg0x\",\"path\":\"/topic/redis/Redis的分布式锁\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"业务执行的时间大于redis锁过期的时间\",\"id\":\"20220428141727-q83o36l\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁#业务执行的时间大于redis锁过期的时间\",\"parentId\":\"20220428141727-5jo3h6s\",\"path\":\"/topic/redis/Redis的分布式锁\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"redis部署模式的影响\",\"id\":\"20220428141727-9xczwbf\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁#redis部署模式的影响\",\"parentId\":\"20220428141727-5jo3h6s\",\"path\":\"/topic/redis/Redis的分布式锁\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"原子性问题\",\"id\":\"20220428141727-u4jomll\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁#原子性问题\",\"parentId\":\"20220428141727-5jo3h6s\",\"path\":\"/topic/redis/Redis的分布式锁\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"看门狗模式\",\"id\":\"20220428141728-gdeeql2\",\"type\":\"d\",\"href\":\"/topic/redis/Redis的分布式锁/看门狗模式\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis的分布式锁/看门狗模式\",\"parentPath\":\"/topic/redis/Redis的分布式锁\",\"sort\":1,\"children\":[],\"level\":2},{\"title\":\"Redlock\",\"id\":\"20220428141728-qbzn1tc\",\"type\":\"d\",\"href\":\"/topic/redis/Redis的分布式锁/Redlock\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis的分布式锁/Redlock\",\"parentPath\":\"/topic/redis/Redis的分布式锁\",\"sort\":2,\"children\":[{\"title\":\"问题1\",\"id\":\"20220428141728-lg0r797\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁/Redlock#问题1\",\"parentId\":\"20220428141728-qbzn1tc\",\"path\":\"/topic/redis/Redis的分布式锁/Redlock\",\"parentPath\":\"/topic/redis/Redis的分布式锁\",\"children\":[],\"level\":3},{\"title\":\"问题2\",\"id\":\"20220428141728-nhr8fen\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁/Redlock#问题2\",\"parentId\":\"20220428141728-qbzn1tc\",\"path\":\"/topic/redis/Redis的分布式锁/Redlock\",\"parentPath\":\"/topic/redis/Redis的分布式锁\",\"children\":[],\"level\":3},{\"title\":\"问题3\",\"id\":\"20220428141728-5jc3ave\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁/Redlock#问题3\",\"parentId\":\"20220428141728-qbzn1tc\",\"path\":\"/topic/redis/Redis的分布式锁/Redlock\",\"parentPath\":\"/topic/redis/Redis的分布式锁\",\"children\":[],\"level\":3}],\"level\":2}],\"level\":1},{\"title\":\"Redis集群\",\"id\":\"20220428141727-awm7yu5\",\"type\":\"d\",\"href\":\"/topic/redis/Redis集群\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"sort\":6,\"children\":[{\"title\":\"三种集群方案\",\"id\":\"20220428141727-id6w37y\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#三种集群方案\",\"parentId\":\"20220428141727-awm7yu5\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":2},{\"title\":\"主从复制模式\",\"id\":\"20220428141727-01yokji\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#主从复制模式\",\"parentId\":\"20220428141727-awm7yu5\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"原理\",\"id\":\"20220428141727-2xgqon2\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#原理\",\"parentId\":\"20220428141727-01yokji\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"redis主从复制的坑\",\"id\":\"20220428141727-h04f0fa\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#redis主从复制的坑\",\"parentId\":\"20220428141727-01yokji\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"哨兵模式\",\"id\":\"20220428141727-jxcatge\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#哨兵模式\",\"parentId\":\"20220428141727-awm7yu5\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"哨兵模式的作用\",\"id\":\"20220428141727-3jb6vil\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#哨兵模式的作用\",\"parentId\":\"20220428141727-jxcatge\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"故障切换的过程\",\"id\":\"20220428141727-uscl9hh\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#故障切换的过程\",\"parentId\":\"20220428141727-jxcatge\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"哨兵模式的工作方式：\",\"id\":\"20220428141727-fe5liq6\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#哨兵模式的工作方式：\",\"parentId\":\"20220428141727-jxcatge\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"哨兵模式的优缺点\",\"id\":\"20220428141727-fq18erp\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#哨兵模式的优缺点\",\"parentId\":\"20220428141727-jxcatge\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"Cluster 集群模式（Redis官方）\",\"id\":\"20220428141727-z0udk1o\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#Cluster 集群模式（Redis官方）\",\"parentId\":\"20220428141727-awm7yu5\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"集群的数据分片\",\"id\":\"20220428141727-zez6jhc\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#集群的数据分片\",\"parentId\":\"20220428141727-z0udk1o\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"Redis 集群的主从复制模型\",\"id\":\"20220428141727-guu9h2l\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#Redis 集群的主从复制模型\",\"parentId\":\"20220428141727-z0udk1o\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"集群的特点\",\"id\":\"20220428141727-a9a9ogo\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#集群的特点\",\"parentId\":\"20220428141727-z0udk1o\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"Redis数据淘汰策略\",\"id\":\"20220428141727-oaw8wmd\",\"type\":\"d\",\"href\":\"/topic/redis/Redis集群/Redis数据淘汰策略\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis集群/Redis数据淘汰策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"sort\":5,\"children\":[{\"title\":\"Redis的内存淘汰策略，有以下几种\",\"id\":\"20220428141727-aort8cn\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据淘汰策略#Redis的内存淘汰策略，有以下几种\",\"parentId\":\"20220428141727-oaw8wmd\",\"path\":\"/topic/redis/Redis集群/Redis数据淘汰策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":3},{\"title\":\"数据库中有 3000w 的数据，而 Redis 中只有 100w 数据，如何保证 Redis 中存放的都是热点数据\",\"id\":\"20220428141727-egla613\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据淘汰策略#数据库中有 3000w 的数据，而 Redis 中只有 100w 数据，如何保证 Redis 中存放的都是热点数据\",\"parentId\":\"20220428141727-oaw8wmd\",\"path\":\"/topic/redis/Redis集群/Redis数据淘汰策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"redis持久化\",\"id\":\"20220428141728-ahu8hnn\",\"type\":\"d\",\"href\":\"/topic/redis/Redis集群/redis持久化\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"sort\":8,\"children\":[{\"title\":\"策略\",\"id\":\"20220428141728-h8spnbe\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#策略\",\"parentId\":\"20220428141728-ahu8hnn\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":3},{\"title\":\"AOF持久化\",\"id\":\"20220428141728-8sb3e90\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#AOF持久化\",\"parentId\":\"20220428141728-ahu8hnn\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[{\"title\":\"执行流程\",\"id\":\"20220428141728-xdy9wq3\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#执行流程\",\"parentId\":\"20220428141728-8sb3e90\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4},{\"title\":\"怎么防止AOF文件越来越大？\",\"id\":\"20220428141728-2fjjnsi\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#怎么防止AOF文件越来越大？\",\"parentId\":\"20220428141728-8sb3e90\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[{\"title\":\"AOF文件追加阻塞？\",\"id\":\"20220428141728-jggnla6\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#AOF文件追加阻塞？\",\"parentId\":\"20220428141728-2fjjnsi\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"RDB持久化\",\"id\":\"20220428141728-3uk1dzb\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#RDB持久化\",\"parentId\":\"20220428141728-ahu8hnn\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[{\"title\":\"执行流程\",\"id\":\"20220428141728-b6xujxs\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#执行流程\",\"parentId\":\"20220428141728-3uk1dzb\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"混合持久化（Redis4.0+）\",\"id\":\"20220428141728-z9bdsb4\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#混合持久化（Redis4.0+）\",\"parentId\":\"20220428141728-ahu8hnn\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[{\"title\":\"执行流程\",\"id\":\"20220428141728-flzi42f\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#执行流程\",\"parentId\":\"20220428141728-z9bdsb4\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"Redis的数据恢复策略\",\"id\":\"20220428141728-x9y47t6\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#Redis的数据恢复策略\",\"parentId\":\"20220428141728-ahu8hnn\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":3},{\"title\":\"Redis持久化策略该如何进行选择\",\"id\":\"20220428141728-54y3bdq\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#Redis持久化策略该如何进行选择\",\"parentId\":\"20220428141728-ahu8hnn\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[{\"title\":\"1.不需要考虑数据丢失的情况\",\"id\":\"20220428141728-ujbrmwt\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#1.不需要考虑数据丢失的情况\",\"parentId\":\"20220428141728-54y3bdq\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4},{\"title\":\"2.单机实例情况下\",\"id\":\"20220428141728-zahznfw\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#2.单机实例情况下\",\"parentId\":\"20220428141728-54y3bdq\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4},{\"title\":\"3.在主从环境下\",\"id\":\"20220428141728-jbd8vij\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#3.在主从环境下\",\"parentId\":\"20220428141728-54y3bdq\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[{\"title\":\"那么在从服务器进行数据热备份的情况下，是否还需要持久化呢？\",\"id\":\"20220428141728-sjs8krt\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#那么在从服务器进行数据热备份的情况下，是否还需要持久化呢？\",\"parentId\":\"20220428141728-jbd8vij\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":5},{\"title\":\"4.异地灾备\",\"id\":\"20220428141728-aryf17w\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#4.异地灾备\",\"parentId\":\"20220428141728-jbd8vij\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"Redis数据删除策略\",\"id\":\"20220428141727-pvzi1zo\",\"type\":\"d\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"sort\":13,\"children\":[{\"title\":\"惰性删除\",\"id\":\"20220428141727-o0rija8\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#惰性删除\",\"parentId\":\"20220428141727-pvzi1zo\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":3},{\"title\":\"定期删除\",\"id\":\"20220428141727-wq9axfb\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#定期删除\",\"parentId\":\"20220428141727-pvzi1zo\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":3},{\"title\":\"AOF、RDB 和复制功能对过期键的处理\",\"id\":\"20220428141727-gr8a4lk\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#AOF、RDB 和复制功能对过期键的处理\",\"parentId\":\"20220428141727-pvzi1zo\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[{\"title\":\"RDB\",\"id\":\"20220428141727-xhxrdyf\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#RDB\",\"parentId\":\"20220428141727-gr8a4lk\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4},{\"title\":\"AOF\",\"id\":\"20220428141727-z7l5azb\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#AOF\",\"parentId\":\"20220428141727-gr8a4lk\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4},{\"title\":\"复制\",\"id\":\"20220428141727-vdap5h4\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#复制\",\"parentId\":\"20220428141727-gr8a4lk\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"疑问点？\",\"id\":\"20220428141727-5x39avu\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#疑问点？\",\"parentId\":\"20220428141727-pvzi1zo\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[{\"title\":\"如果主从服务器链接断开怎么办？\",\"id\":\"20220428141727-4505lb0\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#如果主从服务器链接断开怎么办？\",\"parentId\":\"20220428141727-5x39avu\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4},{\"title\":\"如果发生网络抖动，主服务器发送的 del 命令没有传递到从服务器怎么办？\",\"id\":\"20220428141727-4x9rpfk\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#如果发生网络抖动，主服务器发送的 del 命令没有传递到从服务器怎么办？\",\"parentId\":\"20220428141727-5x39avu\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2}],\"level\":1}],\"level\":0}"}},"pageContext":{"slug":"/topic/redis/Redis分布式缓存","topic":"redis"}},"staticQueryHashes":["1284643331","2841359383"]}