{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/RocketMQ顺序消息","result":{"data":{"siYuan":{"excerpt":"RocketMQ顺序消息 消息有序指的是可以按照消息的发送顺序来消费(FIFO)。RocketMQ可以严格的保证消息有序，可以分为分区有序或者全局有序。 > 电商的订单创建，以订单ID作为Sharding Key，那么同一个订单相关的创建订...","raw":"# RocketMQ顺序消息\n\n消息有序指的是可以按照消息的发送顺序来消费(FIFO)。RocketMQ可以严格的保证消息有序，可以分为分区有序或者全局有序。\n\n> 电商的订单创建，以订单ID作为Sharding Key，那么同一个订单相关的创建订单消息、订单支付消息、订单退款消息、订单物流消息都会按照发布的先后顺序来消费。\n>\n\n# 基本原理\n\n在默认的情况下消息发送会采取Round Robin轮询方式把消息发送到不同的queue(分区队列)；\n\n而消费消息的时候从多个queue上拉取消息，这种情况发送和消费是不能保证顺序。\n\n如下图所示: \n\n![](https://image.ztianzeng.com/uPic/20220509173821.png)\n\n![](https://image.ztianzeng.com/uPic/20220509173700.png)\n\n但是如果控制发送的顺序消息只依次发送到同一个queue中，消费的时候只从这个queue上依次拉取，则就保证了顺序。\n\n当发送和消费参与的queue只有一个，则是全局有序；如果多个queue参与，则为分区有序，即相对每个queue，消息都是有序的。\n\n![](https://image.ztianzeng.com/uPic/20220509173907.png)\n\n下面用订单进行分区有序的示例: \n\n> 一个订单的顺序流程是：创建、付款、推送、完成。订单号相同的消息会被先后发送到同一个队列中，消费时，同一个OrderId获取到的肯定是同一个队列。\n>\n\n\n```java\npublic class Producer {\n   public static void main(String[] args) throws Exception {\n       DefaultMQProducer producer = new DefaultMQProducer(\"please_rename_unique_group_name\");\n       producer.setNamesrvAddr(\"127.0.0.1:9876\");\n       producer.start();\n       String[] tags = new String[]{\"TagA\", \"TagC\", \"TagD\"};\n       // 订单列表\n       List<OrderStep> orderList = new Producer().buildOrders();\n       Date date = new Date();\n       SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n       String dateStr = sdf.format(date);\n       for (int i = 0; i < 10; i++) {\n           // 加个时间前缀\n           String body = dateStr + \" Hello RocketMQ \" + orderList.get(i);\n           Message msg = new Message(\"TopicTest\", tags[i % tags.length], \"KEY\" + i, body.getBytes());\n\n           SendResult sendResult = producer.send(msg, new MessageQueueSelector() {\n               @Override\n               public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {\n                   Long id = (Long) arg;  //根据订单id选择发送queue\n                   long index = id % mqs.size();\n                   return mqs.get((int) index);\n               }\n           }, orderList.get(i).getOrderId());//订单id\n\n           System.out.printf(\"SendResult status:%s, queueId:%d, body:%s%n\",\n               sendResult.getSendStatus(),\n               sendResult.getMessageQueue().getQueueId(),\n               body);\n       }\n       producer.shutdown();\n   }\n\n   /**\n    * 订单的步骤\n    */\n   @Data\n   private static class OrderStep {\n       private long orderId;\n       private String desc;\n   }\n\n   /**\n    * 生成模拟订单数据\n    */\n   private List<OrderStep> buildOrders() {\n       List<OrderStep> orderList = new ArrayList<OrderStep>();\n       OrderStep orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103111039L);\n       orderDemo.setDesc(\"创建\");\n       orderList.add(orderDemo);\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103111065L);\n       orderDemo.setDesc(\"创建\");\n       orderList.add(orderDemo);\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103111039L);\n       orderDemo.setDesc(\"付款\");\n       orderList.add(orderDemo);\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103117235L);\n       orderDemo.setDesc(\"创建\");\n       orderList.add(orderDemo);\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103111065L);\n       orderDemo.setDesc(\"付款\");\n       orderList.add(orderDemo);\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103117235L);\n       orderDemo.setDesc(\"付款\");\n       orderList.add(orderDemo);\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103111065L);\n       orderDemo.setDesc(\"完成\");\n       orderList.add(orderDemo);\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103111039L);\n       orderDemo.setDesc(\"推送\");\n       orderList.add(orderDemo);\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103117235L);\n       orderDemo.setDesc(\"完成\");\n       orderList.add(orderDemo);\n       orderDemo = new OrderStep();\n       orderDemo.setOrderId(15103111039L);\n       orderDemo.setDesc(\"完成\");\n       orderList.add(orderDemo);\n       return orderList;\n   }\n}\n```\n\n这是消费者的代码: \n\n```java\npublic class ConsumerInOrder {\n   public static void main(String[] args) throws Exception {\n       DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"please_rename_unique_group_name_3\");\n       consumer.setNamesrvAddr(\"127.0.0.1:9876\");\n       /**\n        * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费<br>\n        * 如果非第一次启动，那么按照上次消费的位置继续消费\n        */\n       consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);\n       consumer.subscribe(\"TopicTest\", \"TagA || TagC || TagD\");\n       consumer.registerMessageListener(new MessageListenerOrderly() {\n           Random random = new Random();\n\n           @Override\n           public ConsumeOrderlyStatus consumeMessage(List<MessageExt> msgs, ConsumeOrderlyContext context) {\n               context.setAutoCommit(true);\n               for (MessageExt msg : msgs) {\n                   // 可以看到每个queue有唯一的consume线程来消费, 订单对每个queue(分区)有序\n                   System.out.println(\"consumeThread=\" + Thread.currentThread().getName() + \"queueId=\" + msg.getQueueId() + \", content:\" + new String(msg.getBody()));\n               }\n               try {\n                   //模拟业务逻辑处理中...\n                   TimeUnit.SECONDS.sleep(random.nextInt(10));\n               } catch (Exception e) {\n                   e.printStackTrace();\n               }\n               return ConsumeOrderlyStatus.SUCCESS;\n           }\n       });\n       consumer.start();\n       System.out.println(\"Consumer Started.\");\n   }\n}\n```\n\n可以看出来，生产者那边需要实现`MessageQueueSelector`完成队列的选举，而消费者需要实现`MessageListenerOrderly`以完成消息的顺序消费\n\n# 问题\n\n如果我们整个RocketMQ搭建的环境是，单个NameServer当个Broker的话，初始MessageQueue的队列为4。\n\n有ID为13, 整个时候Hash情况如下图所示:\n\n![](https://image.ztianzeng.com/uPic/20220510133921.png)\n\n我们由于业务的增长，新增了一个Broker，Broker非成倍数扩容，导致逻辑队列的QueueId无法路由到原有队列中，就变成了这样\n\n![](https://image.ztianzeng.com/uPic/20220510141046.png)\n\n# 解决方案\n\n## 成倍扩容\n\n成倍扩容，实现扩容前后，同样的 key，hash 到原队列，或者 hash 到新扩容的队列。\n\n因为可以参考HashMap的成倍扩容原理，消息要么在原队列上，要么在原有队列上+扩容的长度，由于RocketMQ的特性，他们的QueueId是一致的，所以可以顺序消费\n\n## 一致性Hash\n\n用一致性Hash来计算需要放置的MessageQueue队列\n\n## 自定义负载算法\n\n实现一个自定义的队列负载算法，需要传入一个队列的总队列个数，在负载均衡过程中如果发现数量不对时将消息先暂存到数据库，并将这些失败的队列信息存储到redis中，在发送新消息时，如果计算的负载队列是失败的队列，并且当前的队列信息已经恢复到当前初始值，则先判断数据库中是否有待发送到消息，如果有，则继续将消息发送到数据库，并开启一个线程，将数据库中的消息发送到mq中，这样后续的消息就会继续进入到MQ\n","field":{"slug":"/posts/RocketMQ顺序消息"},"frontmatter":{"title":"RocketMQ顺序消息","tags":["RocketMQ"],"date":"2022-05-09","description":"RocketMQ顺序消息 消息有序指的是可以按照消息的发送顺序来消费(FIFO)。RocketMQ可以严格的保证消息有序，可以分为分区有序或者全局有序。 > 电商的订单创建，以订单ID作为Sharding Key，那么同一个订单相关的创建订..."}},"prev":{"frontmatter":{"title":"RocketMQ Rebalance流程"},"field":{"slug":"/posts/RocketMQ Rebalance流程"}},"next":{"frontmatter":{"title":"RocketMQ持久化原理"},"field":{"slug":"/posts/RocketMQ持久化原理"}}},"pageContext":{"slug":"/posts/RocketMQ顺序消息","prevSlug":"/posts/RocketMQ Rebalance流程","nextSlug":"/posts/RocketMQ持久化原理"}},"staticQueryHashes":["1284643331","2841359383"]}