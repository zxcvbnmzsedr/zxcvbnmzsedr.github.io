{
    "componentChunkName": "component---src-templates-topic-page-template-tsx",
    "path": "/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal使用场景",
    "result": {"pageContext":{"id":"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal使用场景","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"ThreadLocal使用场景"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在业务开发中有两种典型的使用场景。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"保存线程不安全的对象。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"传递全局变量"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"保存线程不安全的工具类"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"典型的类: SimpleDateFormat"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果有多个线程同时调用下面这个方法，由于dateFormat是局部变量，不会有线程安全问题；但是会创建出大量的SimpleDateFormat对象，造成频繁的GC。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public String date() {\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\"mm:ss\");\n        return dateFormat.format(new Date());\n }\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果我们声明成全局变量呢？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"static SimpleDateFormat dateFormat = new SimpleDateFormat(\"mm:ss\");\npublic String date(){\n   return dateFormat.format(new Date());\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在多个线程访问下，不同的线程都是指向同一个对象，会有线程安全的问题、"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"用传统的解决方法: 加锁"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"static SimpleDateFormat dateFormat = new SimpleDateFormat(\"mm:ss\");\npublic synchronized String date(){\n   return dateFormat.format(new Date());\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"加锁的方式的确能够解决线程不安全的问题，但是也带来了性能低下。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"正确的方式是采用ThreadLocal来创建对象"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public synchronized String date(){\n   SimpleDateFormat dateFormat = ThreadSafeFormatter.dateFormatThreadLocal.get();\n   return dateFormat.format(new Date());\n}\nclass ThreadSafeFormatter {\n    public static ThreadLocal<SimpleDateFormat> dateFormatThreadLocal = new ThreadLocal<SimpleDateFormat>() {\n        @Override\n        protected SimpleDateFormat initialValue() {\n            return new SimpleDateFormat(\"mm:ss\");\n        }\n    };\n\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这种创建的方式，最多创建的对象只和线程数相同。这样既高效的使用了内存，也保证了线程安全。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"传递全局变量"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"每个线程内需要保存类似于全局变量的信息，可以让不同方法直接使用，避免参数传递的麻烦却不想被多线程共享。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"例如，用 ThreadLocal 保存一些业务内容，这些信息在同一个线程内相同，但是不同的线程使用的业务内容是不相同的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在线程生命周期内，都通过这个静态 ThreadLocal 实例的 get() 方法取得自己 set 过的那个对象，避免了将这个对象作为参数传递的麻烦。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"案例:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"在分布式链路追踪中，log4j的MDC对象"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"业务系统中，使用ThreadLocal传递用户信息"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"面试题: ThreadLocal是用来解决共享资源的多线程访问吗?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这道题的答案很明确——不是。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ThreadLocal不是用来解决共享资源问题的。虽然ThreadLocal可以用于解决多线程情况下的线程安全问题，但是"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"资源不是共享的，而是每个线程独享过的"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"面试官在忽悠你，独享资源何来的多线程访问呢？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ThreadLocal解决线程安全问题的时候，相比于使用“锁”而言，避免了竞争，采用了线程独享来进行操作。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"具体而言，它可以在 initialValue 中 new 出自己线程独享的资源，而多个线程之间，它们所访问的对象本身是不共享的，自然就不存在任何并发问题。这是 ThreadLocal 解决并发问题的最主要思路。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果变量变成了共享，则依然是线程不安全的:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"\tpublic synchronized String date(){\n   SimpleDateFormat dateFormat = ThreadSafeFormatter.dateFormatThreadLocal.get();\n   return dateFormat.format(new Date());\n}\nclass ThreadSafeFormatter {\n  \tstatic SimpleDateFormat format = new SimpleDateFormat();\n    public static ThreadLocal<SimpleDateFormat> dateFormatThreadLocal = new ThreadLocal<SimpleDateFormat>() {\n        @Override\n        protected SimpleDateFormat initialValue() {\n            return ThreadSafeFormatter.format;\n        }\n    };\n\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"ThreadLocal 和 synchronized 是什么关系"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"当 ThreadLocal 用于解决线程安全问题的时候，也就是把一个对象给每个线程都生成一份独享的副本的，在这种场景下，ThreadLocal 和 synchronized 都可以理解为是用来保证线程安全的手段。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但是效果和实现原理不同："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"ThreadLocal 是通过让每个线程独享自己的副本，避免了资源的竞争。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"synchronized 主要用于临界资源的分配，在同一时刻限制最多只有一个线程能访问该资源。"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"headings":[{"depth":1,"value":"ThreadLocal使用场景","slug":"threadlocal使用场景"},{"depth":2,"value":"保存线程不安全的工具类","slug":"保存线程不安全的工具类"},{"depth":2,"value":"传递全局变量","slug":"传递全局变量"},{"depth":2,"value":"面试题: ThreadLocal是用来解决共享资源的多线程访问吗?","slug":"面试题-threadlocal是用来解决共享资源的多线程访问吗"},{"depth":3,"value":"ThreadLocal 和 synchronized 是什么关系","slug":"threadlocal-和-synchronized-是什么关系"}]}},
    "staticQueryHashes": ["928362550"]}