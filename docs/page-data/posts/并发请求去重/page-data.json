{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/并发请求去重","result":{"data":{"siYuan":{"excerpt":"背景 一些请求在某种情况下，会导致重复请求，比如: Nginx反向代理下游服务器，下游服务器超时自动故障转移进行重试 前端按钮重复点击，没有做处理 分布式环境下，请求出现错误进行重试 甚至于重放攻击 因此，对于后端来说需要统一去处理这种情况...","raw":"# 背景\n\n一些请求在某种情况下，会导致重复请求，比如:\n\n* Nginx反向代理下游服务器，下游服务器超时自动故障转移进行重试\n* 前端按钮重复点击，没有做处理\n* 分布式环境下，请求出现错误进行重试\n* 甚至于[重放攻击](https://zh.wikipedia.org/wiki/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB)\n\n因此，对于后端来说需要统一去处理这种情况。\n\n# 利用唯一编号进行去重\n\n在分布式环境下，我们可以借助Redis来进行数据去重,伪代码如下: \n\n```java\nfun 是否第一次访问(key){\n    if (redis.setKey(key,key,超时时间)){\n\treturn true\n    }else {\n\treturn false\n    }\n}\n```\n\n所以，目前的问题就是这个关键的key怎么生成\n\n## 提前下发\n\n我们可以提供一个接口，提前下发一个key下去，在请求的时候带上这个key就可以完成重复接口的判断\n\n但是这种方式会导致开发成本变大，不太适合用这个\n\n## 唯一索引\n\n 数据库处理就是设置唯一索引，可设联合唯一索引用来处理重复数据。\n\n> 缺点：如果业务场景就是应该存储重复的数据，则该种方式不可用。\n>\n\n## 业务参数去重\n\n主流的方式都是采用业务参数进行去重\n\n我们可以对请求的参数进行一个升序排序，拼接成一个字符串，然后字符串转成MD5来作为请求的key。\n\n代码如下：\n\n> 因为用的是SpringMVC来做处理，参数都是用Bean来声明，所以加密的时候可以去掉排序这项，因为反序列化的顺序就是Bean中的顺序\n>\n\n```java\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RepeatableCommit {\n\n    /**\n     * 根据UserId限制重复提交\n     * 取不到 ID 会报错\n     */\n    boolean userId() default true;\n\n    /**\n     * 用于定义区别重复提交的Key SPEl语法描述，就和CacheAble一样\n     * <p>\n     * 默认直接按照整个类去区分\n     */\n    String key() default \"\";\n\n    /**\n     * 指定时间内不可重复提交,单位毫秒\n     */\n    long timeout() default 3000;\n}\n\n@Aspect\n@Component\npublic class RepeatableCommitAspect {\n\n    @Autowired\n    private RedisConnectionFactory redisConnectionFactory;\n\n    @Around(\"@annotation(com.easysoft.puyao.config.RepeatableCommit)\")\n    public Object around(ProceedingJoinPoint point) throws Throwable {\n        MethodSignature signature = (MethodSignature) point.getSignature();\n        Method method = signature.getMethod();\n        RepeatableCommit commitAnnotation = method.getAnnotation(RepeatableCommit.class);\n        String[] parameterNames = new LocalVariableTableParameterNameDiscoverer().getParameterNames(signature.getMethod());\n\n\n        String className = method.getDeclaringClass().getName();\n        String commitKey = handlerKey(commitAnnotation.key(), parameterNames, point.getArgs());\n\n        String key;\n\n        if (commitAnnotation.userId()) {\n            String userId = BaseContextHandler.getUserId();\n            if (userId == null) {\n                throw new BizRuntimeException(API_REQUEST_LIMIT_ERROR, \"请求失败，UserID不能为空\");\n            }\n            key = StrUtil.format(\"{}_{}_{}\", className, commitKey, userId);\n        } else {\n            key = StrUtil.format(\"{}_{}\", className, commitKey);\n        }\n\n\n        long timeout = commitAnnotation.timeout();\n        RedisLockRegistry redisLockRegistry = new RedisLockRegistry(redisConnectionFactory, \"new_king\", timeout);\n\n        Lock lock = redisLockRegistry.obtain(\"lock:\" + key);\n        if (!lock.tryLock()) {\n            throw new BizRuntimeException(API_REQUEST_LIMIT_ERROR, \"重复请求\");\n        }\n        //执行方法\n        return point.proceed();\n    }\n\n    /**\n     * 处理用于过滤重复请求的key\n     */\n    private String handlerKey(String key, String[] params, Object[] args) {\n        if (StringUtils.isEmpty(key)) {\n            return SecureUtil.md5(JSONObject.toJSONString(args));\n        }\n        Object request = getRequest(key, params, args);\n        return SecureUtil.md5(JSONObject.toJSONString(request));\n    }\n\n    /**\n     * 通过spring Spel 获取参数\n     *\n     * @param key            定义的key值 以#开头 例如:#user\n     * @param parameterNames 形参\n     * @param values         形参值\n     * @return\n     */\n    public Object getRequest(String key, String[] parameterNames, Object[] values) {\n\n        //spel解析器\n        ExpressionParser parser = new SpelExpressionParser();\n        //spel上下文\n        EvaluationContext context = new StandardEvaluationContext();\n        for (int i = 0; i < parameterNames.length; i++) {\n            context.setVariable(parameterNames[i], values[i]);\n        }\n        return parser.parseExpression(key).getValue(context);\n    }\n}\n```\n","field":{"slug":"/posts/并发请求去重"},"frontmatter":{"title":"并发请求去重","tags":[],"date":"2022-05-25","description":"背景 一些请求在某种情况下，会导致重复请求，比如: Nginx反向代理下游服务器，下游服务器超时自动故障转移进行重试 前端按钮重复点击，没有做处理 分布式环境下，请求出现错误进行重试 甚至于重放攻击 因此，对于后端来说需要统一去处理这种情况..."}},"prev":null,"next":{"frontmatter":{"title":"Gatsby4.0升级"},"field":{"slug":"/posts/Gatsby4.0升级"}}},"pageContext":{"slug":"/posts/并发请求去重","prevSlug":null,"nextSlug":"/posts/Gatsby4.0升级"}},"staticQueryHashes":["1284643331","2841359383"]}