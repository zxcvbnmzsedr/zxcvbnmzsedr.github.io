{"componentChunkName":"component---src-templates-topic-post-template-js","path":"/topic/redis/Redis的分布式锁/Redlock","result":{"data":{"siYuan":{"excerpt":"Redlock RedLock的基本思路就是为锁准备多个副本，避免Redis主从切换的时候，数据丢失。 Redlock是分布式锁在利用Redis上的一种具体实现，RedLock 是利用了Redis实现了DLM (Distributed Lo...","raw":"# Redlock\n\nRedLock的基本思路就是为锁准备多个副本，避免Redis主从切换的时候，数据丢失。\n\nRedlock是分布式锁在利用Redis上的一种具体实现，RedLock 是利用了Redis实现了DLM (Distributed Lock Manager), 包含了首先获得多数选票，并设置一个租约(lease)时间的功能, 来保证分布式锁的正确性，和高效性。\n\n假设有N个master节点，通常情况下为5个节点，而且这些节点完全独立，5个节点既保证了性能的同时，又增加了可靠的容错性。\n\n+ 客户端首先获取当前时间，单位为毫秒\n+ 客户端依次尝试在N个redis节点上获取锁，使用通用key和随机数。客户端请求redis的超时时间要远小于锁的释放时间，假如锁的有效时间为10s，则客户端请求的超时时间要设置5-50ms。这避免了当某个redis不可用时，客户端会hold住很长时间\n+ 客户端会计算请求锁时消耗的时间，当客户端获取超过半数成功，且流逝的时间小于锁的有效期时间，则说明客户端成功获取到锁\n+ 成功获得锁后，锁的有效期 = 原来锁的有效期(10s) - 流逝的时间\n+ 如果锁获取失败了，那么客户端应该立即向所有reids节点发起释放锁的操作\n\n## 问题1\n\n由于N个Redis节点中的大多数能正常功能就能保证Redlock正常工作，因此理论上它的可用性更高。单Redis节点的分布式锁在failover的时候锁失效的问题，在Redlock中不存在了，但如果有节点发生崩溃重启，还是会对锁的安全性有影响。具体的影响程度跟Redis对数据的持久化程度有关。\n\n假设一共有5个Redis节点：A B C D E。设想发生了如下的事件序列：\n\n1. 客户端1成功锁住了A B C，获取锁成功（但D和E没有锁住）\n2. 节点C崩溃重启了，但客户端1在C上加的锁没有持久化下来，丢失了\n3. 节点C重启后，客户端2锁住了C D E，获取锁成功  \n   这样，客户端1和客户端2同时获得了锁（针对同一资源）\n\n在默认情况下，Redis的AOF持久化方式是每秒写一次磁盘（即执行fsync），因此最坏情况下可能丢失1秒的数据。为了尽可能不丢数据，Redis允许设置成每次修改数据都进行fsync，但这会降低性能。当然，即使执行了fsync也仍然有可能丢失数据（这取决于系统而不是Redis的实现）。所以上面分析的由于节点重启引发的锁失效问题，总是有可能出现的。为了应对这一问题，antirez又提出了延迟重启（delayed restarts）的概念。也就是说，一个节点崩溃后，先不立即重启它，而是等待一段时间再重启，这段时间应该大于锁的有效时间（lock validty time）。这样的话，这个节点在重启前所参与的锁都会过期，它在重启后就不会对现有的锁造成影响。\n\n## 问题2\n\n![redlock](https://www.shiyitopo.tech/uPic/redlock1.png)\n\n如上面的时序图所示，假设锁服务本身是没有问题的，它总是能保证任一时刻最多只有一个客户端获得锁。上图中出现的lease这个词可以暂且认为就等同于一个带有自动过期功能的锁。客户端1在获得锁之后发生了很长时间的GC pause，在此期间，它获得的锁过期了，而客户端2获得了锁。当客户端2获得了锁。当客户端1从GC pause中恢复过来的时候，它不知道自己持有的锁已经过期了，它依然向共享资源（上图中是一个存储服务）发起了写数据请求，而这时锁实际上被客户端2持有，因此两个客户端的写请求就有可能冲突（锁的互斥作用失效了）。\n\n除了GC以外，有很多原因会导致进程的pause，比如需存造成的缺页故障(page falut)，再比如CPU资源的竞争。即使不考虑进程pause的情况，网络延迟也仍然会造成类似的结果。\n\n总结起来就是说，即使锁服务本身是没有问题的，而仅仅是客户端有长时间的pause或网络延迟，仍然会造成两个客户端同时访问共享资源的冲突情况发生。\n\n## 问题3\n\n如下示例说明了Redlock对系统计时(timing)过分依赖，还是假设有5个Redis节点A B C D E：\n\n1. 客户端1从Redis节点A B C成功获取了锁（多数节点）。由于网络问题，与D和E通信失败。\n2. 节点C上的时钟发生了向前跳跃，导致它上面维护的锁快速过期。\n3. 客户单2从Redis节点C D E成功获取了同一个资源的锁（多数节点）\n4. 客户端1和客户端2现在都认为自己持有了锁\n\n上面这种情况之所以有可能发生，本质上是因为Redlock的安全性(safety property)对系统的时钟有比较强的依赖，一旦系统的时钟变得不准确，算法的安全性也就保证不了。\n\n好的分布式算法应该基于异步模型(asynchronous model)，算法的安全性不应该依赖于任何计时假设(timing assumption)。在异步模型中：进程可能pause任意上的时间，消息可能在网络中延迟任意长的时间，甚至丢失，系统时钟也可能以任意方式出错。一个好的分布式算法，这些因素不应该影响它的安全性(safety property)，只可能影响它的活性(liveness property)，也就是说，即使在非常极端的情况下(比如系统时钟严重错误)，算法顶多是不能再有限的时间内给出结果而已，而不应该给出错误的结果。这样的算法在现实中是存在的，像比较著名的Paxos或Raft。但显然按这个标准的话，Redlock的安全性级别是达不到的。\n\n锁的用途可以分为以下两种：\n\n- 为了效率(efficiency)。协调各个客户端避免做重复的工作。即使锁偶尔失效了，只是可能把某些操作多做一遍而已，不会产生其他的不良后果。比如重复发送一封同样的email。\n- 为了正确性(correctness)。在任何情况下都不允许锁失效的情况发生，因为一旦发生，就可能意味着数据不一致(inconsistency)，数据丢失，文件损坏，或者其他严重的问题。\n\n因此应该根据不同的场景选择不同的锁：\n\n- 如果是为了效率(efficiency)而使用分布式锁，允许锁的偶尔失效，那么使用单Redis节点的锁方案就足够了，简单而且效率高。Redlock而是一个过重的实现\n- 如果是为了正确性(correctness)在很严肃的场合使用分布式锁，那么不要使用Redlock。它不是建立在异步模型上的一个足够强的算法，它对于系统模型的假设中包含很多危险的成分(对于timing)。\n","html":"<div data-node-id=\"20220428141728-g7000vv\" data-node-index=\"0\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">RedLock的基本思路就是为锁准备多个副本，避免Redis主从切换的时候，数据丢失。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141728-jtx4ho8\" data-node-index=\"1\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">Redlock是分布式锁在利用Redis上的一种具体实现，RedLock 是利用了Redis实现了DLM (Distributed Lock Manager), 包含了首先获得多数选票，并设置一个租约(lease)时间的功能, 来保证分布式锁的正确性，和高效性。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141728-iixbxpe\" data-node-index=\"2\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">假设有N个master节点，通常情况下为5个节点，而且这些节点完全独立，5个节点既保证了性能的同时，又增加了可靠的容错性。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"u\" data-node-id=\"20220428141728-h5r9cy0\" data-node-index=\"3\" data-type=\"NodeList\" class=\"list\" updated=\"20220428141728\"><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141728-a7ihm0l\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141728\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141728-n8i4ypr\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">客户端首先获取当前时间，单位为毫秒</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141728-00zrzk9\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141728\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141728-k3ffrq5\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">客户端依次尝试在N个redis节点上获取锁，使用通用key和随机数。客户端请求redis的超时时间要远小于锁的释放时间，假如锁的有效时间为10s，则客户端请求的超时时间要设置5-50ms。这避免了当某个redis不可用时，客户端会hold住很长时间</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141728-jbm635x\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141728\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141728-gy8tu91\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">客户端会计算请求锁时消耗的时间，当客户端获取超过半数成功，且流逝的时间小于锁的有效期时间，则说明客户端成功获取到锁</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141728-yztxzuw\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141728\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141728-msc7xag\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">成功获得锁后，锁的有效期 = 原来锁的有效期(10s) - 流逝的时间</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141728-kw31ygm\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141728\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141728-45mszfp\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">如果锁获取失败了，那么客户端应该立即向所有reids节点发起释放锁的操作</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h2\" data-node-id=\"20220428141728-lg0r797\" data-node-index=\"4\" data-type=\"NodeHeading\" class=\"h2\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">问题1</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141728-52y9wng\" data-node-index=\"5\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">由于N个Redis节点中的大多数能正常功能就能保证Redlock正常工作，因此理论上它的可用性更高。单Redis节点的分布式锁在failover的时候锁失效的问题，在Redlock中不存在了，但如果有节点发生崩溃重启，还是会对锁的安全性有影响。具体的影响程度跟Redis对数据的持久化程度有关。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141728-fkz2rl8\" data-node-index=\"6\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">假设一共有5个Redis节点：A B C D E。设想发生了如下的事件序列：</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"o\" data-node-id=\"20220428141728-cd8gxzw\" data-node-index=\"7\" data-type=\"NodeList\" class=\"list\" updated=\"20220428141921\"><div data-marker=\"1.\" data-subtype=\"o\" data-node-id=\"20220428141728-i3rrkan\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141728\"><div class=\"protyle-action protyle-action--order\" contenteditable=\"false\" draggable=\"true\">1.</div><div data-node-id=\"20220428141728-swbj2cz\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">客户端1成功锁住了A B C，获取锁成功（但D和E没有锁住）</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"2.\" data-subtype=\"o\" data-node-id=\"20220428141728-ija70p8\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141728\"><div class=\"protyle-action protyle-action--order\" contenteditable=\"false\" draggable=\"true\">2.</div><div data-node-id=\"20220428141728-yy6oako\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">节点C崩溃重启了，但客户端1在C上加的锁没有持久化下来，丢失了</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"3.\" data-subtype=\"o\" data-node-id=\"20220428141728-pekqk31\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141921\"><div class=\"protyle-action protyle-action--order\" contenteditable=\"false\" draggable=\"true\">3.</div><div data-node-id=\"20220428141728-esne3w1\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141921\"><div contenteditable=\"true\" spellcheck=\"false\">节点C重启后，客户端2锁住了C D E，获取锁成功\n这样，客户端1和客户端2同时获得了锁（针对同一资源）</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141728-vei5psi\" data-node-index=\"8\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">在默认情况下，Redis的AOF持久化方式是每秒写一次磁盘（即执行fsync），因此最坏情况下可能丢失1秒的数据。为了尽可能不丢数据，Redis允许设置成每次修改数据都进行fsync，但这会降低性能。当然，即使执行了fsync也仍然有可能丢失数据（这取决于系统而不是Redis的实现）。所以上面分析的由于节点重启引发的锁失效问题，总是有可能出现的。为了应对这一问题，antirez又提出了延迟重启（delayed restarts）的概念。也就是说，一个节点崩溃后，先不立即重启它，而是等待一段时间再重启，这段时间应该大于锁的有效时间（lock validty time）。这样的话，这个节点在重启前所参与的锁都会过期，它在重启后就不会对现有的锁造成影响。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h2\" data-node-id=\"20220428141728-nhr8fen\" data-node-index=\"9\" data-type=\"NodeHeading\" class=\"h2\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">问题2</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141728-if2f8ac\" data-node-index=\"10\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\"><span contenteditable=\"false\" data-type=\"img\" class=\"img\"><span> </span><span><span class=\"protyle-action protyle-icons\"><span class=\"protyle-icon protyle-icon--only\"><svg class=\"svg\"><use xlink:href=\"#iconMore\"></use></svg></span></span><img src=\"https://www.shiyitopo.tech/uPic/redlock1.png\" data-src=\"https://www.shiyitopo.tech/uPic/redlock1.png\" alt=\"redlock\" /><span class=\"protyle-action__drag\"></span><span class=\"protyle-action__title\"></span></span><span> </span></span></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141728-nmhkvl9\" data-node-index=\"11\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">如上面的时序图所示，假设锁服务本身是没有问题的，它总是能保证任一时刻最多只有一个客户端获得锁。上图中出现的lease这个词可以暂且认为就等同于一个带有自动过期功能的锁。客户端1在获得锁之后发生了很长时间的GC pause，在此期间，它获得的锁过期了，而客户端2获得了锁。当客户端2获得了锁。当客户端1从GC pause中恢复过来的时候，它不知道自己持有的锁已经过期了，它依然向共享资源（上图中是一个存储服务）发起了写数据请求，而这时锁实际上被客户端2持有，因此两个客户端的写请求就有可能冲突（锁的互斥作用失效了）。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141728-j7ucoba\" data-node-index=\"12\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">除了GC以外，有很多原因会导致进程的pause，比如需存造成的缺页故障(page falut)，再比如CPU资源的竞争。即使不考虑进程pause的情况，网络延迟也仍然会造成类似的结果。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141728-rszqzii\" data-node-index=\"13\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">总结起来就是说，即使锁服务本身是没有问题的，而仅仅是客户端有长时间的pause或网络延迟，仍然会造成两个客户端同时访问共享资源的冲突情况发生。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"h2\" data-node-id=\"20220428141728-5jc3ave\" data-node-index=\"14\" data-type=\"NodeHeading\" class=\"h2\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">问题3</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141728-snir4s0\" data-node-index=\"15\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">如下示例说明了Redlock对系统计时(timing)过分依赖，还是假设有5个Redis节点A B C D E：</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"o\" data-node-id=\"20220428141728-ea46ejp\" data-node-index=\"16\" data-type=\"NodeList\" class=\"list\" updated=\"20220428141728\"><div data-marker=\"1.\" data-subtype=\"o\" data-node-id=\"20220428141728-htv8alc\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141728\"><div class=\"protyle-action protyle-action--order\" contenteditable=\"false\" draggable=\"true\">1.</div><div data-node-id=\"20220428141728-z9sqf2k\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">客户端1从Redis节点A B C成功获取了锁（多数节点）。由于网络问题，与D和E通信失败。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"2.\" data-subtype=\"o\" data-node-id=\"20220428141728-920pudq\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141728\"><div class=\"protyle-action protyle-action--order\" contenteditable=\"false\" draggable=\"true\">2.</div><div data-node-id=\"20220428141728-z3plqz0\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">节点C上的时钟发生了向前跳跃，导致它上面维护的锁快速过期。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"3.\" data-subtype=\"o\" data-node-id=\"20220428141728-ljjien2\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141728\"><div class=\"protyle-action protyle-action--order\" contenteditable=\"false\" draggable=\"true\">3.</div><div data-node-id=\"20220428141728-g5zj0l1\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">客户单2从Redis节点C D E成功获取了同一个资源的锁（多数节点）</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"4.\" data-subtype=\"o\" data-node-id=\"20220428141728-cpn9b63\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141728\"><div class=\"protyle-action protyle-action--order\" contenteditable=\"false\" draggable=\"true\">4.</div><div data-node-id=\"20220428141728-ug6qdot\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">客户端1和客户端2现在都认为自己持有了锁</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141728-4uk7da9\" data-node-index=\"17\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">上面这种情况之所以有可能发生，本质上是因为Redlock的安全性(safety property)对系统的时钟有比较强的依赖，一旦系统的时钟变得不准确，算法的安全性也就保证不了。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141728-2zsrnsl\" data-node-index=\"18\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">好的分布式算法应该基于异步模型(asynchronous model)，算法的安全性不应该依赖于任何计时假设(timing assumption)。在异步模型中：进程可能pause任意上的时间，消息可能在网络中延迟任意长的时间，甚至丢失，系统时钟也可能以任意方式出错。一个好的分布式算法，这些因素不应该影响它的安全性(safety property)，只可能影响它的活性(liveness property)，也就是说，即使在非常极端的情况下(比如系统时钟严重错误)，算法顶多是不能再有限的时间内给出结果而已，而不应该给出错误的结果。这样的算法在现实中是存在的，像比较著名的Paxos或Raft。但显然按这个标准的话，Redlock的安全性级别是达不到的。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141728-d20lld5\" data-node-index=\"19\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">锁的用途可以分为以下两种：</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"u\" data-node-id=\"20220428141728-vksw1d8\" data-node-index=\"20\" data-type=\"NodeList\" class=\"list\" updated=\"20220428141728\"><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141728-oe97dey\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141728\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141728-6rdy95u\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">为了效率(efficiency)。协调各个客户端避免做重复的工作。即使锁偶尔失效了，只是可能把某些操作多做一遍而已，不会产生其他的不良后果。比如重复发送一封同样的email。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141728-bhlltrm\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141728\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141728-45qihen\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">为了正确性(correctness)。在任何情况下都不允许锁失效的情况发生，因为一旦发生，就可能意味着数据不一致(inconsistency)，数据丢失，文件损坏，或者其他严重的问题。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-node-id=\"20220428141728-tdp10ck\" data-node-index=\"21\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">因此应该根据不同的场景选择不同的锁：</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-subtype=\"u\" data-node-id=\"20220428141728-325c00d\" data-node-index=\"22\" data-type=\"NodeList\" class=\"list\" updated=\"20220428141728\"><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141728-b9x6z4g\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141728\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141728-q8bm938\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">如果是为了效率(efficiency)而使用分布式锁，允许锁的偶尔失效，那么使用单Redis节点的锁方案就足够了，简单而且效率高。Redlock而是一个过重的实现</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div data-marker=\"*\" data-subtype=\"u\" data-node-id=\"20220428141728-2tk4zqg\" data-type=\"NodeListItem\" class=\"li\" updated=\"20220428141728\"><div class=\"protyle-action\" draggable=\"true\"><svg><use xlink:href=\"#iconDot\"></use></svg></div><div data-node-id=\"20220428141728-z6b65yj\" data-type=\"NodeParagraph\" class=\"p\" updated=\"20220428141728\"><div contenteditable=\"true\" spellcheck=\"false\">如果是为了正确性(correctness)在很严肃的场合使用分布式锁，那么不要使用Redlock。它不是建立在异步模型上的一个足够强的算法，它对于系统模型的假设中包含很多危险的成分(对于timing)。</div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div><div class=\"protyle-attr\" contenteditable=\"false\">​</div></div>","field":{"slug":"/topic/redis/Redis的分布式锁/Redlock","topic":"redis"},"frontmatter":{"title":"Redlock","tags":["redis","Redis的分布式锁"],"date":"2022-04-28","description":"Redlock RedLock的基本思路就是为锁准备多个副本，避免Redis主从切换的时候，数据丢失。 Redlock是分布式锁在利用Redis上的一种具体实现，RedLock 是利用了Redis实现了DLM (Distributed Lo..."}},"topic":{"title":"redis","tree":"{\"title\":\"redis\",\"id\":\"20220428141727-a3p03i0\",\"parentId\":\"\",\"href\":\"/topic/redis\",\"path\":\"/topic/redis\",\"children\":[{\"title\":\"Redis为什么这么快\",\"id\":\"20220428141727-jbyo2wp\",\"type\":\"d\",\"href\":\"/topic/redis/Redis为什么这么快\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis为什么这么快\",\"parentPath\":\"/topic/redis\",\"sort\":1,\"children\":[{\"title\":\"完全基于内存\",\"id\":\"20220428141727-m8thckv\",\"type\":\"h\",\"href\":\"/topic/redis/Redis为什么这么快#完全基于内存\",\"parentId\":\"20220428141727-jbyo2wp\",\"path\":\"/topic/redis/Redis为什么这么快\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":2},{\"title\":\"数据结构简单\",\"id\":\"20220428141727-0532nq9\",\"type\":\"h\",\"href\":\"/topic/redis/Redis为什么这么快#数据结构简单\",\"parentId\":\"20220428141727-jbyo2wp\",\"path\":\"/topic/redis/Redis为什么这么快\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":2},{\"title\":\"工作线程采用单线程，避免了线程上下文切换所带来的损耗\",\"id\":\"20220428141727-kw7bg9v\",\"type\":\"h\",\"href\":\"/topic/redis/Redis为什么这么快#工作线程采用单线程，避免了线程上下文切换所带来的损耗\",\"parentId\":\"20220428141727-jbyo2wp\",\"path\":\"/topic/redis/Redis为什么这么快\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":2},{\"title\":\"对于客户端的连接采用多路复用和非阻塞I/O\",\"id\":\"20220428141727-m7ruuk1\",\"type\":\"h\",\"href\":\"/topic/redis/Redis为什么这么快#对于客户端的连接采用多路复用和非阻塞I/O\",\"parentId\":\"20220428141727-jbyo2wp\",\"path\":\"/topic/redis/Redis为什么这么快\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":2},{\"title\":\"redis单线程的问题\",\"id\":\"20220428141728-w6wf4kq\",\"type\":\"d\",\"href\":\"/topic/redis/Redis为什么这么快/redis单线程的问题\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis为什么这么快/redis单线程的问题\",\"parentPath\":\"/topic/redis/Redis为什么这么快\",\"sort\":11,\"children\":[],\"level\":2}],\"level\":1},{\"title\":\"Redis基本数据结构\",\"id\":\"20220428141727-imsmasu\",\"type\":\"d\",\"href\":\"/topic/redis/Redis基本数据结构\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"sort\":2,\"children\":[{\"title\":\"常用的\",\"id\":\"20220428141727-1gclyg6\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#常用的\",\"parentId\":\"20220428141727-imsmasu\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"string\",\"id\":\"20220428141727-u2m7nzt\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#string\",\"parentId\":\"20220428141727-1gclyg6\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"hash\",\"id\":\"20220428141727-po0l8p4\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#hash\",\"parentId\":\"20220428141727-1gclyg6\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"list\",\"id\":\"20220428141727-nyjx5v1\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#list\",\"parentId\":\"20220428141727-1gclyg6\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"set\",\"id\":\"20220428141727-ujl3jkq\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#set\",\"parentId\":\"20220428141727-1gclyg6\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"zset\",\"id\":\"20220428141727-8lh8dqt\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#zset\",\"parentId\":\"20220428141727-1gclyg6\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"扩展结构\",\"id\":\"20220428141727-9xu8ei1\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#扩展结构\",\"parentId\":\"20220428141727-imsmasu\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"bitmap\",\"id\":\"20220428141727-89gt7iy\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#bitmap\",\"parentId\":\"20220428141727-9xu8ei1\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"hyperloglog\",\"id\":\"20220428141727-08upaib\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#hyperloglog\",\"parentId\":\"20220428141727-9xu8ei1\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"GEO\",\"id\":\"20220428141727-6z03dvm\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#GEO\",\"parentId\":\"20220428141727-9xu8ei1\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"扩展功能\",\"id\":\"20220428141727-x5n4s7y\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#扩展功能\",\"parentId\":\"20220428141727-imsmasu\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"pub/sub\",\"id\":\"20220428141727-zay76x9\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#pub/sub\",\"parentId\":\"20220428141727-x5n4s7y\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"pipeline\",\"id\":\"20220428141727-m3750uw\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#pipeline\",\"parentId\":\"20220428141727-x5n4s7y\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"Lua 脚本\",\"id\":\"20220428141727-6rc0qt7\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#Lua 脚本\",\"parentId\":\"20220428141727-x5n4s7y\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"事务\",\"id\":\"20220428141727-8i9gpxn\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构#事务\",\"parentId\":\"20220428141727-x5n4s7y\",\"path\":\"/topic/redis/Redis基本数据结构\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"String的底层实现\",\"id\":\"20220428141728-d2hmuxd\",\"type\":\"d\",\"href\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"sort\":1,\"children\":[{\"title\":\"SDS 结构\",\"id\":\"20220428141728-y2039os\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/String的底层实现#SDS 结构\",\"parentId\":\"20220428141728-d2hmuxd\",\"path\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":3},{\"title\":\"相对于C语言的优势\",\"id\":\"20220428141728-8t63ohh\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/String的底层实现#相对于C语言的优势\",\"parentId\":\"20220428141728-d2hmuxd\",\"path\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[{\"title\":\"统计长度时间复杂度 O(1)\",\"id\":\"20220428141728-xeqpgol\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/String的底层实现#统计长度时间复杂度 O(1)\",\"parentId\":\"20220428141728-8t63ohh\",\"path\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":4},{\"title\":\"数据溢出\",\"id\":\"20220428141728-coew455\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/String的底层实现#数据溢出\",\"parentId\":\"20220428141728-8t63ohh\",\"path\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":4},{\"title\":\"内存重分配策略\",\"id\":\"20220428141728-mbwnou1\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/String的底层实现#内存重分配策略\",\"parentId\":\"20220428141728-8t63ohh\",\"path\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":4},{\"title\":\"数据格式多样性\",\"id\":\"20220428141728-5h2se0u\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/String的底层实现#数据格式多样性\",\"parentId\":\"20220428141728-8t63ohh\",\"path\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"三大编码\",\"id\":\"20220428141728-t4votze\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/String的底层实现#三大编码\",\"parentId\":\"20220428141728-d2hmuxd\",\"path\":\"/topic/redis/Redis基本数据结构/String的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"List的底层实现\",\"id\":\"20220428141727-skh553t\",\"type\":\"d\",\"href\":\"/topic/redis/Redis基本数据结构/List的底层实现\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis基本数据结构/List的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"sort\":2,\"children\":[],\"level\":2},{\"title\":\"Hash的底层实现\",\"id\":\"20220428141727-g51ewzt\",\"type\":\"d\",\"href\":\"/topic/redis/Redis基本数据结构/Hash的底层实现\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis基本数据结构/Hash的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"sort\":3,\"children\":[{\"title\":\"ZipList编码的哈希对象\",\"id\":\"20220428141727-fo8pixs\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/Hash的底层实现#ZipList编码的哈希对象\",\"parentId\":\"20220428141727-g51ewzt\",\"path\":\"/topic/redis/Redis基本数据结构/Hash的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":3},{\"title\":\"hashtable对象\",\"id\":\"20220428141727-f7zok8f\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/Hash的底层实现#hashtable对象\",\"parentId\":\"20220428141727-g51ewzt\",\"path\":\"/topic/redis/Redis基本数据结构/Hash的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"Set的底层实现\",\"id\":\"20220428141728-5c6e914\",\"type\":\"d\",\"href\":\"/topic/redis/Redis基本数据结构/Set的底层实现\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis基本数据结构/Set的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"sort\":4,\"children\":[],\"level\":2},{\"title\":\"ZSet的底层实现\",\"id\":\"20220428141728-58eined\",\"type\":\"d\",\"href\":\"/topic/redis/Redis基本数据结构/ZSet的底层实现\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis基本数据结构/ZSet的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"sort\":5,\"children\":[{\"title\":\"跳表是什么?\",\"id\":\"20220428141728-9by553n\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/ZSet的底层实现#跳表是什么?\",\"parentId\":\"20220428141728-58eined\",\"path\":\"/topic/redis/Redis基本数据结构/ZSet的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[{\"title\":\"优缺点\",\"id\":\"20220428141728-rvbr2il\",\"type\":\"h\",\"href\":\"/topic/redis/Redis基本数据结构/ZSet的底层实现#优缺点\",\"parentId\":\"20220428141728-9by553n\",\"path\":\"/topic/redis/Redis基本数据结构/ZSet的底层实现\",\"parentPath\":\"/topic/redis/Redis基本数据结构\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2}],\"level\":1},{\"title\":\"Redis分布式缓存\",\"id\":\"20220428141727-3x1i5zp\",\"type\":\"d\",\"href\":\"/topic/redis/Redis分布式缓存\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"sort\":3,\"children\":[{\"title\":\"双写一致性\",\"id\":\"20220428141727-zahxna7\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#双写一致性\",\"parentId\":\"20220428141727-3x1i5zp\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":2},{\"title\":\"缓存更新策略\",\"id\":\"20220428141727-iqgn80l\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#缓存更新策略\",\"parentId\":\"20220428141727-3x1i5zp\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"最常见的策略\",\"id\":\"20220428141727-45wxv7a\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#最常见的策略\",\"parentId\":\"20220428141727-iqgn80l\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"优点剖析\",\"id\":\"20220428141727-tfanvhu\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#优点剖析\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"1. “先淘汰缓存，再写数据库” 合理\",\"id\":\"20220428141727-vzyp7bi\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#1. “先淘汰缓存，再写数据库” 合理\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"2. 异步刷新，补缺补漏\",\"id\":\"20220428141727-kbueoxr\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#2. 异步刷新，补缺补漏\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"缺点剖析\",\"id\":\"20220428141727-sd1lbh3\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#缺点剖析\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"1. 容灾不足\",\"id\":\"20220428141727-aff14q4\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#1. 容灾不足\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"2. 并发问题\",\"id\":\"20220428141727-7kjhtfn\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#2. 并发问题\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"方案总结\",\"id\":\"20220428141727-5w2loli\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#方案总结\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"写流程：\",\"id\":\"20220428141727-s959uv0\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#写流程：\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"读流程：\",\"id\":\"20220428141727-sceljri\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#读流程：\",\"parentId\":\"20220428141727-45wxv7a\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"方案分析\",\"id\":\"20220428141727-7flpl0m\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#方案分析\",\"parentId\":\"20220428141727-iqgn80l\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"优点剖析\",\"id\":\"20220428141727-1cqjx66\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#优点剖析\",\"parentId\":\"20220428141727-7flpl0m\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"1. 容灾\",\"id\":\"20220428141727-w9bvsqf\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#1. 容灾\",\"parentId\":\"20220428141727-1cqjx66\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"缺点剖析\",\"id\":\"20220428141727-n1twxfd\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#缺点剖析\",\"parentId\":\"20220428141727-7flpl0m\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"1. 只适合简单业务，复杂业务容易发生并发问题\",\"id\":\"20220428141727-t5kobxh\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#1. 只适合简单业务，复杂业务容易发生并发问题\",\"parentId\":\"20220428141727-n1twxfd\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"缺点1的改进\",\"id\":\"20220428141727-bz5ta88\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#缺点1的改进\",\"parentId\":\"20220428141727-t5kobxh\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":6}],\"level\":5},{\"title\":\"2. 依然是并发问题\",\"id\":\"20220428141727-gysgmg1\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#2. 依然是并发问题\",\"parentId\":\"20220428141727-n1twxfd\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"方案总结\",\"id\":\"20220428141727-01sdgjy\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#方案总结\",\"parentId\":\"20220428141727-iqgn80l\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"写流程：\",\"id\":\"20220428141727-eglmgkf\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#写流程：\",\"parentId\":\"20220428141727-01sdgjy\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4},{\"title\":\"读流程：\",\"id\":\"20220428141727-1vywbk4\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#读流程：\",\"parentId\":\"20220428141727-01sdgjy\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"方案分析\",\"id\":\"20220428141727-137lw2k\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#方案分析\",\"parentId\":\"20220428141727-iqgn80l\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"优点剖析\",\"id\":\"20220428141727-p0zad1o\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#优点剖析\",\"parentId\":\"20220428141727-137lw2k\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"1. 容灾完善\",\"id\":\"20220428141727-cawius6\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#1. 容灾完善\",\"parentId\":\"20220428141727-p0zad1o\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"写流程容灾分析\",\"id\":\"20220428141727-2d2z7fz\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#写流程容灾分析\",\"parentId\":\"20220428141727-cawius6\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":6},{\"title\":\"读流程容灾分析\",\"id\":\"20220428141727-4hr5okn\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#读流程容灾分析\",\"parentId\":\"20220428141727-cawius6\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":6}],\"level\":5},{\"title\":\"2. 无并发问题\",\"id\":\"20220428141727-uvwj2ga\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#2. 无并发问题\",\"parentId\":\"20220428141727-p0zad1o\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"缺点剖析\",\"id\":\"20220428141727-fmiz5zl\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#缺点剖析\",\"parentId\":\"20220428141727-137lw2k\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"1. 增加Cache_0强依赖\",\"id\":\"20220428141727-hr6lxu9\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#1. 增加Cache_0强依赖\",\"parentId\":\"20220428141727-fmiz5zl\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":5},{\"title\":\"2. 复杂度是比较高的\",\"id\":\"20220428141727-vbiftey\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#2. 复杂度是比较高的\",\"parentId\":\"20220428141727-fmiz5zl\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"方案总结\",\"id\":\"20220428141727-0an20z6\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存#方案总结\",\"parentId\":\"20220428141727-iqgn80l\",\"path\":\"/topic/redis/Redis分布式缓存\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"缓存击穿\",\"id\":\"20220428141728-p93afgy\",\"type\":\"d\",\"href\":\"/topic/redis/Redis分布式缓存/缓存击穿\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis分布式缓存/缓存击穿\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"sort\":1,\"children\":[{\"title\":\"解决方案\",\"id\":\"20220428141728-27esyuz\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存/缓存击穿#解决方案\",\"parentId\":\"20220428141728-p93afgy\",\"path\":\"/topic/redis/Redis分布式缓存/缓存击穿\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"children\":[{\"title\":\"不过期\",\"id\":\"20220428141728-foxjedm\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存/缓存击穿#不过期\",\"parentId\":\"20220428141728-27esyuz\",\"path\":\"/topic/redis/Redis分布式缓存/缓存击穿\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"children\":[],\"level\":4},{\"title\":\"互斥锁\",\"id\":\"20220428141728-68zg08m\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存/缓存击穿#互斥锁\",\"parentId\":\"20220428141728-27esyuz\",\"path\":\"/topic/redis/Redis分布式缓存/缓存击穿\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"缓存穿透\",\"id\":\"20220428141728-64iljj5\",\"type\":\"d\",\"href\":\"/topic/redis/Redis分布式缓存/缓存穿透\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis分布式缓存/缓存穿透\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"sort\":3,\"children\":[{\"title\":\"接口校验\",\"id\":\"20220428141728-wny00tb\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存/缓存穿透#接口校验\",\"parentId\":\"20220428141728-64iljj5\",\"path\":\"/topic/redis/Redis分布式缓存/缓存穿透\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"children\":[],\"level\":3},{\"title\":\"空对象缓存或者缺省值\",\"id\":\"20220428141728-6wjc642\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存/缓存穿透#空对象缓存或者缺省值\",\"parentId\":\"20220428141728-64iljj5\",\"path\":\"/topic/redis/Redis分布式缓存/缓存穿透\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"children\":[],\"level\":3},{\"title\":\"布隆过滤器\",\"id\":\"20220428141728-r9yad28\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存/缓存穿透#布隆过滤器\",\"parentId\":\"20220428141728-64iljj5\",\"path\":\"/topic/redis/Redis分布式缓存/缓存穿透\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"缓存雪崩\",\"id\":\"20220428141728-9ti4duq\",\"type\":\"d\",\"href\":\"/topic/redis/Redis分布式缓存/缓存雪崩\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis分布式缓存/缓存雪崩\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"sort\":4,\"children\":[{\"title\":\"解决方案\",\"id\":\"20220428141728-zu9jxq3\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存/缓存雪崩#解决方案\",\"parentId\":\"20220428141728-9ti4duq\",\"path\":\"/topic/redis/Redis分布式缓存/缓存雪崩\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"children\":[{\"title\":\"三步骤\",\"id\":\"20220428141728-0vnf8gp\",\"type\":\"h\",\"href\":\"/topic/redis/Redis分布式缓存/缓存雪崩#三步骤\",\"parentId\":\"20220428141728-zu9jxq3\",\"path\":\"/topic/redis/Redis分布式缓存/缓存雪崩\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"缓存预热\",\"id\":\"20220428141728-fz10tn2\",\"type\":\"d\",\"href\":\"/topic/redis/Redis分布式缓存/缓存预热\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis分布式缓存/缓存预热\",\"parentPath\":\"/topic/redis/Redis分布式缓存\",\"sort\":7,\"children\":[],\"level\":2}],\"level\":1},{\"title\":\"Redis的分布式锁\",\"id\":\"20220428141727-sgydg0x\",\"type\":\"d\",\"href\":\"/topic/redis/Redis的分布式锁\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis的分布式锁\",\"parentPath\":\"/topic/redis\",\"sort\":4,\"children\":[{\"title\":\"利用redis实现分布式锁\",\"id\":\"20220428141727-e4nwnv1\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁#利用redis实现分布式锁\",\"parentId\":\"20220428141727-sgydg0x\",\"path\":\"/topic/redis/Redis的分布式锁\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"三个重要因素\",\"id\":\"20220428141727-zthzzjq\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁#三个重要因素\",\"parentId\":\"20220428141727-e4nwnv1\",\"path\":\"/topic/redis/Redis的分布式锁\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"涉及命令\",\"id\":\"20220428141727-hs1yg88\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁#涉及命令\",\"parentId\":\"20220428141727-e4nwnv1\",\"path\":\"/topic/redis/Redis的分布式锁\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"实现思想\",\"id\":\"20220428141727-5jo3h6s\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁#实现思想\",\"parentId\":\"20220428141727-sgydg0x\",\"path\":\"/topic/redis/Redis的分布式锁\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"业务执行的时间大于redis锁过期的时间\",\"id\":\"20220428141727-q83o36l\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁#业务执行的时间大于redis锁过期的时间\",\"parentId\":\"20220428141727-5jo3h6s\",\"path\":\"/topic/redis/Redis的分布式锁\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"redis部署模式的影响\",\"id\":\"20220428141727-9xczwbf\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁#redis部署模式的影响\",\"parentId\":\"20220428141727-5jo3h6s\",\"path\":\"/topic/redis/Redis的分布式锁\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"原子性问题\",\"id\":\"20220428141727-u4jomll\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁#原子性问题\",\"parentId\":\"20220428141727-5jo3h6s\",\"path\":\"/topic/redis/Redis的分布式锁\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"看门狗模式\",\"id\":\"20220428141728-gdeeql2\",\"type\":\"d\",\"href\":\"/topic/redis/Redis的分布式锁/看门狗模式\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis的分布式锁/看门狗模式\",\"parentPath\":\"/topic/redis/Redis的分布式锁\",\"sort\":1,\"children\":[],\"level\":2},{\"title\":\"Redlock\",\"id\":\"20220428141728-qbzn1tc\",\"type\":\"d\",\"href\":\"/topic/redis/Redis的分布式锁/Redlock\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis的分布式锁/Redlock\",\"parentPath\":\"/topic/redis/Redis的分布式锁\",\"sort\":2,\"children\":[{\"title\":\"问题1\",\"id\":\"20220428141728-lg0r797\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁/Redlock#问题1\",\"parentId\":\"20220428141728-qbzn1tc\",\"path\":\"/topic/redis/Redis的分布式锁/Redlock\",\"parentPath\":\"/topic/redis/Redis的分布式锁\",\"children\":[],\"level\":3},{\"title\":\"问题2\",\"id\":\"20220428141728-nhr8fen\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁/Redlock#问题2\",\"parentId\":\"20220428141728-qbzn1tc\",\"path\":\"/topic/redis/Redis的分布式锁/Redlock\",\"parentPath\":\"/topic/redis/Redis的分布式锁\",\"children\":[],\"level\":3},{\"title\":\"问题3\",\"id\":\"20220428141728-5jc3ave\",\"type\":\"h\",\"href\":\"/topic/redis/Redis的分布式锁/Redlock#问题3\",\"parentId\":\"20220428141728-qbzn1tc\",\"path\":\"/topic/redis/Redis的分布式锁/Redlock\",\"parentPath\":\"/topic/redis/Redis的分布式锁\",\"children\":[],\"level\":3}],\"level\":2}],\"level\":1},{\"title\":\"Redis集群\",\"id\":\"20220428141727-awm7yu5\",\"type\":\"d\",\"href\":\"/topic/redis/Redis集群\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"sort\":6,\"children\":[{\"title\":\"三种集群方案\",\"id\":\"20220428141727-id6w37y\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#三种集群方案\",\"parentId\":\"20220428141727-awm7yu5\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":2},{\"title\":\"主从复制模式\",\"id\":\"20220428141727-01yokji\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#主从复制模式\",\"parentId\":\"20220428141727-awm7yu5\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"原理\",\"id\":\"20220428141727-2xgqon2\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#原理\",\"parentId\":\"20220428141727-01yokji\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"redis主从复制的坑\",\"id\":\"20220428141727-h04f0fa\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#redis主从复制的坑\",\"parentId\":\"20220428141727-01yokji\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"哨兵模式\",\"id\":\"20220428141727-jxcatge\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#哨兵模式\",\"parentId\":\"20220428141727-awm7yu5\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"哨兵模式的作用\",\"id\":\"20220428141727-3jb6vil\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#哨兵模式的作用\",\"parentId\":\"20220428141727-jxcatge\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"故障切换的过程\",\"id\":\"20220428141727-uscl9hh\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#故障切换的过程\",\"parentId\":\"20220428141727-jxcatge\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"哨兵模式的工作方式：\",\"id\":\"20220428141727-fe5liq6\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#哨兵模式的工作方式：\",\"parentId\":\"20220428141727-jxcatge\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"哨兵模式的优缺点\",\"id\":\"20220428141727-fq18erp\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#哨兵模式的优缺点\",\"parentId\":\"20220428141727-jxcatge\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"Cluster 集群模式（Redis官方）\",\"id\":\"20220428141727-z0udk1o\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#Cluster 集群模式（Redis官方）\",\"parentId\":\"20220428141727-awm7yu5\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[{\"title\":\"集群的数据分片\",\"id\":\"20220428141727-zez6jhc\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#集群的数据分片\",\"parentId\":\"20220428141727-z0udk1o\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"Redis 集群的主从复制模型\",\"id\":\"20220428141727-guu9h2l\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#Redis 集群的主从复制模型\",\"parentId\":\"20220428141727-z0udk1o\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3},{\"title\":\"集群的特点\",\"id\":\"20220428141727-a9a9ogo\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群#集群的特点\",\"parentId\":\"20220428141727-z0udk1o\",\"path\":\"/topic/redis/Redis集群\",\"parentPath\":\"/topic/redis\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"Redis数据淘汰策略\",\"id\":\"20220428141727-oaw8wmd\",\"type\":\"d\",\"href\":\"/topic/redis/Redis集群/Redis数据淘汰策略\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis集群/Redis数据淘汰策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"sort\":5,\"children\":[{\"title\":\"Redis的内存淘汰策略，有以下几种\",\"id\":\"20220428141727-aort8cn\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据淘汰策略#Redis的内存淘汰策略，有以下几种\",\"parentId\":\"20220428141727-oaw8wmd\",\"path\":\"/topic/redis/Redis集群/Redis数据淘汰策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":3},{\"title\":\"数据库中有 3000w 的数据，而 Redis 中只有 100w 数据，如何保证 Redis 中存放的都是热点数据\",\"id\":\"20220428141727-egla613\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据淘汰策略#数据库中有 3000w 的数据，而 Redis 中只有 100w 数据，如何保证 Redis 中存放的都是热点数据\",\"parentId\":\"20220428141727-oaw8wmd\",\"path\":\"/topic/redis/Redis集群/Redis数据淘汰策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"redis持久化\",\"id\":\"20220428141728-ahu8hnn\",\"type\":\"d\",\"href\":\"/topic/redis/Redis集群/redis持久化\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"sort\":8,\"children\":[{\"title\":\"策略\",\"id\":\"20220428141728-h8spnbe\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#策略\",\"parentId\":\"20220428141728-ahu8hnn\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":3},{\"title\":\"AOF持久化\",\"id\":\"20220428141728-8sb3e90\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#AOF持久化\",\"parentId\":\"20220428141728-ahu8hnn\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[{\"title\":\"执行流程\",\"id\":\"20220428141728-xdy9wq3\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#执行流程\",\"parentId\":\"20220428141728-8sb3e90\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4},{\"title\":\"怎么防止AOF文件越来越大？\",\"id\":\"20220428141728-2fjjnsi\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#怎么防止AOF文件越来越大？\",\"parentId\":\"20220428141728-8sb3e90\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[{\"title\":\"AOF文件追加阻塞？\",\"id\":\"20220428141728-jggnla6\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#AOF文件追加阻塞？\",\"parentId\":\"20220428141728-2fjjnsi\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"RDB持久化\",\"id\":\"20220428141728-3uk1dzb\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#RDB持久化\",\"parentId\":\"20220428141728-ahu8hnn\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[{\"title\":\"执行流程\",\"id\":\"20220428141728-b6xujxs\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#执行流程\",\"parentId\":\"20220428141728-3uk1dzb\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"混合持久化（Redis4.0+）\",\"id\":\"20220428141728-z9bdsb4\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#混合持久化（Redis4.0+）\",\"parentId\":\"20220428141728-ahu8hnn\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[{\"title\":\"执行流程\",\"id\":\"20220428141728-flzi42f\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#执行流程\",\"parentId\":\"20220428141728-z9bdsb4\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"Redis的数据恢复策略\",\"id\":\"20220428141728-x9y47t6\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#Redis的数据恢复策略\",\"parentId\":\"20220428141728-ahu8hnn\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":3},{\"title\":\"Redis持久化策略该如何进行选择\",\"id\":\"20220428141728-54y3bdq\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#Redis持久化策略该如何进行选择\",\"parentId\":\"20220428141728-ahu8hnn\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[{\"title\":\"1.不需要考虑数据丢失的情况\",\"id\":\"20220428141728-ujbrmwt\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#1.不需要考虑数据丢失的情况\",\"parentId\":\"20220428141728-54y3bdq\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4},{\"title\":\"2.单机实例情况下\",\"id\":\"20220428141728-zahznfw\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#2.单机实例情况下\",\"parentId\":\"20220428141728-54y3bdq\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4},{\"title\":\"3.在主从环境下\",\"id\":\"20220428141728-jbd8vij\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#3.在主从环境下\",\"parentId\":\"20220428141728-54y3bdq\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[{\"title\":\"那么在从服务器进行数据热备份的情况下，是否还需要持久化呢？\",\"id\":\"20220428141728-sjs8krt\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#那么在从服务器进行数据热备份的情况下，是否还需要持久化呢？\",\"parentId\":\"20220428141728-jbd8vij\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":5},{\"title\":\"4.异地灾备\",\"id\":\"20220428141728-aryf17w\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/redis持久化#4.异地灾备\",\"parentId\":\"20220428141728-jbd8vij\",\"path\":\"/topic/redis/Redis集群/redis持久化\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"Redis数据删除策略\",\"id\":\"20220428141727-pvzi1zo\",\"type\":\"d\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentId\":\"\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"sort\":13,\"children\":[{\"title\":\"惰性删除\",\"id\":\"20220428141727-o0rija8\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#惰性删除\",\"parentId\":\"20220428141727-pvzi1zo\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":3},{\"title\":\"定期删除\",\"id\":\"20220428141727-wq9axfb\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#定期删除\",\"parentId\":\"20220428141727-pvzi1zo\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":3},{\"title\":\"AOF、RDB 和复制功能对过期键的处理\",\"id\":\"20220428141727-gr8a4lk\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#AOF、RDB 和复制功能对过期键的处理\",\"parentId\":\"20220428141727-pvzi1zo\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[{\"title\":\"RDB\",\"id\":\"20220428141727-xhxrdyf\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#RDB\",\"parentId\":\"20220428141727-gr8a4lk\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4},{\"title\":\"AOF\",\"id\":\"20220428141727-z7l5azb\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#AOF\",\"parentId\":\"20220428141727-gr8a4lk\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4},{\"title\":\"复制\",\"id\":\"20220428141727-vdap5h4\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#复制\",\"parentId\":\"20220428141727-gr8a4lk\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"疑问点？\",\"id\":\"20220428141727-5x39avu\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#疑问点？\",\"parentId\":\"20220428141727-pvzi1zo\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[{\"title\":\"如果主从服务器链接断开怎么办？\",\"id\":\"20220428141727-4505lb0\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#如果主从服务器链接断开怎么办？\",\"parentId\":\"20220428141727-5x39avu\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4},{\"title\":\"如果发生网络抖动，主服务器发送的 del 命令没有传递到从服务器怎么办？\",\"id\":\"20220428141727-4x9rpfk\",\"type\":\"h\",\"href\":\"/topic/redis/Redis集群/Redis数据删除策略#如果发生网络抖动，主服务器发送的 del 命令没有传递到从服务器怎么办？\",\"parentId\":\"20220428141727-5x39avu\",\"path\":\"/topic/redis/Redis集群/Redis数据删除策略\",\"parentPath\":\"/topic/redis/Redis集群\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2}],\"level\":1}],\"level\":0}"}},"pageContext":{"slug":"/topic/redis/Redis的分布式锁/Redlock","topic":"redis"}},"staticQueryHashes":["1284643331","2841359383"]}