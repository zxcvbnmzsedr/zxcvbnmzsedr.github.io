{
    "componentChunkName": "component---src-templates-topic-page-template-tsx",
    "path": "/topic/分布式解决方案/数据调度/分布式事务/Seata框架/Seata解决方案/AT模式",
    "result": {"pageContext":{"id":"/topic/分布式解决方案/数据调度/分布式事务/Seata框架/Seata解决方案/AT模式","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"AT模式"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Seata AT模式是最早⽀持的模式。AT模式是指Automatic (Branch) Transaction Mode⾃动化分⽀事务。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Seata AT 模式是增强型2pc模式，或者说是增强型的XA模型。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"总体来说，AT 模式，是 2pc两阶段提交协议的演变，不同的地⽅，SeataAT 模式不会⼀直锁表。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"使用前提"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"基于支持本地 ACID 事务的关系型数据库"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Java 应用，通过 JDBC 访问数据库"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"整体机制"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Seata AT模型图"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"两阶段提交协议的演变："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"⼀阶段：业务数据和回滚⽇志记录在同⼀个本地事务中提交，释放本地锁和连接资源。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"⼆阶段："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"提交异步化，⾮常快速地完成"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"或回滚通过⼀阶段的回滚⽇志进⾏反向补偿"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"完整的AT在Seata所制定的事务模式下的模型图："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://image.ztianzeng.com/uPic/20201009172509465.png","alt":"20201009172509465"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"数据隔离性"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"写隔离"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"一阶段本地事务提交前，需要确保先拿到 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"全局锁"}]},{"type":"text","value":" 。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"拿不到 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"全局锁"}]},{"type":"text","value":" ，不能提交本地事务。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"拿 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"全局锁"}]},{"type":"text","value":" 的尝试被限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"以一个示例来说明："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"两个全局事务 tx1 和 tx2，分别对 a 表的 m 字段进行更新操作，m 的初始值 1000。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"tx1 先开始，开启本地事务，拿到本地锁，更新操作 m = 1000 - 100 = 900。本地事务提交前，先拿到该记录的 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"全局锁"}]},{"type":"text","value":" ，本地提交释放本地锁。 tx2 后开始，开启本地事务，拿到本地锁，更新操作 m = 900 - 100 = 800。本地事务提交前，尝试拿该记录的 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"全局锁"}]},{"type":"text","value":" ，tx1 全局提交前，该记录的全局锁被 tx1 持有，tx2 需要重试等待 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"全局锁"}]},{"type":"text","value":" 。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://image.ztianzeng.com/uPic/seata_at-1.png","alt":"seata_at-1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"tx1 二阶段全局提交，释放 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"全局锁"}]},{"type":"text","value":" 。tx2 拿到 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"全局锁"}]},{"type":"text","value":" 提交本地事务。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://image.ztianzeng.com/uPic/52J1Ew.jpg","alt":"52J1Ew"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果 tx1 的二阶段全局回滚，则 tx1 需要重新获取该数据的本地锁，进行反向补偿的更新操作，实现分支的回滚。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"此时，如果 tx2 仍在等待该数据的  "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"全局锁"}]},{"type":"text","value":" ，同时持有本地锁，则 tx1 的分支回滚会失败。分支的回滚会一直重试，直到 tx2 的 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"全局锁"}]},{"type":"text","value":" 等锁超时，放弃 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"全局锁"}]},{"type":"text","value":" 并回滚本地事务释放本地锁，tx1 的分支回滚最终成功。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因为整个过程 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"全局锁"}]},{"type":"text","value":" 在 tx1 结束前一直是被 tx1 持有的，所以不会发生 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"脏写"}]},{"type":"text","value":" 的问题。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"读隔离"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在数据库本地事务隔离级别 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"读已提交（Read Committed）"}]},{"type":"text","value":" 或以上的基础上，Seata（AT 模式）的默认全局隔离级别是 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"读未提交（Read Uncommitted）"}]},{"type":"text","value":" 。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果应用在特定场景下，必需要求全局的 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"读已提交"}]},{"type":"text","value":" ，目前 Seata 的方式是通过 SELECT FOR UPDATE 语句的代理。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://image.ztianzeng.com/uPic/EmlTOi.jpg","alt":"EmlTOi"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"SELECT FOR UPDATE 语句的执行会申请 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"全局锁"}]},{"type":"text","value":" ，如果 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"全局锁"}]},{"type":"text","value":" 被其他事务持有，则释放本地锁（回滚 SELECT FOR UPDATE 语句的本地执行）并重试。这个过程中，查询是被 block 住的，直到 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"全局锁"}]},{"type":"text","value":" 拿到，即读取的相关数据是 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"已提交"}]},{"type":"text","value":" 的，才返回。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"出于总体性能上的考虑，Seata 目前的方案并没有对所有 SELECT 语句都进行代理，仅针对 FOR UPDATE 的 SELECT 语句。"}]}],"data":{"quirksMode":false}},"headings":[{"depth":1,"value":"AT模式","slug":"at模式"},{"depth":1,"value":"使用前提","slug":"使用前提"},{"depth":1,"value":"整体机制","slug":"整体机制-1"},{"depth":1,"value":"数据隔离性","slug":"数据隔离性"},{"depth":2,"value":"写隔离","slug":"写隔离"},{"depth":2,"value":"读隔离","slug":"读隔离"}]}},
    "staticQueryHashes": ["928362550"]}