{
    "componentChunkName": "component---src-templates-topic-page-template-tsx",
    "path": "/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点",
    "result": {"pageContext":{"id":"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"锁的种类和特点"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"锁的种类有七种"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"偏向锁/轻量级锁/重量级锁"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"可重入锁/不可重入锁"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"共享锁/独占锁"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"公平锁/非公平锁"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"乐观锁/悲观锁"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"自旋锁/非自旋锁"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"可中断锁/不可中断锁"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"偏向锁/轻量级锁/重量级锁"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这三种是JVM为了提升synchronized修饰的方法的并发性能，而出现的锁。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"实现方式是通过对象头中的mark word 字段，来表明锁的状态。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"偏向锁"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"偏向锁指的是，如果一段代码的并发程度很低，只有一个线程在请求锁，那么其实就没有必要上锁，JVM的做法是，当一个对象被初始化之后，这个时候就是可偏向的，在第一个线程访问锁的时候会在这个对象标记上线程的信息，那么在下一次还是这个线程请求，就直接获取到锁，开销比较小，性能好"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"轻量级锁"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"轻量级锁，synchronized修饰的方法被多个线程访问，就会从偏向锁升级成轻量级锁。因为在绝大多数的情况下，线程都是交替执行只存在于少量的竞争，这个时候轻量级锁会通过CAS方式进行自旋，不会陷入到阻塞"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"重量级锁"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"重量级锁，是在操作系统层实现的一个完全互斥的锁。当有多个线程在竞争，且竞争的时间过长的时候，轻量级锁就会膨胀成重量级锁。重量级锁会让其他没有获取到锁的线程进入阻塞状态。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以，synchronized的锁是会经历 无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁 这几个过程，这个过程也被称之为锁的膨胀。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"其中，偏向锁性能最好，轻量级锁由于CAS自旋，所以性能次之，重量级锁存在线程的阻塞和唤醒，性能最差。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"可重入锁/不可重入锁"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"可重入锁是指，在线程当前已经持有这把锁了，在不释放这把锁的情况下，再次获取这把锁。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"不可重入锁是指，在线程当前已经只有这把锁了，必须得先释放掉持有的锁，才能够重新获取锁。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"对于可重入锁而言，最典型的就是 ReentrantLock 了，正如它的名字一样，reentrant 的意思就是可重入，它也是 Lock 接口最主要的一个实现类。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"%E5%85%B1%E4%BA%AB%E9%94%81%E7%8B%AC%E5%8D%A0%E9%94%81.md"},"children":[{"type":"text","value":"共享锁/独占锁"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"最好能够全是共享锁和独占锁的是"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"读写锁"}]},{"type":"text","value":"。读文件的时候，可以多个线程读取一个文件，但是在写入的时候只允许一个线程进行写入。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"当读写锁是写加锁状态时, 在这个锁被解锁之前, 所有试图对这个锁加锁的线程都会被阻塞."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"当读写锁在读加锁状态时, 所有试图以读模式对它进行加锁的线程都可以得到访问权, 但是如果线程希望以写模式对此锁进行加锁, 它必须直到所有的线程释放锁."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"通常, 当读写锁处于读模式锁住状态时, 如果有另外线程试图以写模式加锁, 读写锁通常会阻塞随后的读模式锁请求, 这样可以避免读模式锁长期占用, 而等待的写模式锁请求长期阻塞."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"%E5%85%AC%E5%B9%B3%E9%94%81%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81.md"},"children":[{"type":"text","value":"公平锁/非公平锁"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"公平锁是指，在线程拿不到锁的时候会进入到等待，开始排队，在队列中等待时间长的会优先分配到锁，先来先得。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"非公平锁是指，在线程拿不到锁的时候，开始排队，但是分配上是会忽略掉排队时间，随机分配到一个线程上"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81.md"},"children":[{"type":"text","value":"乐观锁/悲观锁"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"悲观锁在获取到资源之前，必须先拿到锁，JVM的重量级锁就是一种悲观锁，只有在独占锁的时候，才回去操作资源。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"乐观锁在获取资源之前无需拿到锁，只有在最后更新的时候，会通过CAS的方式去更新资源，JVM的轻量级锁与之类似"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"%E8%87%AA%E6%97%8B%E9%94%81%E9%9D%9E%E8%87%AA%E6%97%8B%E9%94%81.md"},"children":[{"type":"text","value":"自旋锁/非自旋锁"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"自旋锁的理念是如果线程现在拿不到锁，并不直接陷入阻塞或者释放 CPU 资源，而是开始利用循环，不停地尝试获取锁，这个循环过程被形象地比喻为“自旋”，就像是线程在“自我旋转”。相反，非自旋锁的理念就是没有自旋的过程，如果拿不到锁就直接放弃，或者进行其他的处理逻辑，例如去排队、陷入阻塞等。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"不可中断锁/可中断锁"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在 Java 中，synchronized 关键字修饰的锁代表的是不可中断锁，一旦线程申请了锁，就没有回头路了，只能等到拿到锁以后才能进行其他的逻辑处理。而我们的 ReentrantLock 是一种典型的可中断锁，例如使用 lockInterruptibly 方法在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需要一直傻等到获取到锁才离开。"}]}],"data":{"quirksMode":false}},"headings":[{"depth":1,"value":"锁的种类和特点","slug":"锁的种类和特点"},{"depth":2,"value":"偏向锁/轻量级锁/重量级锁","slug":"偏向锁轻量级锁重量级锁"},{"depth":2,"value":"可重入锁/不可重入锁","slug":"可重入锁不可重入锁"},{"depth":2,"value":"共享锁/独占锁","slug":"共享锁独占锁-1"},{"depth":2,"value":"公平锁/非公平锁","slug":"公平锁非公平锁-1"},{"depth":2,"value":"乐观锁/悲观锁","slug":"乐观锁悲观锁"},{"depth":2,"value":"自旋锁/非自旋锁","slug":"自旋锁非自旋锁-1"},{"depth":2,"value":"不可中断锁/可中断锁","slug":"不可中断锁可中断锁"}]}},
    "staticQueryHashes": ["928362550"]}