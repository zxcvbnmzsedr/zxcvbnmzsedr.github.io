{
    "componentChunkName": "component---src-templates-topic-page-template-tsx",
    "path": "/topic/Java并发工具包/并发工具/各种锁/lock的常用方法",
    "result": {"pageContext":{"id":"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"lock的常用方法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"方法概览:"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public interface Lock {\n\n    void lock();\n\n    void lockInterruptibly() throws InterruptedException;\n\n    boolean tryLock();\n\n    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;\n\n    void unlock();\n\n    Condition newCondition();\n\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"lock()"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"用于加锁，然后在try代码块中进行相关业务逻辑的处理，然后在finally中释放锁。如果不进行try cache中释放，一旦发生异常，则无法正常释放锁。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"lock() 在执行的过程中是不能被中断，一旦进入死锁那便会永久等待。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"Lock lock = new ReentrantLock();\nlock.lock();\ntry {\n  // 进入锁的保护，处理代码\n} finally{\n  // 解锁\n  lock.unlock();\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"tryLock()"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"为了避免lock()会永久等待的问题，tryLock()会尝试获取锁，如果锁没有被其他线程占用则直接获取到锁，否则立刻返回false。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"通常情况下使用 if 语句判断 tryLock() 的返回结果，根据是否获取到锁来执行不同的业务逻辑"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"Lock lock = new ReentrantLock();\nif(lock.tryLock()) {\n     try{\n         //处理任务\n     }finally{\n         lock.unlock();   //释放锁\n     } \n}else {\n    //如果不能获取锁，则做其他事情\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"tryLock(long time, TimeUnit unit)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"tryLock() 的重载方法是 tryLock(long time, TimeUnit unit)，这个方法和 tryLock() 很类似，区别在于 tryLock(long time, TimeUnit unit) 方法会有一个超时时间，在拿不到锁时会等待一定的时间。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果在时间期限结束后，还获取不到锁，就会返回 false；如果一开始就获取锁或者等待期间内获取到锁，则返回 true。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这个方法解决了 lock() 方法容易发生死锁的问题，使用 tryLock(long time, TimeUnit unit) 时，在等待了一段指定的超时时间后，线程会主动放弃这把锁的获取，避免永久等待；"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在等待的期间，也可以随时中断线程，这就避免了死锁的发生。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"lockInterruptibly()"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"和lock类似，区别的是lockInterruptibly()能够响应线程中断。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"Lock lock = new ReentrantLock();\ntry {\n  locklockInterruptibly();\n  try {\n          System.out.println(\"操作资源\");\n  } finally {\n      lock.unlock();\n  }\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"unlock()"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"对于 ReentrantLock 而言，执行 unlock() 的时候，内部会把锁的“被持有计数器”减 1，直到减到 0 就代表当前这把锁已经完全释放了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果减 1 后计数器不为 0，说明这把锁之前被“重入”了，那么锁并没有真正释放，仅仅是减少了持有的次数。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"newCondition()"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"会生成一个，和锁对象绑定的Condition实例，用于处理线程的等待和通知。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public interface Condition {\n     //使当前线程加入 await() 等待队列中，并释放当锁，当其他线程调用signal()会重新请求锁。与Object.wait()类似。\n    void await() throws InterruptedException;\n\n    //调用该方法的前提是，当前线程已经成功获得与该条件对象绑定的重入锁，否则调用该方法时会抛出IllegalMonitorStateException。\n    //调用该方法后，结束等待的唯一方法是其它线程调用该条件对象的signal()或signalALL()方法。等待过程中如果当前线程被中断，该方法仍然会继续等待，同时保留该线程的中断状态。 \n    void awaitUninterruptibly();\n\n    // 调用该方法的前提是，当前线程已经成功获得与该条件对象绑定的重入锁，否则调用该方法时会抛出IllegalMonitorStateException。\n    //nanosTimeout指定该方法等待信号的的最大时间（单位为纳秒）。若指定时间内收到signal()或signalALL()则返回nanosTimeout减去已经等待的时间；\n    //若指定时间内有其它线程中断该线程，则抛出InterruptedException并清除当前线程的打断状态；若指定时间内未收到通知，则返回0或负数。 \n    long awaitNanos(long nanosTimeout) throws InterruptedException;\n\n    //与await()基本一致，唯一不同点在于，指定时间之内没有收到signal()或signalALL()信号或者线程中断时该方法会返回false;其它情况返回true。\n    boolean await(long time, TimeUnit unit) throws InterruptedException;\n\n   //适用条件与行为与awaitNanos(long nanosTimeout)完全一样，唯一不同点在于它不是等待指定时间，而是等待由参数指定的某一时刻。\n    boolean awaitUntil(Date deadline) throws InterruptedException;\n\n    //唤醒一个在 await()等待队列中的线程。与Object.notify()相似\n    void signal();\n\n   //唤醒 await()等待队列中所有的线程。与object.notifyAll()相似\n    void signalAll();\n}\n"}]}]}],"data":{"quirksMode":false}},"headings":[{"depth":1,"value":"lock的常用方法","slug":"lock的常用方法"},{"depth":2,"value":"lock()","slug":"lock"},{"depth":2,"value":"tryLock()","slug":"trylock"},{"depth":2,"value":"tryLock(long time, TimeUnit unit)","slug":"trylocklong-time-timeunit-unit"},{"depth":2,"value":"lockInterruptibly()","slug":"lockinterruptibly"},{"depth":2,"value":"unlock()","slug":"unlock"},{"depth":2,"value":"newCondition()","slug":"newcondition"}]}},
    "staticQueryHashes": ["928362550"]}