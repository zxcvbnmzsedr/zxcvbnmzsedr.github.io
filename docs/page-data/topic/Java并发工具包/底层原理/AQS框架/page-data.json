{
    "componentChunkName": "component---src-templates-topic-page-template-tsx",
    "path": "/topic/Java并发工具包/底层原理/AQS框架",
    "result": {"pageContext":{"id":"/topic/Java并发工具包/底层原理/AQS框架","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"AQS框架"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"AQS框架，全名叫做"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"A"}]},{"type":"text","value":"bstract"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Q"}]},{"type":"text","value":"ueued"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"S"}]},{"type":"text","value":"ynchronizer。是目前JUC中，各个Lock锁的核心实现。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"AQS提供了一系列的方式方法，用于我们去实现自己的\"锁\"结构。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"接下来，我们会从"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"ReentrantLock"}]},{"type":"text","value":"开始，剖析AQS框架的整体结构。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"模拟场景"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"有三个用户A、B、C，排队去银行取款，银行只有一个窗口。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"用户A办理业务的时间比较长，需要办理20分钟，在A办理窗口的时候，B、C只能在等待。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"代码如下："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public static final ReentrantLock lock = new ReentrantLock();\n    public static void main(String[] args) throws InterruptedException, NoSuchFieldException {\n       Thread A = new Thread(() -> {\n           lock.lock();\n           try {\n               System.out.println(\"用户A开始办理业务\");\n               try { TimeUnit.MINUTES.sleep(20); } catch (InterruptedException e) {e.printStackTrace();}\n               System.out.println(\"用户A办理业务完成\");   \n           }finally {\n               lock.unlock();\n           }\n       },\"用户A\");\n       Thread B = new Thread(() -> {\n           lock.lock();\n           try {\n               System.out.println(\"用户B开始办理业务\");\n           }finally {\n               lock.unlock();\n           }\n       },\"用户B\");\n       Thread C = new Thread(() -> {\n           lock.lock();\n           try {\n               System.out.println(\"用户C开始办理业务\");\n           }finally {\n               lock.unlock();\n           }\n       },\"用户C\");\n       A.start();\n       // 让线程A先启动\n       Thread.sleep(100);\n       B.start();\n       C.start();\n    }\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们使用lock来模拟银行单个柜台的操作，在办理业务之前必须先拿到柜台的锁。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如下图所示，B、C正在座位上排队，A正在办理业务"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/image-20211214133706380.png","alt":"image-20211214133706380"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"源码分析"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们调用lock的方法，才能够获取到办理业务的锁。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":" public void lock() {\n        sync.lock();\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"lock方法的实现，非常简单，就是调用sync对象进行加锁。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"sync对象是继承自AbstractQueuedSynchronizer而实现的锁。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"内部定义了一个lock的抽象方法（我们接下来都以默认的"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"非公平锁"}]},{"type":"text","value":"来进行说明）。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"lock的抽象方法交由给NonfairSync的lock实现。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"abstract static class Sync extends AbstractQueuedSynchronizer {\n\tabstract void lock();\n}\nstatic final class NonfairSync extends Sync {\n  private static final long serialVersionUID = 7316153563782823691L;\n\n  final void lock() {\n    if (compareAndSetState(0, 1))\n      setExclusiveOwnerThread(Thread.currentThread());\n    else\n      acquire(1);\n  }\n\n  protected final boolean tryAcquire(int acquires) {\n    return nonfairTryAcquire(acquires);\n  }\n}\n\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"额外说明:在AQS框架中，有个state字段，这是给实现类用的，谁使用谁实现。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在ReentrantLock的Sync中，state字段: 0代表着被占用;1代表着锁已经被占用。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"接下来，会结合具体场景，来剖析整个流程。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"获取锁流程"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"用户A加锁"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在第一次调用lock方法的时候，会通过CAS的方式去判断state的值。state在第一次调用时，肯定是0，所以这个时候可以通过setExclusiveOwnerThread(Thread.currentThread())方法，设置当前获取这个锁的线程为"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"用户A"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"final void lock() {\n    if (compareAndSetState(0, 1))\n      setExclusiveOwnerThread(Thread.currentThread());\n    else\n      acquire(1);\n  }\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如下图所示:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/%E7%94%A8%E6%88%B7A%E8%BF%9B%E6%9D%A5.png","alt":"用户A进来"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"用户B加锁"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"用户B加锁的这种情况，就会走到整个AQS的核心。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在用户B加锁的时候，会发现\"柜台\"已经被A占用了，只能到一旁的小板凳去等待，会调用acquire(1)方法，获取一张\"小板凳\"；"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public final void acquire(int arg) {\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"可以看到在这个if方法中，会尝试获取锁，并且加入到队列中。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"tryAcquire方法:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"AQS"}]},{"type":"text","value":"采用模板方法的模式，将tryAcquire交由给子类进行实现,最后调用到nonfairTryAcquire。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public abstract class AbstractQueuedSynchronizer{\n  protected boolean tryAcquire(int arg) {\n          throw new UnsupportedOperationException();\n  }\n}\nabstract static class Sync extends AbstractQueuedSynchronizer {\n  final boolean nonfairTryAcquire(int acquires) {\n    // 获取当前线程。\n    final Thread current = Thread.currentThread();\n    // 获取当前的执行状态，因为用户A还没有释放锁，所以这个state是1\n    int c = getState();\n    // 跳过第一个if逻辑\n    if (c == 0) {\n      if (compareAndSetState(0, acquires)) {\n        setExclusiveOwnerThread(current);\n        return true;\n      }\n    }\n    // 这里进来的线程是用户B，当前持有锁的线程是用户A，所以这个if也进行跳过，直接return false\n    else if (current == getExclusiveOwnerThread()) {\n      int nextc = c + acquires;\n      if (nextc < 0) // overflow\n        throw new Error(\"Maximum lock count exceeded\");\n      setState(nextc);\n      return true;\n    }\n    return false;\n  }\n}\n\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在tryAcquire方法返回false之后，将会进入第二个逻辑: "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"acquireQueued(addWaiter(Node.EXCLUSIVE), arg)"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"首先进入的是addWaiter，用户B的进入队列的逻辑:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"addWaiter(Node.EXCLUSIVE);\nprivate Node addWaiter(Node mode) {\n  // 创建出node对象，node中存储了当前线程 和 Node的类型（目前是独占模式）\n  Node node = new Node(Thread.currentThread(), mode);\n  // 尾巴结点，目前没有东西\n  Node pred = tail;\n  // 所以跳过第一个if判断\n  if (pred != null) {\n    node.prev = pred;\n    if (compareAndSetTail(pred, node)) {\n      pred.next = node;\n      return node;\n    }\n  }\n  // 将节点插入队列\n  enq(node);\n  return node;\n}\n// 将节点插入到队列中\nprivate Node enq(final Node node) {\n  for (;;) {\n    // 第一次循环——尾结点，目前是null\n    // 第二次循环——尾结点，目前是new Node\n    Node t = tail;\n    // 第一次循环——进入初始化\n    if (t == null) { // Must initialize\n      // 第一次循环——设置头尾结点为一个新的节点，注意：此时头结点不是 用户B，将进入下一个循环\n      if (compareAndSetHead(new Node()))\n        tail = head;\n    } else {\n      // 用户B真正的入队逻辑\n      // 第二次循环——用户B的前驱节点是\n      node.prev = t;\n      // 第二次循环——将用户B设置成尾结点\n      if (compareAndSetTail(t, node)) {\n        // 第二次循环——头结点的后继节点是 用户B\n        t.next = node;\n        return t;\n      }\n    }\n  }\n}\n最后进入队列的用户B会呈现出这样的状态\n  new Node() ----next---> 用户B\n  new Node() <---prev---— 用户B\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/image-20211214151453981.png","alt":"image-20211214151453981"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"再来看: acquireQueued方法,这个方法实现了 用户B 的阻塞"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"// node现在是addWaiter返回的 用户B\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            // 获取 用户B 的 前驱节点，目前是个空节点\n            final Node p = node.predecessor();\n\t\t\t\t\t\t// p == head 是成立的, 但是 由于 用户A依然占有线程，tryAcquire 返回的是false\n            // 所以跳过这if判断\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return interrupted;\n            }\n            // shouldParkAfterFailedAcquire是只，在抢占失败之后阻塞线程，会将头结点的waitStatus从0设置成-1，并返回true\n            // parkAndCheckInterrupt将会真正的阻塞线程在这，会调用LockSupport.park(this)进入阻塞态。\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如下图所示，头结点的waitStatus变成了-1"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/image-20211214162714865.png","alt":"image-20211214162714865"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"用户C加锁"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"其逻辑和用户B相类似，直接看排队的代码"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"private Node addWaiter(Node mode) {\n  // 创建出node对象，node中存储了当前线程 和 Node的类型（目前是独占模式）\n  Node node = new Node(Thread.currentThread(), mode);\n  // 尾结点，因为B已经进来了，这个节点是用户B\n  Node pred = tail;\n  // 因为pred不为空\n  if (pred != null) {\n    // 用户C 的前驱节点设置成 用户B\n    // 尾结点指向 用户C\n    // 用户B的 后驱设置成 用户C\n    node.prev = pred;\n    if (compareAndSetTail(pred, node)) {\n      pred.next = node;\n      return node;\n    }\n  }\n  // 不会走到这\n  enq(node);\n  return node;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/image-20211214163207041.png","alt":"image-20211214163207041"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在 B、C入队之后，整个获取锁的流程就结束了，接下来就等待A执行完业务流程释放锁即可。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"释放锁流程"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"同样的，在解锁时也是调用AQS的release方法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public void unlock() {\n\tsync.release(1);\n}\nAQS:\n...\npublic final boolean release(int arg) {\n  if (tryRelease(arg)) {\n    Node h = head;\n    if (h != null && h.waitStatus != 0)\n      unparkSuccessor(h);\n    return true;\n  }\n  return false;\n}\n...\n  \n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"然后通过tryRelease()模板方法，调用回Sync中的tryRelease"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"// 尝试释放锁\nprotected final boolean tryRelease(int releases) {\n \t\t// 当前状态 - 1 = 0\n    int c = getState() - releases;\n  \t// 如果当前线程不是持有锁的线程，不能释放锁\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n  \t// 如果状态为0 说明可以释放锁\n    if (c == 0) {\n        free = true;\n      \t// 将设置线程持有锁的线程为null\n        setExclusiveOwnerThread(null);\n    }\n    // 将状态设置为0\n    setState(c);\n    return free;\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在这一步执行完之后，状态是这样的:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/image-20211214163224576.png","alt":"image-20211214163224576"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在tryRelease执行成功之后，会执行下面这段代码:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":" Node h = head;\nif (h != null && h.waitStatus != 0)\n   unparkSuccessor(h);\n return true;\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"获取头结点，如果头结点不为空且waitStatus为-1时，就调用unparkSuccessor(h)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"private void unparkSuccessor(Node node) {\n       // 获取waitStatus，我们知道，这个时候waitStatus为头结点的-1\n        int ws = node.waitStatus;\n  \t\t\t// 将node的状态从-1设置成0\n        if (ws < 0)\n            compareAndSetWaitStatus(node, ws, 0);\n  \t\t\t// 获取头结点的后驱节点，即 用户B\n        Node s = node.next;\n  \t\t\t// 后面的节点状态是取消的状态，就从最后向前寻找可执行的节点\n        if (s == null || s.waitStatus > 0) {\n            s = null;\n            for (Node t = tail; t != null && t != node; t = t.prev)\n                if (t.waitStatus <= 0)\n                    s = t;\n        }\n        if (s != null)\n          \t// 唤醒线程\n            LockSupport.unpark(s.thread);\n    }\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在unparkSuccessor执行成功之后，会唤醒 用户B的线程, 现在线程被阻塞在 parkAndCheckInterrupt 这一行。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因为这个是自旋的方法，所以唤醒之后，会再次进入判断"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"final boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            // 唤醒之后，会进入到这里\n          \t// 用户B 的 前驱节点依然是 哨兵节点\n            final Node p = node.predecessor();\n\t\t\t\t\t\t// p == head 是成立的\n            // 由于 用户A 已经释放锁，tryAcquire 也成立\n            if (p == head && tryAcquire(arg)) {\n                // 设置头节点为 用户B\n                setHead(node);\n              \t// 将 哨兵 节点的 next 设置为空，也就是\n                p.next = null; // help GC\n                failed = false;\n                return interrupted;\n            }\n            if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n// 设置头节点为 用户B , 然后将线程清空，前置节点清空\n private void setHead(Node node) {\n        head = node;\n        node.thread = null;\n        node.prev = null;\n    }\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/image-20211214165737590.png","alt":"image-20211214165737590"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这个时候，我们的整个AQS的状态已经和最初B进来的时候一致。也就意味着，原本的用户C 占用了 用户B 的位置，排队向前占了一格。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"然后，不断循环处理。就成就了加锁和解锁的逻辑。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"至此，整个AQS就基本算是结束了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"总结"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这个时候，我们再倒过来看AQS中抽象的概念。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/7132e4cef44c26f62835b197b239147b18062.png","alt":"img"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CLH"}]},{"type":"text","value":"队列，虚拟双向队列，Craig,Landin,and Hagersten。仅存在结点之间的关联关系。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点(Node)来实现锁的分配。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"其中Sync queue，即同步队列，是双向链表，包括head结点和tail结点，head结点主要用作后续的调度。‘"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"结点状态"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"// CANCELLED，值为1，表示当前的线程被取消"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"// SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"// CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"// PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"// 值为0，表示当前节点在sync队列中，等待着获取锁"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"AQS就是靠着这个数据结构来对线程来进行处理的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"AQS还有其他各种各样的api，这里就不展开赘述了，可以看去看https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/82077ccf14127a87b77cefd1ccf562d3253591.png","alt":"img"},"children":[]}]}],"data":{"quirksMode":false}},"headings":[{"depth":1,"value":"AQS框架","slug":"aqs框架"},{"depth":2,"value":"模拟场景","slug":"模拟场景-1"},{"depth":2,"value":"源码分析","slug":"源码分析-1"},{"depth":2,"value":"获取锁流程","slug":"获取锁流程"},{"depth":3,"value":"用户A加锁","slug":"用户a加锁"},{"depth":3,"value":"用户B加锁","slug":"用户b加锁"},{"depth":3,"value":"用户C加锁","slug":"用户c加锁"},{"depth":2,"value":"释放锁流程","slug":"释放锁流程"},{"depth":2,"value":"总结","slug":"总结-6"}]}},
    "staticQueryHashes": ["928362550"]}