{
    "componentChunkName": "component---src-templates-topic-page-template-tsx",
    "path": "/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题",
    "result": {"pageContext":{"id":"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"使用CompletableFuture解决旅游平台问题"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"旅游平台问题介绍"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果要搭建一个旅游平台，经常会有这样的需求，就是用户想同时获取多个航空公司的航班信息。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"比如: 北京到上海的票价。由于有很多公司都有这样的航班信息，所以应该获取到所有航空公司的信息，然后聚合输出。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/CompletableFuture.png","alt":"CompletableFuture"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"串行获取"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"最传统的解决方案"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/%E4%B8%B2%E8%A1%8C%E8%8E%B7%E5%8F%96%E7%A4%BA%E6%84%8F%E5%9B%BE.png","alt":"串行获取示意图"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们获取价格的时候，先去访问"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"国航"}]},{"type":"text","value":"等"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"国航"}]},{"type":"text","value":"有响应之后，再去访问下一个航空公司，如果航空公司较多，每个响应都需要1s的话，十几个航空公司就是几十秒，用户肯定等不及。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"并行获取"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/%E5%B9%B6%E8%A1%8C%E8%8E%B7%E5%8F%96.png","alt":"并行获取"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果我们换成并行的去请求各个网站信息，效果就能好很多。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"只需要规定一个超时的总时长，比如3s，3s之后返回的响应一概不管，只把前3s获取到的结果进行返回，即使数据有所丢失，但是也比一直等待的强。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"使用线程池实现"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public class PriceDemo {\n    ExecutorService threadPool = Executors.newFixedThreadPool(3);\n    public static void main(String[] args) throws InterruptedException {\n        PriceDemo priceDemo = new PriceDemo();\n        System.out.println(priceDemo.getPrices());\n    }\n    private Set<String> getPrices() throws InterruptedException {\n        Set<String> prices = Collections.synchronizedSet(new HashSet<>());\n        threadPool.submit(new Task(\"国行\", prices));\n        threadPool.submit(new Task(\"海航\", prices));\n        threadPool.submit(new Task(\"东航\", prices));\n        Thread.sleep(3000);\n        return prices;\n    }\n    /**\n     * 获取价格\n     */\n    private class Task implements Runnable {\n        private String name;\n        private Set<String> prices;\n\n        public Task(String name, Set<String> prices) {\n            this.name = name;\n            this.prices = prices;\n        }\n        @Override\n        public void run() {\n            try {\n                int price = (int) (Math.random() * 4000);\n                Thread.sleep(price);\n                prices.add(name + \": \" + price);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在代码中，新建了一个线程安全的set，用于存储各个航空公司的价格信息。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"然后通过向线程池提交获取价格的任务，最后线程睡3s，模拟用户等待的时间，最后在3s之内获取到的结果进行返回。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这就是使用线程池去实现的最基础的方案。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"CountDownLatch%E8%AF%A6%E8%A7%A3.md"},"children":[{"type":"text","value":"CountDownLatch"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们可以采用CountDownLatch去对上面的代码进行一个优化。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"上面的代码，最大的问题是无论如何都需要等待3秒，假如网络特别好，处理速度特别快，可能几百毫秒就返回了，所以就会白白等待一段时间。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以需要改进一下:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public class PriceDemo {\n    ExecutorService threadPool = Executors.newFixedThreadPool(3);\n    public static void main(String[] args) throws InterruptedException {\n        PriceDemo priceDemo = new PriceDemo();\n        System.out.println(priceDemo.getPrices());\n    }\n    private Set<String> getPrices() throws InterruptedException {\n        Set<String> prices = Collections.synchronizedSet(new HashSet<>());\n        CountDownLatch countDownLatch = new CountDownLatch(3);\n        threadPool.submit(new Task(\"国行\", prices, countDownLatch));\n        threadPool.submit(new Task(\"海航\", prices, countDownLatch));\n        threadPool.submit(new Task(\"东航\", prices, countDownLatch));\n        countDownLatch.await(3, TimeUnit.SECONDS);\n        return prices;\n    }\n\n    /**\n     * 获取价格\n     */\n    private class Task implements Runnable {\n        private String name;\n        private Set<String> prices;\n        private CountDownLatch countDownLatch;\n        public Task(String name, Set<String> prices, CountDownLatch countDownLatch) {\n            this.name = name;\n            this.prices = prices;\n            this.countDownLatch = countDownLatch;\n        }\n        @Override\n        public void run() {\n            try {\n                int price = (int) (Math.random() * 4000);\n                Thread.sleep(price);\n                prices.add(name + \": \" + price);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                countDownLatch.countDown();\n            }\n        }\n    }\n}\n\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"使用CoutDownLatch，来进行任务执行的统计，每完成一个任务，CoutDownLatch的数量则减一。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"然后使用await进行等待，await方法会阻塞当前线程，只有任务执行完，或者在规定时间内没有响应才会往下走。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这就可以保证，总用时会永远小于等于3s."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"CompletableFuture"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"CompletableFuture 提供了简单快速的方法让我们去实现上面使用CountDownLatch实现的代码逻辑。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public static void main(String[] args) throws InterruptedException {\n        PriceDemo priceDemo = new PriceDemo();\n        System.out.println(priceDemo.getPrices());\n    }\n\n    private Set<String> getPrices() throws InterruptedException {\n        Set<String> prices = Collections.synchronizedSet(new HashSet<>());\n        CompletableFuture<Void> task1 = CompletableFuture.runAsync(new Task(\"国行\", prices));\n        CompletableFuture<Void> task2 = CompletableFuture.runAsync(new Task(\"海航\", prices));\n        CompletableFuture<Void> task3 = CompletableFuture.runAsync(new Task(\"东航\", prices));\n        CompletableFuture<Void> allTask = CompletableFuture.allOf(task1, task2, task3);\n        try {\n            allTask.get(3,TimeUnit.SECONDS);\n        } catch (ExecutionException | TimeoutException e) {\n            e.printStackTrace();\n        }\n        return prices;\n    }\n    /**\n     * 获取价格\n     */\n    private class Task implements Runnable {\n        private String name;\n        private Set<String> prices;\n        public Task(String name, Set<String> prices) {\n            this.name = name;\n            this.prices = prices;\n        }\n        @Override\n        public void run() {\n            try {\n                int price = (int) (Math.random() * 4000);\n                Thread.sleep(price);\n                prices.add(name + \": \" + price);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们可以从代码中看到，CompletableFuture对Task进行了包装，然后通过allOf将所有任务聚合起来，最后通过allTask.get()阻塞线程，如果任务超时会进入异常中，我们可以根据异常再去做对应的异常处理，相对于自己使用CountDownLatch实现的，功能性会多一些。"}]}],"data":{"quirksMode":false}},"headings":[{"depth":1,"value":"使用CompletableFuture解决旅游平台问题","slug":"使用completablefuture解决旅游平台问题"},{"depth":2,"value":"旅游平台问题介绍","slug":"旅游平台问题介绍"},{"depth":3,"value":"串行获取","slug":"串行获取"},{"depth":3,"value":"并行获取","slug":"并行获取"},{"depth":2,"value":"使用线程池实现","slug":"使用线程池实现"},{"depth":2,"value":"CountDownLatch","slug":"countdownlatch"},{"depth":2,"value":"CompletableFuture","slug":"completablefuture"}]}},
    "staticQueryHashes": ["928362550"]}