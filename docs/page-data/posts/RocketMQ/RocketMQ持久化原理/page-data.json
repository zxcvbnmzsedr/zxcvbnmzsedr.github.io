{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/RocketMQ/RocketMQ持久化原理","result":{"data":{"siYuan":{"excerpt":"RocketMQ持久化原理 消息的持久化是RocketMQ中最为复杂和重要的一部分，由于持久化机制的存在才能够实现RocketMQ的高可靠性。 图1展示了RocketMQ的整体的工作逻辑 Productor按照顺序写入CommitLog C...","raw":"# RocketMQ持久化原理\n\n消息的持久化是RocketMQ中最为复杂和重要的一部分，由于持久化机制的存在才能够实现RocketMQ的高可靠性。\n\n**图1**展示了RocketMQ的整体的工作逻辑\n\n![](https://image.ztianzeng.com/uPic/20220507104147.png \"图1 整体工作流程\")\n\n1. Productor按照顺序写入`CommitLog`\n2. Consumer顺序读取`ConsumeQueue`进行消费, `ConsumeQueue`是`CommitLog`基于`Topic`的索引文件\n\nRocketMQ通过文件来作为中介，来衔接Productor和Consumer之间的消息传递，其流程还是比较简单的。\n\n# ComitLog\n\ncomitLog是RocketMQ存储消息的地方，Productor的发送消息都会写入到这个文件里面。\n\n对应的实现类就叫做CommitLog。\n\nCommitLog是通过MMAP的方式来操作文件，以加快文件处理速度，代码在`asyncPutMessages`\n\n```java\n// CommitLog.java\npublic CompletableFuture<PutMessageResult> asyncPutMessages(final MessageExtBatch messageExtBatch) {\n        \t// .....\n            MappedFile mappedFile = this.mappedFileQueue.getLastMappedFile();\n\n\t\t// 如果文件为空，或者文件已经满了，则整一个新的文件出来\n            if (null == mappedFile || mappedFile.isFull()) {\n                mappedFile = this.mappedFileQueue.getLastMappedFile(0); // Mark: NewFile may be cause noise\n            }\n\t\t// 创建出来的文件为空，就返回异常\n            if (null == mappedFile) {\n                log.error(\"Create mapped file1 error, topic: {} clientAddr: {}\", messageExtBatch.getTopic(), messageExtBatch.getBornHostString());\n                return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, null));\n            }\n            // 向文件中追加消息信息\n            result = mappedFile.appendMessages(messageExtBatch, this.appendMessageCallback, putMessageContext);\n\n            switch (result.getStatus()) {\n\t\t// 如果正常处理，则相安无事\n                case PUT_OK:\n                    break;\n\t\t// 如果正好到了文件的末尾，则新建一个文件追加到新的文件中去\n                case END_OF_FILE:\n                    unlockMappedFile = mappedFile;\n                    // Create a new file, re-write the message\n                    mappedFile = this.mappedFileQueue.getLastMappedFile(0);\n                    if (null == mappedFile) {\n                        // XXX: warn and notify me\n                        log.error(\"Create mapped file2 error, topic: {} clientAddr: {}\", messageExtBatch.getTopic(), messageExtBatch.getBornHostString());\n                        return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result));\n                    }\n                    result = mappedFile.appendMessages(messageExtBatch, this.appendMessageCallback, putMessageContext);\n                    break;\n                case MESSAGE_SIZE_EXCEEDED:\n                case PROPERTIES_SIZE_EXCEEDED:\n                    return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result));\n                case UNKNOWN_ERROR:\n                default:\n                    return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result));\n            }\n\t// .....\n    }\n```\n\n`asyncPutMessages` 追加msg信息还是比较好理解的，会调用到一个自己封装的`MappedFile`\n\n在`MappedFile`的构造函数中，通过JDK提供的文件NIO，初始化了`mappedByteBuffer`\n\n```java\n// MappedFile.java\nprivate void init(final String fileName, final int fileSize) throws IOException {\n        // .... \n            this.fileChannel = new RandomAccessFile(this.file, \"rw\").getChannel();\n\t    // 用mmap的技术来获取文件的句柄\n            this.mappedByteBuffer = this.fileChannel.map(MapMode.READ_WRITE, 0, fileSize);\n            TOTAL_MAPPED_VIRTUAL_MEMORY.addAndGet(fileSize);\n            TOTAL_MAPPED_FILES.incrementAndGet();\n            ok = true;\n   // .....\n    \n```\n\n然后调用`MappedFile`的`appendMessagesInner`来进行文件的追加，最终又会回到`CommitLog`中的内部类`DefaultAppendMessageCallback`完成文件的写入。\n\n# ComitLog结构\n\n启动一个Productor，向着Broker中发送一条msg，msg结构如下\n\n```java\nMessage msg = new Message(\"TopicTest\",\n                    \"TagA\",\n                    \"OrderID188\",\n                    \"Hello world\".getBytes(RemotingHelper.DEFAULT_CHARSET));\n```\n\n然后我们用UltraEdit查看一下位于`${home}/store/commitlog`下的`00000000000000000000` 文件\n\n![](https://image.ztianzeng.com/uPic/20220507160040.png)\n\n可以明显的看到这个CommitLog文件里面明显有我们上传的msg信息。它具体的写入逻辑在`CommitLog`中的内部类`DefaultAppendMessageCallback#doAppend`。\n\n这个代码非常的长，主要盯住`byteBuffer` 这个对象，看看往里面`put`了什么东西\n\n```java\n/**\n* 追加逻辑\n* @param fileFromOffset 文件偏移量，也就是具体的文件\n* @param byteBuffer 字节缓冲区，需要通过这个对象，完成文件的追加\n* @param maxBlank  可以写入的文件的所剩空间\n* @param msgInner 内部消息，就是msg对象\n* @param putMessageContext 写入消息的上下文\n* @return\n*/\npublic AppendMessageResult doAppend(final long fileFromOffset, final ByteBuffer byteBuffer, final int maxBlank,\n\t// ...先省略        \n}\n```\n\n## 第一个put\n\n通过IDEA工具，可以看到第一个`byteBuffer`的`put`处理，是用于判断文件是否结束的\n\n```java\n// 如果消息的长度+用于控制文件结束的8个空白字符 > 剩余胡亮\nif ((msgLen + END_FILE_MIN_BLANK_LENGTH) > maxBlank) {\n                this.msgStoreItemMemory.clear();\n                // 1 TOTALSIZE\n                this.msgStoreItemMemory.putInt(maxBlank);\n                // 2 MAGICCODE\n                this.msgStoreItemMemory.putInt(CommitLog.BLANK_MAGIC_CODE);\n                // 3 The remaining space may be any value\n                // Here the length of the specially set maxBlank\n                final long beginTimeMills = CommitLog.this.defaultMessageStore.now();\n\t\t// 加入最后8个空白字符，并且返回文件已经写满的标记\n                byteBuffer.put(this.msgStoreItemMemory.array(), 0, 8);\n                return new AppendMessageResult(AppendMessageStatus.END_OF_FILE, wroteOffset,\n                        maxBlank, /* only wrote 8 bytes, but declare wrote maxBlank for compute write position */\n                        msgIdSupplier, msgInner.getStoreTimestamp(),\n                        queueOffset, CommitLog.this.defaultMessageStore.now() - beginTimeMills);\n}\n```\n\n## 第二个put\n\n第二个Put的时候，`put`了一个`preEncodeBuffer` 进去\n\n```java\nbyteBuffer.put(preEncodeBuffer);\n```\n\n所以，重点就回到了`preEncodeBuffer`是怎么构造出来的\n\n```java\n// CommitLog.java\n// 发现就一行代码，通过内部msgInner获取到byteBuffer\nByteBuffer preEncodeBuffer = msgInner.getEncodedBuff();\n```\n\n继续倒过来看，可以看到`MessageExtEncoder`中设置有`encode`方法来对进来的消息体进行设置\n\n```java\n// 1 TOTALSIZE\nthis.encoderBuffer.putInt(msgLen);\n// 2 MAGICCODE\nthis.encoderBuffer.putInt(CommitLog.MESSAGE_MAGIC_CODE);\n// 3 BODYCRC\nthis.encoderBuffer.putInt(msgInner.getBodyCRC());\n// 4 QUEUEID\nthis.encoderBuffer.putInt(msgInner.getQueueId());\n// 5 FLAG\nthis.encoderBuffer.putInt(msgInner.getFlag());\n// 6 QUEUEOFFSET, need update later\nthis.encoderBuffer.putLong(0);\n{\n   // DefaultAppendMessageCallback.class 中\n   preEncodeBuffer.putLong(pos, queueOffset);\n}\n// 7 PHYSICALOFFSET, need update later\nthis.encoderBuffer.putLong(0);\n{\n   // DefaultAppendMessageCallback.class 中\n    preEncodeBuffer.putLong(pos, fileFromOffset + byteBuffer.position());\n\n}\n\n// 8 SYSFLAG\nthis.encoderBuffer.putInt(msgInner.getSysFlag());\n// 9 BORNTIMESTAMP\nthis.encoderBuffer.putLong(msgInner.getBornTimestamp());\n// 10 BORNHOST\nsocketAddress2ByteBuffer(msgInner.getBornHost() ,this.encoderBuffer);\n// 11 STORETIMESTAMP\nthis.encoderBuffer.putLong(msgInner.getStoreTimestamp());\n// 12 STOREHOSTADDRESS\nsocketAddress2ByteBuffer(msgInner.getStoreHost() ,this.encoderBuffer);\n// 13 RECONSUMETIMES\nthis.encoderBuffer.putInt(msgInner.getReconsumeTimes());\n// 14 Prepared Transaction Offset\nthis.encoderBuffer.putLong(msgInner.getPreparedTransactionOffset());\n// 15 BODY\nthis.encoderBuffer.putInt(bodyLength);\nif (bodyLength > 0)\n    this.encoderBuffer.put(msgInner.getBody());\n// 16 TOPIC\nthis.encoderBuffer.put((byte) topicLength);\nthis.encoderBuffer.put(topicData);\n// 17 PROPERTIES\nthis.encoderBuffer.putShort((short) propertiesLength);\nif (propertiesLength > 0)\n    this.encoderBuffer.put(propertiesData);\n```\n\n> ![](https://image.ztianzeng.com/uPic/20220507163411.png)\n>\n> 1. TOTALSIZE: 该消息条目总长度，4字节\n> 2. MAGICCODE: 魔法值，固定0xdaa320a7，4字节\n> 3. BODYCRC: 消息体crc校验码，4字节\n> 4. QUEUEID: ComsumeQueue消息消费队列ID，4字节\n> 5. FLAG: 消息FLAG，预留给消费者的标识位，4字节\n> 6. QUEUEOFFSET: 消息在ComsumeQueue的偏移量，8字节\n> 7. PHYSICALOFFSET: 消息在CommitLog文件中的偏移量，8字节\n> 8. SYSFLAG: 消息系统FLAG，例如是否压缩、是否有事务消息，4字节\n> 9. BORNTIMESTAMP: 消息产生者调用消息发送API的时间戳，8字节\n> 10. BORNHOST: 消息发送者IP、端口号，8字节\n> 11. STORETIMESTAMP: 消息存储时间戳，8字节\n> 12. STOREHOSPTADDRESS: Broker服务器IP+端口号，8字节\n> 13. RECONSUMETIMES: 消息重试次数，4字节\n> 14. Prepare Transaction Offset: 事务消息物理偏移量，8字节\n> 15. BodyLength: 消息体长度，4字节\n> 16. Body: 消息体内容\n> 17. TopicLength: 主题存储长度，主题名称不能超过255个字符，1字节\n> 18. Topic: 主题内容\n> 19. PropertiesLength: 消息属性长度，表示消息属性长度不能超过65536个字符，2字节\n> 20. Properties: 消息属性\n>\n\n最后把这个消息体给put到byteBuffer中去，就完成了文件的写入。\n\n# 消息丢失\n\n为了加快读写速度，RocketMQ采用了MMAP来进行写入\n\n1. 将数据文件通过MMAP技术，映射文件到OS的虚拟内存中\n2. MMAP技术在写入消息时，会写入到PageCache中，然后异步刷盘到实际的磁盘中\n\n写入PageCache的时候，假如说这个时候发生了断电，导致数据没有及时刷到磁盘中就会发生消息丢失\n\n## 解决方案\n\n* 修改配置\n\n  修改 Broker 端配置，默认刷盘方式是通过异步刷盘，修改为同步刷盘\n\n  ```java\n  ## 默认情况为 ASYNC_FLUSH \n  flushDiskType = SYNC_FLUSH\n  ```\n\n* 集群部署\n\n  为了保证可用性，Broker 通常采用一主（ `master` ）多从（ `slave` ）部署方式。为了保证消息不丢失，消息还需要复制到 slave 节点。\n\n  默认方式下，消息写入 `master` 成功，就可以返回确认响应给生产者，接着消息将会异步复制到 `slave` 节点。\n\n  > 注：master 配置：flushDiskType = SYNC_FLUSH\n  >\n\n  此时若 master 突然` 宕机且不可恢复` ，那么还未复制到 `slave` 的消息将会丢失。\n\n  为了进一步提高消息的可靠性，我们可以采用同步的复制方式，`master` 节点将会同步等待 `slave` 节点复制完成，才会返回确认响应\n\n虽然上述配置提高消息的高可靠性，但是会降低性能 ，生产实践中需要综合选择。\n","field":{"slug":"/posts/RocketMQ/RocketMQ持久化原理"},"frontmatter":{"title":"RocketMQ持久化原理","tags":["RocketMQ"],"date":"2022-05-07","description":"RocketMQ持久化原理 消息的持久化是RocketMQ中最为复杂和重要的一部分，由于持久化机制的存在才能够实现RocketMQ的高可靠性。 图1展示了RocketMQ的整体的工作逻辑 Productor按照顺序写入CommitLog C..."}},"prev":{"frontmatter":{"title":"RocketMQ顺序消息"},"field":{"slug":"/posts/RocketMQ/RocketMQ顺序消息"}},"next":{"frontmatter":{"title":"RocketMQ延迟消息原理"},"field":{"slug":"/posts/RocketMQ/RocketMQ延迟消息原理"}}},"pageContext":{"slug":"/posts/RocketMQ/RocketMQ持久化原理","prevSlug":"/posts/RocketMQ/RocketMQ顺序消息","nextSlug":"/posts/RocketMQ/RocketMQ延迟消息原理"}},"staticQueryHashes":["1284643331","2841359383"]}