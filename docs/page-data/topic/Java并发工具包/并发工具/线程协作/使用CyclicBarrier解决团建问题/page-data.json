{
    "componentChunkName": "component---src-templates-topic-page-template-tsx",
    "path": "/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题",
    "result": {"pageContext":{"id":"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"使用CyclicBarrier解决团建问题"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"团建问题介绍"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"假设有一家公司要全体员工进行团建活动，活动内容为爬山，但是由于每一个人爬山的时间都是不一样的，因此需要等到所有人都爬过山头之后才能够一起去吃饭，但是每个饭桌只能容纳2个人。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"模拟场景"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们用代码模拟这个场景:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public class PartyBuilding {\n    public static void main(String[] args) {\n        CyclicBarrier cyclicBarrier = new CyclicBarrier(2, () -> System.out.println(\"有两人到齐了,干饭~~~\"));\n        Climbing employee1 = new Climbing(\"甲\", cyclicBarrier);\n        Climbing employee2 = new Climbing(\"乙\", cyclicBarrier);\n        Climbing employee3 = new Climbing(\"丙\", cyclicBarrier);\n        Climbing employee4 = new Climbing(\"丁\", cyclicBarrier);\n        Climbing employee5 = new Climbing(\"戊\", cyclicBarrier);\n        Climbing employee6 = new Climbing(\"己\", cyclicBarrier);\n        ExecutorService executorService = Executors.newFixedThreadPool(5);\n        executorService.submit(employee1);\n        executorService.submit(employee2);\n        executorService.submit(employee3);\n        executorService.submit(employee4);\n        executorService.submit(employee5);\n        executorService.submit(employee6);\n    }\n\n    public static class Climbing implements Runnable {\n        private String name;\n        private CyclicBarrier cyclicBarrier;\n\n        public Climbing(String name, CyclicBarrier cyclicBarrier) {\n            this.name = name;\n            this.cyclicBarrier = cyclicBarrier;\n        }\n\n        @Override\n        public void run() {\n            System.out.println(\"员工:\" + name + \"开始爬山~~\");\n            try {\n                long climbingTime = (long) (Math.random() * 4000);\n                Thread.sleep(climbingTime);\n                System.out.println(\"员工:\" + name + \" 用时:\" + climbingTime + \",等待人齐去吃饭~~\");\n                cyclicBarrier.await();\n            } catch (InterruptedException | BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"运行结果如下:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"员工:乙开始爬山~~\n员工:戊开始爬山~~\n员工:甲开始爬山~~\n员工:丁开始爬山~~\n员工:丙开始爬山~~\n员工:丁 用时:813,等待人齐去吃饭~~\n员工:丙 用时:2022,等待人齐去吃饭~~\n有两人到齐了,干饭~~~\n员工:己开始爬山~~\n员工:乙 用时:2500,等待人齐去吃饭~~\n员工:己 用时:933,等待人齐去吃饭~~\n有两人到齐了,干饭~~~\n员工:甲 用时:3215,等待人齐去吃饭~~\n员工:戊 用时:3898,等待人齐去吃饭~~\n有两人到齐了,干饭~~~\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"能够看到，这段代码输出的结果，符合我们的预期"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"从这段代码中，首先建了参数为2的一个CyclicBarrier，这意味着需要等待2个线程到达这个集结点才统一放行，每2个执行一次runable里面的干饭逻辑。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"CyclicBarrier 和 CountDownLatch 的异同"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"相同点"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"都能够阻塞一个或一组线程，直到某个预设的条件达成发送，再统一出发。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"不同点"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"作用对象不同"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"CyclicBarrier作用于线程，需要等到线程执行完成之后，计数器则减一，到0的时候就继续执行。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"CountDownLatch作用于事件，需要通过调用countDown才能够计数器减一，直到0才继续执行。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"可重用性不同"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"CyclicBarrier可以重复使用，在计时器归零后，会重置计时器重新开始计数，甚至还能通过reset主动重置计数器，如果重置时有线程已经调用await并开始等待，等待的线程会抛出BrokenBarrierException异常。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"CountDownLatch在倒数到0的时候，就不能再次使用了，除非新建一个新的实例。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"执行动作不同"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"CyclicBarrier有执行动作，在满足计数器归零的时候会调用barrierAction执行一个回调操作。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"CountDownLatch没有这个功能"}]}],"data":{"quirksMode":false}},"headings":[{"depth":1,"value":"使用CyclicBarrier解决团建问题","slug":"使用cyclicbarrier解决团建问题"},{"depth":2,"value":"团建问题介绍","slug":"团建问题介绍"},{"depth":2,"value":"模拟场景","slug":"模拟场景"},{"depth":2,"value":"CyclicBarrier 和 CountDownLatch 的异同","slug":"cyclicbarrier-和-countdownlatch-的异同"},{"depth":3,"value":"相同点","slug":"相同点-1"},{"depth":3,"value":"不同点","slug":"不同点-1"},{"depth":4,"value":"作用对象不同","slug":"作用对象不同"},{"depth":4,"value":"可重用性不同","slug":"可重用性不同"},{"depth":4,"value":"执行动作不同","slug":"执行动作不同"}]}},
    "staticQueryHashes": ["928362550"]}