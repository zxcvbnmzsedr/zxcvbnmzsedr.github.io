{
    "componentChunkName": "component---src-templates-article-page-template-tsx",
    "path": "/posts/RedoLog诞生史",
    "result": {"pageContext":{"id":"/posts/RedoLog诞生史","htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"InnoDB"}]},{"type":"text","value":"存储引擎是通过页为单位对数据进行访问，换句话说对数据库的所有操作都最终会作用到这个页上面。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　但是，磁盘的运行速度远远慢于内存，所以在对这个页操作的时候需要将数据给整到内存中去，来加快增删改查的速度。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　MySQL的设计者设计了了一个叫做"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Buffer Pool"}]},{"type":"text","value":"的存储在内存中的数据结构，用于平衡存储介质和内存之间的速度差异："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"写入时先写入"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Buffer Pool"}]},{"type":"text","value":"中，后刷到磁盘中"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"读取时"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Buffer Pool"}]},{"type":"text","value":"中有完整数据，则直接返回"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Buffer Pool"}]},{"type":"text","value":"中只记录了更改状态，则需要合并磁盘和"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Buffer Pool"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Buffer Pool"}]},{"type":"text","value":"中无数据，进入磁盘查找"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　但是，在这种情况下不错处理会有一个问题，在写入"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Buffer Pool"}]},{"type":"text","value":"成功，但是刷写磁盘时可能由于断电导致没有刷成功，数据出现了丢失。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　需要一个新的数据结构，在事务提交完成之前把事务所修改的页面都刷到磁盘中，但是这个简单粗暴的做法有些问题："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"刷新一个完整的数据页太浪费了"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"InnoDB"}]},{"type":"text","value":"中是以页为单位来进行磁盘IO，事务提交时需要将一个完整的页面从内存中刷新到磁盘。一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太浪费了。这种在存储系统中有个专有的名词 —— 写放大（Write Amplification）"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"随机IO刷起来比较慢"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，事务修改的这些页面在物理磁盘上不相邻，每一次操作前都需要寻址，称之为随机IO"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　针对这两种方式也比较好解决:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"刷新完成数据页浪费"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"那就记录被修改的位置，把修改了哪些东西记录一下就好，比如:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"update test set a = 2;"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"将第0号表空间的100号页面的偏移量为1000处的值更新为"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"随机IO刷起来比较慢"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这个就更好解决了，把随机IO给弄成顺序IO，磁盘中开辟一块单独的连续空间，就直接写这片空间就好了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"那空间写满了怎么办？重写！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"空间开辟: 0....100"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"写到100之后，重新从0开始写。只需要做个标记，如果写入的，已经被实实在在的刷到磁盘中了，则这块是可以重写的；否则，MySQL整体阻塞，免得数据出现异常"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　有了这些手段，即使MySQL重启崩溃了，也仅仅需要从这个顺序空间中将数据的操作给捞出来，进行回放重新更新一下数据页就好了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　这个手段，MySQL中已经有了，叫做"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"redo log"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"redo"}]},{"type":"text","value":"日志占用的空间非常小"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n存储表空间ID、页号、偏移量以及需要更新的值所需的存储空间是很小。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"redo"}]},{"type":"text","value":"日志是顺序写入磁盘的"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n在执行事务的过程中，每执行一条语句，就可能产生若干条"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"redo"}]},{"type":"text","value":"日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"style","properties":{"className":["grvsc-styles"]},"children":[{"type":"text","value":"\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n"}]}],"data":{"quirksMode":false}},"html":"<p updated=\"20220805101449\">　　<code>InnoDB</code>存储引擎是通过页为单位对数据进行访问，换句话说对数据库的所有操作都最终会作用到这个页上面。</p>\n<p updated=\"20220805101449\">　　但是，磁盘的运行速度远远慢于内存，所以在对这个页操作的时候需要将数据给整到内存中去，来加快增删改查的速度。</p>\n<p updated=\"20220805101449\">　　MySQL的设计者设计了了一个叫做<code>Buffer Pool</code>的存储在内存中的数据结构，用于平衡存储介质和内存之间的速度差异：</p>\n<ul updated=\"20220805101449\">\n<li id=\"20220805101449-7j753tr\" updated=\"20220805101449\">\n<p updated=\"20220805101449\">写入时先写入<code>Buffer Pool</code>中，后刷到磁盘中</p>\n</li>\n<li id=\"20220805101449-xucpza8\" updated=\"20220805101449\">\n<p updated=\"20220805101449\">读取时</p>\n<ul updated=\"20220805101449\">\n<li id=\"20220805101449-2f6dh3c\" updated=\"20220805101449\">\n<p updated=\"20220805101449\"><code>Buffer Pool</code>中有完整数据，则直接返回</p>\n</li>\n<li id=\"20220805101449-wri8sak\" updated=\"20220805101449\">\n<p updated=\"20220805101449\"><code>Buffer Pool</code>中只记录了更改状态，则需要合并磁盘和<code>Buffer Pool</code></p>\n</li>\n<li id=\"20220805101449-wef94pj\" updated=\"20220805101449\">\n<p updated=\"20220805101449\"><code>Buffer Pool</code>中无数据，进入磁盘查找</p>\n</li>\n</ul>\n</li>\n</ul>\n<p updated=\"20220805101449\">　　但是，在这种情况下不错处理会有一个问题，在写入<code>Buffer Pool</code>成功，但是刷写磁盘时可能由于断电导致没有刷成功，数据出现了丢失。</p>\n<p updated=\"20220805101449\">　　需要一个新的数据结构，在事务提交完成之前把事务所修改的页面都刷到磁盘中，但是这个简单粗暴的做法有些问题：</p>\n<ol updated=\"20220805101449\">\n<li id=\"20220805101449-0vhpmhk\" updated=\"20220805101449\">\n<p updated=\"20220805101449\">刷新一个完整的数据页太浪费了</p>\n<p updated=\"20220805101449\"><code>InnoDB</code>中是以页为单位来进行磁盘IO，事务提交时需要将一个完整的页面从内存中刷新到磁盘。一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太浪费了。这种在存储系统中有个专有的名词 —— 写放大（Write Amplification）</p>\n</li>\n<li id=\"20220805101449-te80klu\" updated=\"20220805101449\">\n<p updated=\"20220805101449\">随机IO刷起来比较慢</p>\n<p updated=\"20220805101449\">一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，事务修改的这些页面在物理磁盘上不相邻，每一次操作前都需要寻址，称之为随机IO</p>\n</li>\n</ol>\n<p updated=\"20220805101449\">　　针对这两种方式也比较好解决:</p>\n<ol updated=\"20220805101449\">\n<li id=\"20220805101449-nlzame6\" updated=\"20220805101449\">\n<p updated=\"20220805101449\">刷新完成数据页浪费</p>\n<p updated=\"20220805101449\">那就记录被修改的位置，把修改了哪些东西记录一下就好，比如:</p>\n<blockquote updated=\"20220805101449\">\n<p updated=\"20220805101449\">update test set a = 2;</p>\n<p updated=\"20220805101449\">将第0号表空间的100号页面的偏移量为1000处的值更新为<code>2</code>。</p>\n</blockquote>\n</li>\n<li id=\"20220805101449-cp9k2ql\" updated=\"20220805101449\">\n<p updated=\"20220805101449\">随机IO刷起来比较慢</p>\n<p updated=\"20220805101449\">这个就更好解决了，把随机IO给弄成顺序IO，磁盘中开辟一块单独的连续空间，就直接写这片空间就好了。</p>\n<p updated=\"20220805101449\">那空间写满了怎么办？重写！</p>\n<blockquote updated=\"20220805101449\">\n<p updated=\"20220805101449\">空间开辟: 0....100</p>\n<p updated=\"20220805101449\">写到100之后，重新从0开始写。只需要做个标记，如果写入的，已经被实实在在的刷到磁盘中了，则这块是可以重写的；否则，MySQL整体阻塞，免得数据出现异常</p>\n</blockquote>\n</li>\n</ol>\n<p updated=\"20220805101449\">　　有了这些手段，即使MySQL重启崩溃了，也仅仅需要从这个顺序空间中将数据的操作给捞出来，进行回放重新更新一下数据页就好了。</p>\n<p updated=\"20220805101449\">　　这个手段，MySQL中已经有了，叫做<code>redo log</code></p>\n<ul updated=\"20220805101449\">\n<li id=\"20220805101449-kxz6biq\" updated=\"20220805101449\">\n<p updated=\"20220805101449\"><code>redo</code>日志占用的空间非常小<br />\n存储表空间ID、页号、偏移量以及需要更新的值所需的存储空间是很小。</p>\n</li>\n<li id=\"20220805101449-pxxdpss\" updated=\"20220805101449\">\n<p updated=\"20220805101449\"><code>redo</code>日志是顺序写入磁盘的<br />\n在执行事务的过程中，每执行一条语句，就可能产生若干条<code>redo</code>日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO。</p>\n</li>\n</ul>\n","articleNode":{"field":{"contentType":"posts","topic":null},"frontmatter":{"id":"/posts/RedoLog诞生史","title":"RedoLog诞生史","date":"2022-07-22 14:09","absolute_path":"/posts/RedoLog诞生史"},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"InnoDB"}]},{"type":"text","value":"存储引擎是通过页为单位对数据进行访问，换句话说对数据库的所有操作都最终会作用到这个页上面。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　但是，磁盘的运行速度远远慢于内存，所以在对这个页操作的时候需要将数据给整到内存中去，来加快增删改查的速度。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　MySQL的设计者设计了了一个叫做"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Buffer Pool"}]},{"type":"text","value":"的存储在内存中的数据结构，用于平衡存储介质和内存之间的速度差异："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"写入时先写入"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Buffer Pool"}]},{"type":"text","value":"中，后刷到磁盘中"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"读取时"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Buffer Pool"}]},{"type":"text","value":"中有完整数据，则直接返回"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Buffer Pool"}]},{"type":"text","value":"中只记录了更改状态，则需要合并磁盘和"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Buffer Pool"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Buffer Pool"}]},{"type":"text","value":"中无数据，进入磁盘查找"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　但是，在这种情况下不错处理会有一个问题，在写入"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Buffer Pool"}]},{"type":"text","value":"成功，但是刷写磁盘时可能由于断电导致没有刷成功，数据出现了丢失。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　需要一个新的数据结构，在事务提交完成之前把事务所修改的页面都刷到磁盘中，但是这个简单粗暴的做法有些问题："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"刷新一个完整的数据页太浪费了"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"InnoDB"}]},{"type":"text","value":"中是以页为单位来进行磁盘IO，事务提交时需要将一个完整的页面从内存中刷新到磁盘。一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太浪费了。这种在存储系统中有个专有的名词 —— 写放大（Write Amplification）"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"随机IO刷起来比较慢"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，事务修改的这些页面在物理磁盘上不相邻，每一次操作前都需要寻址，称之为随机IO"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　针对这两种方式也比较好解决:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"刷新完成数据页浪费"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"那就记录被修改的位置，把修改了哪些东西记录一下就好，比如:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"update test set a = 2;"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"将第0号表空间的100号页面的偏移量为1000处的值更新为"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"2"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"随机IO刷起来比较慢"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这个就更好解决了，把随机IO给弄成顺序IO，磁盘中开辟一块单独的连续空间，就直接写这片空间就好了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"那空间写满了怎么办？重写！"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"空间开辟: 0....100"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"写到100之后，重新从0开始写。只需要做个标记，如果写入的，已经被实实在在的刷到磁盘中了，则这块是可以重写的；否则，MySQL整体阻塞，免得数据出现异常"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　有了这些手段，即使MySQL重启崩溃了，也仅仅需要从这个顺序空间中将数据的操作给捞出来，进行回放重新更新一下数据页就好了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　这个手段，MySQL中已经有了，叫做"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"redo log"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"redo"}]},{"type":"text","value":"日志占用的空间非常小"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n存储表空间ID、页号、偏移量以及需要更新的值所需的存储空间是很小。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"redo"}]},{"type":"text","value":"日志是顺序写入磁盘的"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n在执行事务的过程中，每执行一条语句，就可能产生若干条"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"redo"}]},{"type":"text","value":"日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"　　"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"style","properties":{"className":["grvsc-styles"]},"children":[{"type":"text","value":"\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n"}]}],"data":{"quirksMode":false}},"html":"<p updated=\"20220805101449\">　　<code>InnoDB</code>存储引擎是通过页为单位对数据进行访问，换句话说对数据库的所有操作都最终会作用到这个页上面。</p>\n<p updated=\"20220805101449\">　　但是，磁盘的运行速度远远慢于内存，所以在对这个页操作的时候需要将数据给整到内存中去，来加快增删改查的速度。</p>\n<p updated=\"20220805101449\">　　MySQL的设计者设计了了一个叫做<code>Buffer Pool</code>的存储在内存中的数据结构，用于平衡存储介质和内存之间的速度差异：</p>\n<ul updated=\"20220805101449\">\n<li id=\"20220805101449-7j753tr\" updated=\"20220805101449\">\n<p updated=\"20220805101449\">写入时先写入<code>Buffer Pool</code>中，后刷到磁盘中</p>\n</li>\n<li id=\"20220805101449-xucpza8\" updated=\"20220805101449\">\n<p updated=\"20220805101449\">读取时</p>\n<ul updated=\"20220805101449\">\n<li id=\"20220805101449-2f6dh3c\" updated=\"20220805101449\">\n<p updated=\"20220805101449\"><code>Buffer Pool</code>中有完整数据，则直接返回</p>\n</li>\n<li id=\"20220805101449-wri8sak\" updated=\"20220805101449\">\n<p updated=\"20220805101449\"><code>Buffer Pool</code>中只记录了更改状态，则需要合并磁盘和<code>Buffer Pool</code></p>\n</li>\n<li id=\"20220805101449-wef94pj\" updated=\"20220805101449\">\n<p updated=\"20220805101449\"><code>Buffer Pool</code>中无数据，进入磁盘查找</p>\n</li>\n</ul>\n</li>\n</ul>\n<p updated=\"20220805101449\">　　但是，在这种情况下不错处理会有一个问题，在写入<code>Buffer Pool</code>成功，但是刷写磁盘时可能由于断电导致没有刷成功，数据出现了丢失。</p>\n<p updated=\"20220805101449\">　　需要一个新的数据结构，在事务提交完成之前把事务所修改的页面都刷到磁盘中，但是这个简单粗暴的做法有些问题：</p>\n<ol updated=\"20220805101449\">\n<li id=\"20220805101449-0vhpmhk\" updated=\"20220805101449\">\n<p updated=\"20220805101449\">刷新一个完整的数据页太浪费了</p>\n<p updated=\"20220805101449\"><code>InnoDB</code>中是以页为单位来进行磁盘IO，事务提交时需要将一个完整的页面从内存中刷新到磁盘。一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太浪费了。这种在存储系统中有个专有的名词 —— 写放大（Write Amplification）</p>\n</li>\n<li id=\"20220805101449-te80klu\" updated=\"20220805101449\">\n<p updated=\"20220805101449\">随机IO刷起来比较慢</p>\n<p updated=\"20220805101449\">一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，事务修改的这些页面在物理磁盘上不相邻，每一次操作前都需要寻址，称之为随机IO</p>\n</li>\n</ol>\n<p updated=\"20220805101449\">　　针对这两种方式也比较好解决:</p>\n<ol updated=\"20220805101449\">\n<li id=\"20220805101449-nlzame6\" updated=\"20220805101449\">\n<p updated=\"20220805101449\">刷新完成数据页浪费</p>\n<p updated=\"20220805101449\">那就记录被修改的位置，把修改了哪些东西记录一下就好，比如:</p>\n<blockquote updated=\"20220805101449\">\n<p updated=\"20220805101449\">update test set a = 2;</p>\n<p updated=\"20220805101449\">将第0号表空间的100号页面的偏移量为1000处的值更新为<code>2</code>。</p>\n</blockquote>\n</li>\n<li id=\"20220805101449-cp9k2ql\" updated=\"20220805101449\">\n<p updated=\"20220805101449\">随机IO刷起来比较慢</p>\n<p updated=\"20220805101449\">这个就更好解决了，把随机IO给弄成顺序IO，磁盘中开辟一块单独的连续空间，就直接写这片空间就好了。</p>\n<p updated=\"20220805101449\">那空间写满了怎么办？重写！</p>\n<blockquote updated=\"20220805101449\">\n<p updated=\"20220805101449\">空间开辟: 0....100</p>\n<p updated=\"20220805101449\">写到100之后，重新从0开始写。只需要做个标记，如果写入的，已经被实实在在的刷到磁盘中了，则这块是可以重写的；否则，MySQL整体阻塞，免得数据出现异常</p>\n</blockquote>\n</li>\n</ol>\n<p updated=\"20220805101449\">　　有了这些手段，即使MySQL重启崩溃了，也仅仅需要从这个顺序空间中将数据的操作给捞出来，进行回放重新更新一下数据页就好了。</p>\n<p updated=\"20220805101449\">　　这个手段，MySQL中已经有了，叫做<code>redo log</code></p>\n<ul updated=\"20220805101449\">\n<li id=\"20220805101449-kxz6biq\" updated=\"20220805101449\">\n<p updated=\"20220805101449\"><code>redo</code>日志占用的空间非常小<br />\n存储表空间ID、页号、偏移量以及需要更新的值所需的存储空间是很小。</p>\n</li>\n<li id=\"20220805101449-pxxdpss\" updated=\"20220805101449\">\n<p updated=\"20220805101449\"><code>redo</code>日志是顺序写入磁盘的<br />\n在执行事务的过程中，每执行一条语句，就可能产生若干条<code>redo</code>日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO。</p>\n</li>\n</ul>\n","headings":[],"path":"/posts/RedoLog诞生史"},"headings":[]}},
    "staticQueryHashes": ["630634786","928362550"]}