(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{413:function(t,a,s){"use strict";s.r(a);var v=s(6),_=Object(v.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("多线程的性能问题，分为两类，一类是线程本身的调度，另一类是线程之间的协作开销。")]),t._v(" "),a("h2",{attrs:{id:"线程调度开销"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程调度开销"}},[t._v("#")]),t._v(" 线程调度开销")]),t._v(" "),a("h3",{attrs:{id:"上下文切换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#上下文切换"}},[t._v("#")]),t._v(" 上下文切换")]),t._v(" "),a("p",[t._v("在实际开发中，线程数往往是大于 CPU 核心数的，比如 CPU 核心数可能是 8 核、16 核，等等，但线程数可能达到成百上千个。")]),t._v(" "),a("p",[t._v("这种情况下，操作系统就会按照一定的调度算法，给每个线程分配时间片，让每个线程都有机会得到运行。而在进行调度时就会引起上下文切换，上下文切换会挂起当前正在执行的线程并保存当前的状态，然后寻找下一处即将恢复执行的代码，唤醒下一个线程，以此类推，反复执行。")]),t._v(" "),a("p",[t._v("但上下文切换带来的开销是比较大的，假设我们的任务内容非常短，比如只进行简单的计算，那么就有可能发生我们上下文切换带来的性能开销比执行线程本身内容带来的开销还要大的情况。")]),t._v(" "),a("h3",{attrs:{id:"缓存失效"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存失效"}},[t._v("#")]),t._v(" 缓存失效")]),t._v(" "),a("p",[t._v("由于程序有很大概率会再次访问刚才访问过的数据，所以为了加速整个程序的运行，会使用缓存，这样我们在使用相同数据时就可以很快地获取数据。")]),t._v(" "),a("p",[t._v("可一旦进行了线程调度，切换到其他线程，CPU就会去执行不同的代码，原有的缓存就很可能失效了，需要重新缓存新的数据，这也会造成一定的开销。")]),t._v(" "),a("p",[t._v("所以线程调度器为了避免频繁地发生上下文切换，通常会给被调度到的线程设置最小的执行时间，也就是只有执行完这段时间之后，才可能进行下一次的调度，由此减少上下文切换的次数。")]),t._v(" "),a("p",[t._v("如果程序频繁地竞争锁，或者由于 IO 读写等原因导致频繁阻塞，那么这个程序就可能需要更多的上下文切换，这也就导致了更大的开销，我们应该尽量避免这种情况的发生。")]),t._v(" "),a("h2",{attrs:{id:"协作开销"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协作开销"}},[t._v("#")]),t._v(" 协作开销")]),t._v(" "),a("p",[t._v("因为线程之间如果有共享数据，为了避免数据错乱，为了保证线程安全，就有可能禁止编译器和 CPU 对其进行重排序等优化。")]),t._v(" "),a("p",[t._v("也可能出于同步的目的，反复把线程工作内存的数据 flush 到主存中，然后再从主内存 refresh 到其他线程的工作内存中，等等。")]),t._v(" "),a("p",[t._v("这些问题在单线程中并不存在，但在多线程中为了确保数据的正确性，就不得不采取上述方法，因为线程安全的优先级要比性能优先级更高，这也间接降低了我们的性能。")])])}),[],!1,null,null,null);a.default=_.exports}}]);