{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/RocketMQ/RocketMQ延迟消息原理","result":{"data":{"siYuan":{"excerpt":"RocketMQ延迟消息原理 RocketMQ提供了延迟消息的功能，消息在发送到RocketMQ服务端之后不会马上投递，而是根据消息中的属性延迟固定时间之后才会投递到消费者那。 使用场景 电商里，提交了一个订单就可以发送一个延时消息，1h后...","raw":"# RocketMQ延迟消息原理\n\nRocketMQ提供了延迟消息的功能，消息在发送到RocketMQ服务端之后不会马上投递，而是根据消息中的属性延迟固定时间之后才会投递到消费者那。\n\n# 使用场景\n\n电商里，提交了一个订单就可以发送一个延时消息，1h后去检查这个订单的状态，如果还是未付款就取消订单释放库存。\n\n## 启动消费者等待传入订阅消息\n\n```java\npublic class ScheduledMessageConsumer {\n   public static void main(String[] args) throws Exception {\n      // 实例化消费者\n      DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"ExampleConsumer\");\n      // 订阅Topics\n      consumer.subscribe(\"TestTopic\", \"*\");\n      // 注册消息监听者\n      consumer.registerMessageListener(new MessageListenerConcurrently() {\n          @Override\n          public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> messages, ConsumeConcurrentlyContext context) {\n              for (MessageExt message : messages) {\n                  // Print approximate delay time period\n                  System.out.println(\"Receive message[msgId=\" + message.getMsgId() + \"] \" + (System.currentTimeMillis() - message.getBornTimestamp()) + \"ms later\");\n              }\n              return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n          }\n      });\n      // 启动消费者\n      consumer.start();\n  }\n}\n```\n\n## 发送延迟消息\n\n> 现在RocketMq并不支持任意时间的延时，需要设置几个固定的延时等级，从1s到2h分别对应着等级1到18 消息消费失败会进入延时消息队列，消息发送时间与设置的延时等级和重试次数有关\n>\n\n```java\npublic class ScheduledMessageProducer {\n   public static void main(String[] args) throws Exception {\n      // 实例化一个生产者来产生延时消息\n      DefaultMQProducer producer = new DefaultMQProducer(\"ExampleProducerGroup\");\n      // 启动生产者\n      producer.start();\n      int totalMessagesToSend = 100;\n      for (int i = 0; i < totalMessagesToSend; i++) {\n          Message message = new Message(\"TestTopic\", (\"Hello scheduled message \" + i).getBytes());\n          // 设置延时等级3,这个消息将在10s之后发送(现在只支持固定的几个时间,详看delayTimeLevel)\n          message.setDelayTimeLevel(3);\n          // 发送消息\n          producer.send(message);\n      }\n       // 关闭生产者\n      producer.shutdown();\n  }\n}\n```\n\n# 原理分析\n\nProductor发送没啥好说的，与事务消息队列相比简单太多，与正常发送相比仅仅设置了一个`DelayTimeLevel`的属性。\n\n## broker接收流程\n\n消息从`SendMessageProcessor#asyncProcessRequest` 进来之后，会一步步向下执行\n\n```java\n// SendMessageProcessor.java\n private CompletableFuture<RemotingCommand> asyncSendMessage(ChannelHandlerContext ctx, RemotingCommand request,\n                                                                SendMessageContext mqtraceContext,\n                                                                SendMessageRequestHeader requestHeader) {\n        // ......\n        CompletableFuture<PutMessageResult> putMessageResult = null;\n        String transFlag = origProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);\n        if (transFlag != null && Boolean.parseBoolean(transFlag)) {\n            if (this.brokerController.getBrokerConfig().isRejectTransactionMessage()) {\n                response.setCode(ResponseCode.NO_PERMISSION);\n                response.setRemark(\n                        \"the broker[\" + this.brokerController.getBrokerConfig().getBrokerIP1()\n                                + \"] sending transaction message is forbidden\");\n                return CompletableFuture.completedFuture(response);\n            }\n            //存储事务消息\n            putMessageResult = this.brokerController.getTransactionalMessageService().asyncPrepareMessage(msgInner);\n        } else {\n            //存储普通消息\n            putMessageResult = this.brokerController.getMessageStore().asyncPutMessage(msgInner);\n        }\n        return handlePutMessageResultFuture(putMessageResult, response, request, msgInner, responseHeader, mqtraceContext, ctx, queueIdInt);\n    }\n\n```\n\n然后会调用到`DefaultMessageStore#asyncPutMessage`\n\n```java\n// DefaultMessageStore#asyncPutMessage.java\npublic CompletableFuture<PutMessageResult> asyncPutMessage(MessageExtBrokerInner msg) {\n \t// 检查存储状态：是否关闭、是否slave、是否不可写、写入是否频繁\n        PutMessageStatus checkStoreStatus = this.checkStoreStatus();\n        if (checkStoreStatus != PutMessageStatus.PUT_OK) {\n            return CompletableFuture.completedFuture(new PutMessageResult(checkStoreStatus, null));\n        }\n\t// 检查msg长度是否合法：topic是否超过127、body长度是否超过限定值\n        PutMessageStatus msgCheckStatus = this.checkMessage(msg);\n        if (msgCheckStatus == PutMessageStatus.MESSAGE_ILLEGAL) {\n            return CompletableFuture.completedFuture(new PutMessageResult(msgCheckStatus, null));\n        }\n\n        PutMessageStatus lmqMsgCheckStatus = this.checkLmqMessage(msg);\n        if (msgCheckStatus == PutMessageStatus.LMQ_CONSUME_QUEUE_NUM_EXCEEDED) {\n            return CompletableFuture.completedFuture(new PutMessageResult(lmqMsgCheckStatus, null));\n        }\n\n\n        long beginTime = this.getSystemClock().now();\n\t// 往commitLog中塞入消息（核心！！）\n        CompletableFuture<PutMessageResult> putResultFuture = this.commitLog.asyncPutMessage(msg);\n\n        putResultFuture.thenAccept((result) -> {\n            long elapsedTime = this.getSystemClock().now() - beginTime;\n            if (elapsedTime > 500) {\n                log.warn(\"putMessage not in lock elapsed time(ms)={}, bodyLength={}\", elapsedTime, msg.getBody().length);\n            }\n            this.storeStatsService.setPutMessageEntireTimeMax(elapsedTime);\n\n            if (null == result || !result.isOk()) {\n                this.storeStatsService.getPutMessageFailedTimes().add(1);\n            }\n        });\n\n        return putResultFuture;\n    }\n```\n\n最后通过RocketMQ的`CommitLog`将消息存储起来，延迟消息的秘密也在这里将会得到解答\n\n```java\npublic CompletableFuture<PutMessageResult> asyncPutMessage(final MessageExtBrokerInner msg) {\n\t// .... 省略一些代码\n        if (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE\n                || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) {\n            // 如果设置的延迟等级>0,则表示需要延迟进行推送\n            if (msg.getDelayTimeLevel() > 0) {\n                if (msg.getDelayTimeLevel() > this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) {\n                    msg.setDelayTimeLevel(this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());\n                }\n\n                topic = TopicValidator.RMQ_SYS_SCHEDULE_TOPIC;\n                int queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());\n\n                // 保存真实的Topic和QueueId\n                MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());\n                MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));\n                msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));\n\t\t// 将topic修改成延迟队列的topic\n                msg.setTopic(topic);\n                msg.setQueueId(queueId);\n            }\n        }\n\t// ... 省略一些代码\n    }\n```\n\nRocketMQ实现延迟队列的方式大致和事务消息类似，让消息重写到一个`Consumer`无法监听的`Topic`中，这样就能够将延迟消息给保存下来\n\n## 延迟投递原理\n\n通过IDEA 查看 `TopicValidator#RMQ_SYS_SCHEDULE_TOPIC`,可以发现在`ScheduleMessageService`中有去扫描这个Topic，看这个类名大概也能够猜出，是延迟投递的核心实现类。\n\n\n```java\n// ScheduleMessageService.java\npublic void start() {\n        if (started.compareAndSet(false, true)) {\n            this.load();\n            this.deliverExecutorService = new ScheduledThreadPoolExecutor(this.maxDelayLevel, new ThreadFactoryImpl(\"ScheduleMessageTimerThread_\"));\n            if (this.enableAsyncDeliver) {\n                this.handleExecutorService = new ScheduledThreadPoolExecutor(this.maxDelayLevel, new ThreadFactoryImpl(\"ScheduleMessageExecutorHandleThread_\"));\n            }\n            for (Map.Entry<Integer, Long> entry : this.delayLevelTable.entrySet()) {\n                Integer level = entry.getKey();\n                Long timeDelay = entry.getValue();\n                Long offset = this.offsetTable.get(level);\n                if (null == offset) {\n                    offset = 0L;\n                }\n\n                if (timeDelay != null) {\n                    if (this.enableAsyncDeliver) {\n                        this.handleExecutorService.schedule(new HandlePutResultTask(level), FIRST_DELAY_TIME, TimeUnit.MILLISECONDS);\n                    }\n\t\t    // 启动延迟队列，调度任务\n                    this.deliverExecutorService.schedule(new DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME, TimeUnit.MILLISECONDS);\n                }\n            }\n\n            this.deliverExecutorService.scheduleAtFixedRate(new Runnable() {\n\n                @Override\n                public void run() {\n                    try {\n                        if (started.get()) {\n\t\t\t// 将任务持久化到文件中去\n                            ScheduleMessageService.this.persist();\n                        }\n                    } catch (Throwable e) {\n                        log.error(\"scheduleAtFixedRate flush exception\", e);\n                    }\n                }\n            }, 10000, this.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval(), TimeUnit.MILLISECONDS);\n        }\n    }\n```\n\n通过线程启动了一个`DeliverDelayedMessageTimerTask`来调度延迟消息。\n\n就是通过Java自带的延迟队列，来掉队队列中的消息，满足时间了则进行投递，将定时任务的Topic中移除，放入它原本的Topic中。\n\n这样客户端就能够接收到消息的信息。\n\n# 总结\n\n* producer端设置消息delayLevel延迟级别，消息属性DELAY中存储了对应了延时级别\n* broker端收到消息后，判断延时消息延迟级别，如果大于0，则备份消息原始topic，queueId，并将消息topic改为延时消息队列特定topic(SCHEDULE_TOPIC)，queueId改为延时级别-1\n* mq服务端ScheduleMessageService中，为每一个延迟级别单独设置一个定时器，定时(每隔1秒)拉取对应延迟级别的消费队列\n* 根据消费偏移量offset从commitLog中解析出对应消息\n* 从消息tagsCode中解析出消息应当被投递的时间，与当前时间做比较，判断是否应该进行投递\n* 若到达了投递时间，则构建一个新的消息，并从消息属性中恢复出原始的topic，queueId，并清除消息延迟属性，从新进行消息投递\n","field":{"slug":"/posts/RocketMQ/RocketMQ延迟消息原理"},"frontmatter":{"title":"RocketMQ延迟消息原理","tags":["RocketMQ"],"date":"2022-05-06","description":"RocketMQ延迟消息原理 RocketMQ提供了延迟消息的功能，消息在发送到RocketMQ服务端之后不会马上投递，而是根据消息中的属性延迟固定时间之后才会投递到消费者那。 使用场景 电商里，提交了一个订单就可以发送一个延时消息，1h后..."}},"prev":{"frontmatter":{"title":"RocketMQ持久化原理"},"field":{"slug":"/posts/RocketMQ/RocketMQ持久化原理"}},"next":{"frontmatter":{"title":"RocketMQ事务消息实现原理"},"field":{"slug":"/posts/RocketMQ/RocketMQ事务消息实现原理"}}},"pageContext":{"slug":"/posts/RocketMQ/RocketMQ延迟消息原理","prevSlug":"/posts/RocketMQ/RocketMQ持久化原理","nextSlug":"/posts/RocketMQ/RocketMQ事务消息实现原理"}},"staticQueryHashes":["1284643331","2841359383"]}