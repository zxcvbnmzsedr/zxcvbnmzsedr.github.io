{"componentChunkName":"component---src-templates-topic-post-template-js","path":"/topic/Java并发工具包/并发工具/并发容器/HashMap","result":{"data":{"siYuan":{"excerpt":"HashMap 下面说的是1.8下的HashMap HashMap实现原理 img HashMap采用Entry数组来存储key-value键值对，每个键值对组成了Node的实体，Node是一个单向链表的结构，具有next指针，指向下一个N...","raw":"# HashMap\n\n下面说的是1.8下的HashMap\n\n## HashMap实现原理\n\n![img](https://www.shiyitopo.tech/uPic/e4a19398.png)\n\nHashMap采用Entry数组来存储key-value键值对，每个键值对组成了Node的实体，Node是一个单向链表的结构，具有next指针，指向下一个Node实体。\n\n在链表长度>8的时候，链表会转换成为红黑树。\n\n**为什么用数组+链表的方式**\n\n数组是用来确定桶的位置，也就是链表的头节点所在的位置。\n\n这个位置是通过Key的Hash值，对数组长度取模得到。链表的作用是用来解决Hash冲突的问题，当出现Hash值一样的情形，就再数组的对应位置上形成一条链表。这种方法被称之为链地址法\n\n**用LinkedList代理数组结构可以么**\n\n可以的。\n\n**为什么HashMap不用LinkedList,而选用数组?**\n\n因为用数组效率最高！LinkedList的查找时间复杂度是O(n),而数组是O(1)\n\n在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到。此时，我们已得到桶的位置。\n\n显然数组的查找效率比LinkedList大。\n\n**那ArrayList，底层也是数组，查找也快啊，为啥不用ArrayList?**\n\n因为采用基本数组结构，扩容机制可以自己定义，HashMap中数组扩容刚好是2的次幂，在做取模运算的效率高,\n\n 而ArrayList的扩容机制是1.5倍扩容。\n\n**数组的长度是有限的,在什么情况下会进行扩容**\n\n如果bucket满了，超过了 **threshold** 的时候进行扩容，扩容的容量是之前的两倍。\n\nNode[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。\n\n默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。\n\n**为什么扩容是2的次幂**\n\n哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数。\n\nHashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。\n\nHashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高16位异或去参与运算的过程，减少碰撞。\n\n这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。\n\n## 功能实现\n\nHashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。\n\n### 1. 确定哈希桶数组索引位置\n\n不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):\n\n```java\n方法一：\nstatic final int hash(Object key) {   //jdk1.8 & jdk1.7\n     int h;\n     // h = key.hashCode() 为第一步 取hashCode值\n     // h ^ (h >>> 16)  为第二步 高位参与运算\n     return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n方法二：\nstatic int indexFor(int h, int length) {  //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的\n     return h & (length-1);  //第三步 取模运算\n}\n```\n\n这里的Hash算法本质上就是三步：**取key的hashCode值、高位运算、取模运算**。\n\n对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。\n\n这个方法非常巧妙，它通过h & (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h& (length-1)运算等价于对length取模，也就是h%length，但是&比%具有更高的效率。\n\n在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h >>> 16)，主要是从速度、功效、质量来考虑的，这么做可以在\b数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。\n\n下面举例说明下，n为table的长度。\n\n![img](https://www.shiyitopo.tech/uPic/45205ec2.png)\n\n#### 2. 分析HashMap的put方法\n\n![img](https://www.shiyitopo.tech/uPic/d669d29c.png)\n\n①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；\n\n②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，\b转向③；\n\n③.判断\btable[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；\n\n ④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；\n\n⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；\b遍历过程中若发现key已经存在直接覆盖value即可；\n\n⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。\n\n### 3. 扩容机制\n\n扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。\n\n我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。\n\n```java\n 1 void resize(int newCapacity) {   //传入新的容量\n 2     Entry[] oldTable = table;    //引用扩容前的Entry数组\n 3     int oldCapacity = oldTable.length;         \n 4     if (oldCapacity == MAXIMUM_CAPACITY) {  //扩容前的数组大小如果已经达到最大(2^30)了\n 5         threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了\n 6         return;\n 7     }\n 8  \n 9     Entry[] newTable = new Entry[newCapacity];  //初始化一个新的Entry数组\n10     transfer(newTable);                         //！！将数据转移到新的Entry数组里\n11     table = newTable;                           //HashMap的table属性引用新的Entry数组\n12     threshold = (int)(newCapacity * loadFactor);//修改阈值\n13 }\n```\n\n这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。\n\n```\n 1 void transfer(Entry[] newTable) {\n 2     Entry[] src = table;                   //src引用了旧的Entry数组\n 3     int newCapacity = newTable.length;\n 4     for (int j = 0; j < src.length; j++) { //遍历旧的Entry数组\n 5         Entry<K,V> e = src[j];             //取得旧Entry数组的每个元素\n 6         if (e != null) {\n 7             src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）\n 8             do {\n 9                 Entry<K,V> next = e.next;\n10                 int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置\n11                 e.next = newTable[i]; //标记[1]\n12                 newTable[i] = e;      //将元素放在数组上\n13                 e = next;             //访问下一个Entry链上的元素\n14             } while (e != null);\n15         }\n16     }\n17 } \n```\n\nnewTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。\n\n下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的\b哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。\n\n![img](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/b2330062.png)\n\n下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。\n\n![img](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/4d8022db.png)\n\n元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：\n\n![img](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/d773f86e.png)\n\n因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：\n\n![img](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/3cc9813a.png)\n\n这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下:\n\n```java\n 1 final Node<K,V>[] resize() {\n 2     Node<K,V>[] oldTab = table;\n 3     int oldCap = (oldTab == null) ? 0 : oldTab.length;\n 4     int oldThr = threshold;\n 5     int newCap, newThr = 0;\n 6     if (oldCap > 0) {\n 7         // 超过最大值就不再扩充了，就只好随你碰撞去吧\n 8         if (oldCap >= MAXIMUM_CAPACITY) {\n 9             threshold = Integer.MAX_VALUE;\n10             return oldTab;\n11         }\n12         // 没超过最大值，就扩充为原来的2倍\n13         else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n14                  oldCap >= DEFAULT_INITIAL_CAPACITY)\n15             newThr = oldThr << 1; // double threshold\n16     }\n17     else if (oldThr > 0) // initial capacity was placed in threshold\n18         newCap = oldThr;\n19     else {               // zero initial threshold signifies using defaults\n20         newCap = DEFAULT_INITIAL_CAPACITY;\n21         newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n22     }\n23     // 计算新的resize上限\n24     if (newThr == 0) {\n25 \n26         float ft = (float)newCap * loadFactor;\n27         newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n28                   (int)ft : Integer.MAX_VALUE);\n29     }\n30     threshold = newThr;\n31     @SuppressWarnings({\"rawtypes\"，\"unchecked\"})\n32         Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n33     table = newTab;\n34     if (oldTab != null) {\n35         // 把每个bucket都移动到新的buckets中\n36         for (int j = 0; j < oldCap; ++j) {\n37             Node<K,V> e;\n38             if ((e = oldTab[j]) != null) {\n39                 oldTab[j] = null;\n40                 if (e.next == null)\n41                     newTab[e.hash & (newCap - 1)] = e;\n42                 else if (e instanceof TreeNode)\n43                     ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n44                 else { // 链表优化重hash的代码块\n45                     Node<K,V> loHead = null, loTail = null;\n46                     Node<K,V> hiHead = null, hiTail = null;\n47                     Node<K,V> next;\n48                     do {\n49                         next = e.next;\n50                         // 原索引\n51                         if ((e.hash & oldCap) == 0) {\n52                             if (loTail == null)\n53                                 loHead = e;\n54                             else\n55                                 loTail.next = e;\n56                             loTail = e;\n57                         }\n58                         // 原索引+oldCap\n59                         else {\n60                             if (hiTail == null)\n61                                 hiHead = e;\n62                             else\n63                                 hiTail.next = e;\n64                             hiTail = e;\n65                         }\n66                     } while ((e = next) != null);\n67                     // 原索引放到bucket里\n68                     if (loTail != null) {\n69                         loTail.next = null;\n70                         newTab[j] = loHead;\n71                     }\n72                     // 原索引+oldCap放到bucket里\n73                     if (hiTail != null) {\n74                         hiTail.next = null;\n75                         newTab[j + oldCap] = hiHead;\n76                     }\n77                 }\n78             }\n79         }\n80     }\n81     return newTab;\n82 }\n```\n\n### 为什么hashmap的在链表元素数量超过8时改为红黑树?\n\n**知道jdk1.8中hashmap改了啥么?**\n\n- 由**数组+链表**的结构改为**数组+链表+红黑树**。\n- 优化了高位运算的hash算法：h^(h>>>16)\n- 扩容后，元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表顺序不变。\n\n**为什么在解决hash冲突的时候，不直接用红黑树?而选择先用链表，再转红黑树?**\n\n因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。 当元素小于8个当时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于8个的时候，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。\n\n因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。\n\n**那为什么阀值是8呢?**\n\n如果 hashCode 分布良好，也就是 hash 计算的结果离散好的话，那么红黑树这种形式是很少会被用到的，因为各个值都均匀分布，很少出现链表很长的情况。在理想情况下，链表长度符合泊松分布，各个长度的命中概率依次递减，当长度为 8 的时候，概率仅为 0.00000006。这是一个小于千万分之一的概率，通常我们的 Map 里面是不会存储这么多的数据的，所以通常情况下，并不会发生从链表向红黑树的转换。\n\n**当链表转为红黑树后，什么时候退化为链表?**\n\n为6的时候退转为链表。中间有个差值7可以防止链表和树之间频繁的转换。\n\n假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。\n\n## 线程安全性\n\nJDK 1.8 进行了环链的修复。但还是避免在多线程环境下使用，就比如size 是通过++size() 来进行计算的，多线程下必然出现问题。\n\n**java1.8解决环链的方式**\n\n声明两对指针，维护两个连链表\n\n依次在末端添加新的元素。（在多线程操作的情况下，无非是第二个线程重复第一个线程一模一样的操作）\n\n**java1.7下的坑**\n\n在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：\n\n```java\npublic class HashMapInfiniteLoop {  \n\n    private static HashMap<Integer,String> map = new HashMap<Integer,String>(2，0.75f);  \n    public static void main(String[] args) {  \n        map.put(5， \"C\");  \n\n        new Thread(\"Thread1\") {  \n            public void run() {  \n                map.put(7, \"B\");  \n                System.out.println(map);  \n            };  \n        }.start();  \n        new Thread(\"Thread2\") {  \n            public void run() {  \n                map.put(3, \"A);  \n                System.out.println(map);  \n            };  \n        }.start();        \n    }  \n} \n```\n\n其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。\n\n通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。\n\n![img](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/7df99266.png)\n\n注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。\n\n线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。\n\n![img](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/4c3c28fb.png)\n\n![img](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/6c8d086a.png)\n\ne.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。\n\n![img](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/6eed9aaf.png)\n\n于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。\n\n参考: https://tech.meituan.com/2016/06/24/java-hashmap.html\n","html":"<div></div>","field":{"slug":"/topic/Java并发工具包/并发工具/并发容器/HashMap","topic":"Java并发工具包"},"frontmatter":{"title":"HashMap","tags":["Java并发工具包","并发工具","并发容器"],"date":"2022-04-21","description":"HashMap 下面说的是1.8下的HashMap HashMap实现原理 img HashMap采用Entry数组来存储key-value键值对，每个键值对组成了Node的实体，Node是一个单向链表的结构，具有next指针，指向下一个N..."}},"topic":{"title":"Java并发工具包","tree":"{\"title\":\"Java并发工具包\",\"id\":\"20220421194022-szu21fl\",\"parentId\":\"\",\"href\":\"/topic/Java并发工具包\",\"path\":\"/topic/Java并发工具包\",\"children\":[{\"title\":\"并发基础\",\"id\":\"20220421224325-jcq08lp\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发基础\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发基础\",\"parentPath\":\"/topic/Java并发工具包\",\"sort\":1,\"children\":[{\"title\":\"线程基础\",\"id\":\"20220421224347-8pq9978\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础\",\"parentPath\":\"/topic/Java并发工具包/并发基础\",\"sort\":1,\"children\":[{\"title\":\"Thread的状态\",\"id\":\"20220421194023-ol9lplx\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"sort\":1,\"children\":[{\"title\":\"New\",\"id\":\"20220421194023-mz6u7e3\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态#New\",\"parentId\":\"20220421194023-ol9lplx\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4},{\"title\":\"Runable\",\"id\":\"20220421194023-i5j5kt4\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态#Runable\",\"parentId\":\"20220421194023-ol9lplx\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4},{\"title\":\"阻塞态\",\"id\":\"20220421194023-tboo24c\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态#阻塞态\",\"parentId\":\"20220421194023-ol9lplx\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[{\"title\":\"Block\",\"id\":\"20220421194023-ffozdtq\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态#Block\",\"parentId\":\"20220421194023-tboo24c\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":5},{\"title\":\"Timed Watting\",\"id\":\"20220421194023-8wsfgft\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态#Timed Watting\",\"parentId\":\"20220421194023-tboo24c\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"Watting\",\"id\":\"20220421194023-dlwp21r\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态#Watting\",\"parentId\":\"20220421194023-ol9lplx\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"进程与线程\",\"id\":\"20220421194024-2gxhyjq\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/进程与线程\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/进程与线程\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"sort\":2,\"children\":[{\"title\":\"概述\",\"id\":\"20220421194024-ch040n5\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/进程与线程#概述\",\"parentId\":\"20220421194024-2gxhyjq\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/进程与线程\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"正确停止线程的方式\",\"id\":\"20220421194024-frmfw7a\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"sort\":3,\"children\":[{\"title\":\"废弃的停止方式\",\"id\":\"20220421194024-ghx55hh\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式#废弃的停止方式\",\"parentId\":\"20220421194024-frmfw7a\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[{\"title\":\"Thread.stop和suspend被废弃的原因\",\"id\":\"20220421194024-c7u9s2m\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式#Thread.stop和suspend被废弃的原因\",\"parentId\":\"20220421194024-ghx55hh\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":5},{\"title\":\"volatile标记停止位的错误\",\"id\":\"20220421194024-9ucarn0\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式#volatile标记停止位的错误\",\"parentId\":\"20220421194024-ghx55hh\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"正确的停止方式\",\"id\":\"20220421194024-0r7ntu4\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式#正确的停止方式\",\"parentId\":\"20220421194024-frmfw7a\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[{\"title\":\"通过interrupt方式停止\",\"id\":\"20220421194024-98z6tro\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式#通过interrupt方式停止\",\"parentId\":\"20220421194024-0r7ntu4\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"所以Java中如何正确的停止线程\",\"id\":\"20220421194024-stvj48i\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式#所以Java中如何正确的停止线程\",\"parentId\":\"20220421194024-frmfw7a\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[{\"title\":\"答题思路\",\"id\":\"20220421194024-w3nwz6h\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式#答题思路\",\"parentId\":\"20220421194024-stvj48i\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"Thread的实现方式\",\"id\":\"20220421194023-v6obecl\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"sort\":4,\"children\":[{\"title\":\"实现Runable接口\",\"id\":\"20220421194023-vrnazbw\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式#实现Runable接口\",\"parentId\":\"20220421194023-v6obecl\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4},{\"title\":\"直接继承Thread\",\"id\":\"20220421194023-id80wie\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式#直接继承Thread\",\"parentId\":\"20220421194023-v6obecl\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4},{\"title\":\"用线程池创建线程\",\"id\":\"20220421194023-7pse6e4\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式#用线程池创建线程\",\"parentId\":\"20220421194023-v6obecl\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4},{\"title\":\"使用Callable方式创建\",\"id\":\"20220421194023-w1w9u8x\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式#使用Callable方式创建\",\"parentId\":\"20220421194023-v6obecl\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4},{\"title\":\"使用Timer\",\"id\":\"20220421194023-pgfiig8\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式#使用Timer\",\"parentId\":\"20220421194023-v6obecl\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4},{\"title\":\"本质?\",\"id\":\"20220421194023-k7hn4oq\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式#本质?\",\"parentId\":\"20220421194023-v6obecl\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"waitnotifynotifyAll\",\"id\":\"20220421194023-1yi0nux\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/waitnotifynotifyAll\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/waitnotifynotifyAll\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"sort\":5,\"children\":[{\"title\":\"为什么wait必须在synchronized保护的代码中使用\",\"id\":\"20220421194023-giwl4bj\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/waitnotifynotifyAll#为什么wait必须在synchronized保护的代码中使用\",\"parentId\":\"20220421194023-1yi0nux\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/waitnotifynotifyAll\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4},{\"title\":\"为什么 wait/notify/notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？\",\"id\":\"20220421194023-xaxtdxr\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/waitnotifynotifyAll#为什么 wait/notify/notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？\",\"parentId\":\"20220421194023-1yi0nux\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/waitnotifynotifyAll\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4},{\"title\":\"wait/notify 和 sleep 方法的异同？\",\"id\":\"20220421194023-6kelqj2\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/waitnotifynotifyAll#wait/notify 和 sleep 方法的异同？\",\"parentId\":\"20220421194023-1yi0nux\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/waitnotifynotifyAll\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"生产者消费者模型\",\"id\":\"20220421194024-s4r7b6l\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/生产者消费者模型\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/生产者消费者模型\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"sort\":6,\"children\":[{\"title\":\"生产者消费者模式\",\"id\":\"20220421194024-85fpsgz\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/生产者消费者模型#生产者消费者模式\",\"parentId\":\"20220421194024-s4r7b6l\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/生产者消费者模型\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4},{\"title\":\"使用 BlockingQueue 实现生产者消费者模式\",\"id\":\"20220421194024-xhyv35y\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/生产者消费者模型#使用 BlockingQueue 实现生产者消费者模式\",\"parentId\":\"20220421194024-s4r7b6l\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/生产者消费者模型\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4},{\"title\":\"使用 Condition 实现生产者消费者模式\",\"id\":\"20220421194024-l0y6haz\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/生产者消费者模型#使用 Condition 实现生产者消费者模式\",\"parentId\":\"20220421194024-s4r7b6l\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/生产者消费者模型\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4},{\"title\":\"使用 wait/notify 实现生产者消费者模式\",\"id\":\"20220421194024-41f5dyn\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/生产者消费者模型#使用 wait/notify 实现生产者消费者模式\",\"parentId\":\"20220421194024-s4r7b6l\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/生产者消费者模型\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"线程安全\",\"id\":\"20220421224600-95safof\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础\",\"sort\":2,\"children\":[{\"title\":\"线程不安全\",\"id\":\"20220421194024-ixgv706\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程不安全\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程不安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"sort\":1,\"children\":[{\"title\":\"线程不安全示例\",\"id\":\"20220421194024-pu2r1id\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程不安全#线程不安全示例\",\"parentId\":\"20220421194024-ixgv706\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程不安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"线程安全\",\"id\":\"20220421194024-p4q4kvp\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"sort\":7,\"children\":[{\"title\":\"什么是线程安全问题\",\"id\":\"20220421194024-s2yzr20\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#什么是线程安全问题\",\"parentId\":\"20220421194024-p4q4kvp\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":4},{\"title\":\"为何会出现线程安全问题\",\"id\":\"20220421194024-qq259d6\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#为何会出现线程安全问题\",\"parentId\":\"20220421194024-p4q4kvp\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[{\"title\":\"可见性: CPU缓存引起\",\"id\":\"20220421194024-1hqax8a\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#可见性: CPU缓存引起\",\"parentId\":\"20220421194024-qq259d6\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":5},{\"title\":\"原子性: 分时复用引起\",\"id\":\"20220421194024-vr80zol\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#原子性: 分时复用引起\",\"parentId\":\"20220421194024-qq259d6\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":5},{\"title\":\"有序性: 重排序引起\",\"id\":\"20220421194024-uv6bi5r\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#有序性: 重排序引起\",\"parentId\":\"20220421194024-qq259d6\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"一共有哪三类线程安全问题\",\"id\":\"20220421194024-qv6fwxn\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#一共有哪三类线程安全问题\",\"parentId\":\"20220421194024-p4q4kvp\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[{\"title\":\"运行结果错误\",\"id\":\"20220421194024-zg45j9j\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#运行结果错误\",\"parentId\":\"20220421194024-qv6fwxn\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":5},{\"title\":\"发布和初始化导致线程安全问题\",\"id\":\"20220421194024-82nb2py\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#发布和初始化导致线程安全问题\",\"parentId\":\"20220421194024-qv6fwxn\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":5},{\"title\":\"活跃性问题\",\"id\":\"20220421194024-l06bdd0\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#活跃性问题\",\"parentId\":\"20220421194024-qv6fwxn\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[{\"title\":\"死锁\",\"id\":\"20220421194024-xzamyko\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#死锁\",\"parentId\":\"20220421194024-l06bdd0\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[{\"title\":\"产生死锁的原因主要是：\",\"id\":\"20220421194024-jg853ka\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#产生死锁的原因主要是：\",\"parentId\":\"20220421194024-xzamyko\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":7},{\"title\":\"产生死锁的四个必要条件：\",\"id\":\"20220421194024-tka1tzp\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#产生死锁的四个必要条件：\",\"parentId\":\"20220421194024-xzamyko\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":7},{\"title\":\"死锁的解除与预防：\",\"id\":\"20220421194024-g4hr3e1\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#死锁的解除与预防：\",\"parentId\":\"20220421194024-xzamyko\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":7}],\"level\":6},{\"title\":\"活锁\",\"id\":\"20220421194024-e63z48p\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#活锁\",\"parentId\":\"20220421194024-l06bdd0\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":6},{\"title\":\"饥饿\",\"id\":\"20220421194024-48utpac\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#饥饿\",\"parentId\":\"20220421194024-l06bdd0\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":6}],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"需要注意线程安全问题的情况\",\"id\":\"20220421194024-rijyr8z\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/需要注意线程安全问题的情况\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/需要注意线程安全问题的情况\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"sort\":17,\"children\":[{\"title\":\"访问共享变量或资源\",\"id\":\"20220421194024-qsnh4er\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/需要注意线程安全问题的情况#访问共享变量或资源\",\"parentId\":\"20220421194024-rijyr8z\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/需要注意线程安全问题的情况\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":4},{\"title\":\"依赖时序的操作\",\"id\":\"20220421194024-r428t3a\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/需要注意线程安全问题的情况#依赖时序的操作\",\"parentId\":\"20220421194024-rijyr8z\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/需要注意线程安全问题的情况\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":4},{\"title\":\"对方没有声明自己是线程安全的\",\"id\":\"20220421194024-rkeg2mj\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/需要注意线程安全问题的情况#对方没有声明自己是线程安全的\",\"parentId\":\"20220421194024-rijyr8z\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/需要注意线程安全问题的情况\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2}],\"level\":1},{\"title\":\"并发工具\",\"id\":\"20220421224648-bow8i92\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具\",\"parentPath\":\"/topic/Java并发工具包\",\"sort\":2,\"children\":[{\"title\":\"线程协作\",\"id\":\"20220421225409-vum430h\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作\",\"parentPath\":\"/topic/Java并发工具包/并发工具\",\"sort\":1,\"children\":[{\"title\":\"Semaphore信号量\",\"id\":\"20220421194023-zk5fktn\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/Semaphore信号量\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/Semaphore信号量\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"sort\":2,\"children\":[{\"title\":\"介绍\",\"id\":\"20220421194023-6x46it5\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/Semaphore信号量#介绍\",\"parentId\":\"20220421194023-zk5fktn\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/Semaphore信号量\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":4},{\"title\":\"限流实现\",\"id\":\"20220421194023-zkr7ktt\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/Semaphore信号量#限流实现\",\"parentId\":\"20220421194023-zk5fktn\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/Semaphore信号量\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":4},{\"title\":\"思考: FixedThreadPool可以替代Semaphore么?\",\"id\":\"20220421194023-cffzkvl\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/Semaphore信号量#思考: FixedThreadPool可以替代Semaphore么?\",\"parentId\":\"20220421194023-zk5fktn\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/Semaphore信号量\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"CountDownLatch详解\",\"id\":\"20220421194023-m0tc081\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/CountDownLatch详解\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/CountDownLatch详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"sort\":16,\"children\":[{\"title\":\"介绍\",\"id\":\"20220421194023-kbbcxbl\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/CountDownLatch详解#介绍\",\"parentId\":\"20220421194023-m0tc081\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/CountDownLatch详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"使用CompletableFuture解决旅游平台问题\",\"id\":\"20220421194023-7xbmrhw\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"sort\":27,\"children\":[{\"title\":\"旅游平台问题介绍\",\"id\":\"20220421194023-7f92nei\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题#旅游平台问题介绍\",\"parentId\":\"20220421194023-7xbmrhw\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[{\"title\":\"串行获取\",\"id\":\"20220421194023-xtl2a45\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题#串行获取\",\"parentId\":\"20220421194023-7f92nei\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":5},{\"title\":\"并行获取\",\"id\":\"20220421194023-kuctn4p\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题#并行获取\",\"parentId\":\"20220421194023-7f92nei\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"使用线程池实现\",\"id\":\"20220421194023-ipafk28\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题#使用线程池实现\",\"parentId\":\"20220421194023-7xbmrhw\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":4},{\"title\":\"CountDownLatch\",\"id\":\"20220421194023-yhiuvd1\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题#CountDownLatch\",\"parentId\":\"20220421194023-7xbmrhw\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":4},{\"title\":\"CompletableFuture\",\"id\":\"20220421194023-uyxclzb\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题#CompletableFuture\",\"parentId\":\"20220421194023-7xbmrhw\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"使用CyclicBarrier解决团建问题\",\"id\":\"20220421194023-2t11ew0\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"sort\":30,\"children\":[{\"title\":\"团建问题介绍\",\"id\":\"20220421194023-eubfypd\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题#团建问题介绍\",\"parentId\":\"20220421194023-2t11ew0\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":4},{\"title\":\"模拟场景\",\"id\":\"20220421194023-ths6hk3\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题#模拟场景\",\"parentId\":\"20220421194023-2t11ew0\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":4},{\"title\":\"CyclicBarrier 和 CountDownLatch 的异同\",\"id\":\"20220421194023-w7mli0h\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题#CyclicBarrier 和 CountDownLatch 的异同\",\"parentId\":\"20220421194023-2t11ew0\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[{\"title\":\"相同点\",\"id\":\"20220421194023-ha0hs5i\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题#相同点\",\"parentId\":\"20220421194023-w7mli0h\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":5},{\"title\":\"不同点\",\"id\":\"20220421194023-5khi9b8\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题#不同点\",\"parentId\":\"20220421194023-w7mli0h\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[{\"title\":\"作用对象不同\",\"id\":\"20220421194023-6ka48ra\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题#作用对象不同\",\"parentId\":\"20220421194023-5khi9b8\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":6},{\"title\":\"可重用性不同\",\"id\":\"20220421194023-hpyerj6\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题#可重用性不同\",\"parentId\":\"20220421194023-5khi9b8\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":6},{\"title\":\"执行动作不同\",\"id\":\"20220421194023-xpadrxw\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题#执行动作不同\",\"parentId\":\"20220421194023-5khi9b8\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":6}],\"level\":5}],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"Future\",\"id\":\"20220421225357-mgk8fm8\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/Future\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/Future\",\"parentPath\":\"/topic/Java并发工具包/并发工具\",\"sort\":2,\"children\":[{\"title\":\"Future主要功能\",\"id\":\"20220421194023-tc7cnvu\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"sort\":2,\"children\":[{\"title\":\"Future接口\",\"id\":\"20220421194023-vy1iaus\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能#Future接口\",\"parentId\":\"20220421194023-tc7cnvu\",\"path\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[{\"title\":\"cancel方法: 取消任务执行\",\"id\":\"20220421194023-2p9j49p\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能#cancel方法: 取消任务执行\",\"parentId\":\"20220421194023-vy1iaus\",\"path\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[],\"level\":5},{\"title\":\"isCancelled() 方法:判断是否被取消\",\"id\":\"20220421194023-abekw76\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能#isCancelled() 方法:判断是否被取消\",\"parentId\":\"20220421194023-vy1iaus\",\"path\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[],\"level\":5},{\"title\":\"isDown():判断是否执行完毕\",\"id\":\"20220421194023-n3gtv77\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能#isDown():判断是否执行完毕\",\"parentId\":\"20220421194023-vy1iaus\",\"path\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[],\"level\":5},{\"title\":\"get(): 获取结果\",\"id\":\"20220421194023-4rsknhp\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能#get(): 获取结果\",\"parentId\":\"20220421194023-vy1iaus\",\"path\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"基础实现\",\"id\":\"20220421194023-vd9seqp\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能#基础实现\",\"parentId\":\"20220421194023-tc7cnvu\",\"path\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[{\"title\":\"FutureTask示例\",\"id\":\"20220421194023-gptncr7\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能#FutureTask示例\",\"parentId\":\"20220421194023-vd9seqp\",\"path\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"FutureTask源码分析\",\"id\":\"20220421194023-lcf6hel\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"sort\":3,\"children\":[{\"title\":\"核心属性\",\"id\":\"20220421194023-b1jl1as\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析#核心属性\",\"parentId\":\"20220421194023-lcf6hel\",\"path\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[],\"level\":4},{\"title\":\"构造函数\",\"id\":\"20220421194023-6ga3tdq\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析#构造函数\",\"parentId\":\"20220421194023-lcf6hel\",\"path\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[],\"level\":4},{\"title\":\"核心方法：Run()\",\"id\":\"20220421194023-wmuyfw2\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析#核心方法：Run()\",\"parentId\":\"20220421194023-lcf6hel\",\"path\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[],\"level\":4},{\"title\":\"核心方法:get()\",\"id\":\"20220421194023-hqg3oz2\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析#核心方法:get()\",\"parentId\":\"20220421194023-lcf6hel\",\"path\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[],\"level\":4},{\"title\":\"核心方法:awaitDone(boolean timed,long nanos)\",\"id\":\"20220421194023-5kudbjb\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析#核心方法:awaitDone(boolean timed,long nanos)\",\"parentId\":\"20220421194023-lcf6hel\",\"path\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[],\"level\":4},{\"title\":\"核心方法:Cancel()\",\"id\":\"20220421194023-z9yspi4\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析#核心方法:Cancel()\",\"parentId\":\"20220421194023-lcf6hel\",\"path\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"ThreadLocal\",\"id\":\"20220421225340-rez89hu\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/ThreadLocal\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/ThreadLocal\",\"parentPath\":\"/topic/Java并发工具包/并发工具\",\"sort\":3,\"children\":[{\"title\":\"ThreadLocal内存泄漏\",\"id\":\"20220421194023-skqpi80\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal内存泄漏\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal内存泄漏\",\"parentPath\":\"/topic/Java并发工具包/并发工具/ThreadLocal\",\"sort\":18,\"children\":[{\"title\":\"ThreadLocal的实现原理\",\"id\":\"20220421194023-8fje0qn\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal内存泄漏#ThreadLocal的实现原理\",\"parentId\":\"20220421194023-skqpi80\",\"path\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal内存泄漏\",\"parentPath\":\"/topic/Java并发工具包/并发工具/ThreadLocal\",\"children\":[],\"level\":4},{\"title\":\"内存泄漏的案例\",\"id\":\"20220421194023-kzn89ie\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal内存泄漏#内存泄漏的案例\",\"parentId\":\"20220421194023-skqpi80\",\"path\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal内存泄漏\",\"parentPath\":\"/topic/Java并发工具包/并发工具/ThreadLocal\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"ThreadLocal使用场景\",\"id\":\"20220421194023-5y0rwt1\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal使用场景\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal使用场景\",\"parentPath\":\"/topic/Java并发工具包/并发工具/ThreadLocal\",\"sort\":28,\"children\":[{\"title\":\"保存线程不安全的工具类\",\"id\":\"20220421194023-ip2bddc\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal使用场景#保存线程不安全的工具类\",\"parentId\":\"20220421194023-5y0rwt1\",\"path\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal使用场景\",\"parentPath\":\"/topic/Java并发工具包/并发工具/ThreadLocal\",\"children\":[],\"level\":4},{\"title\":\"传递全局变量\",\"id\":\"20220421194023-4h7hbuz\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal使用场景#传递全局变量\",\"parentId\":\"20220421194023-5y0rwt1\",\"path\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal使用场景\",\"parentPath\":\"/topic/Java并发工具包/并发工具/ThreadLocal\",\"children\":[],\"level\":4},{\"title\":\"面试题: ThreadLocal是用来解决共享资源的多线程访问吗?\",\"id\":\"20220421194023-jbeie1n\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal使用场景#面试题: ThreadLocal是用来解决共享资源的多线程访问吗?\",\"parentId\":\"20220421194023-5y0rwt1\",\"path\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal使用场景\",\"parentPath\":\"/topic/Java并发工具包/并发工具/ThreadLocal\",\"children\":[{\"title\":\"ThreadLocal 和 synchronized 是什么关系\",\"id\":\"20220421194023-9j0pf34\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal使用场景#ThreadLocal 和 synchronized 是什么关系\",\"parentId\":\"20220421194023-jbeie1n\",\"path\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal使用场景\",\"parentPath\":\"/topic/Java并发工具包/并发工具/ThreadLocal\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"原子类\",\"id\":\"20220421225252-idqz1wx\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/原子类\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/原子类\",\"parentPath\":\"/topic/Java并发工具包/并发工具\",\"sort\":4,\"children\":[{\"title\":\"原子类的作用概览\",\"id\":\"20220421194024-q0d2887\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"sort\":1,\"children\":[{\"title\":\"什么是原子类，有什么作用\",\"id\":\"20220421194024-i2dwj9d\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览#什么是原子类，有什么作用\",\"parentId\":\"20220421194024-q0d2887\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":4},{\"title\":\"原子类概览\",\"id\":\"20220421194024-pbmtb0x\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览#原子类概览\",\"parentId\":\"20220421194024-q0d2887\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[{\"title\":\"原子更新基本类型\",\"id\":\"20220421194024-bkoixwz\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览#原子更新基本类型\",\"parentId\":\"20220421194024-pbmtb0x\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":5},{\"title\":\"原子更新数组\",\"id\":\"20220421194024-3llb9j7\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览#原子更新数组\",\"parentId\":\"20220421194024-pbmtb0x\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":5},{\"title\":\"原子更新引用类型\",\"id\":\"20220421194024-3iezmq2\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览#原子更新引用类型\",\"parentId\":\"20220421194024-pbmtb0x\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":5},{\"title\":\"原子更新字段\",\"id\":\"20220421194024-1vf6ovf\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览#原子更新字段\",\"parentId\":\"20220421194024-pbmtb0x\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":5},{\"title\":\"Adder 加法器和Accumulator积累器\",\"id\":\"20220421194024-uit0km0\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览#Adder 加法器和Accumulator积累器\",\"parentId\":\"20220421194024-pbmtb0x\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[{\"title\":\"Adder介绍\",\"id\":\"20220421194024-h82jb7t\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览#Adder介绍\",\"parentId\":\"20220421194024-uit0km0\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":6},{\"title\":\"Accumulator介绍\",\"id\":\"20220421194024-8fqd15u\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览#Accumulator介绍\",\"parentId\":\"20220421194024-uit0km0\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":6},{\"title\":\"拓展功能\",\"id\":\"20220421194024-dym8r6k\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览#拓展功能\",\"parentId\":\"20220421194024-uit0km0\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":6},{\"title\":\"适用场景\",\"id\":\"20220421194024-y140gog\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览#适用场景\",\"parentId\":\"20220421194024-uit0km0\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":6}],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"原子类的性能分析\",\"id\":\"20220421194024-x4a73dp\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的性能分析\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的性能分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"sort\":5,\"children\":[{\"title\":\"AtomicLong的问题\",\"id\":\"20220421194024-23koi5c\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的性能分析#AtomicLong的问题\",\"parentId\":\"20220421194024-x4a73dp\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的性能分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":4},{\"title\":\"升级版LongAdder\",\"id\":\"20220421194024-up05t2j\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的性能分析#升级版LongAdder\",\"parentId\":\"20220421194024-x4a73dp\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的性能分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":4},{\"title\":\"如何选择\",\"id\":\"20220421194024-zsum368\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的性能分析#如何选择\",\"parentId\":\"20220421194024-x4a73dp\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的性能分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[{\"title\":\"AtomicLong 可否被 LongAdder 替代？\",\"id\":\"20220421194024-1dx3jlm\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的性能分析#AtomicLong 可否被 LongAdder 替代？\",\"parentId\":\"20220421194024-zsum368\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的性能分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"结论\",\"id\":\"20220421194024-ifiji7o\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的性能分析#结论\",\"parentId\":\"20220421194024-x4a73dp\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的性能分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"阻塞队列\",\"id\":\"20220421225150-nu224ql\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具\",\"sort\":5,\"children\":[{\"title\":\"常见的阻塞队列\",\"id\":\"20220421194024-9ltr7q3\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"sort\":1,\"children\":[{\"title\":\"ArrayBlockingQueue\",\"id\":\"20220421194024-5nxnstz\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列#ArrayBlockingQueue\",\"parentId\":\"20220421194024-9ltr7q3\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":4},{\"title\":\"LinkedBlockingQueue\",\"id\":\"20220421194024-2anxh67\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列#LinkedBlockingQueue\",\"parentId\":\"20220421194024-9ltr7q3\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":4},{\"title\":\"SynchronousQueue\",\"id\":\"20220421194024-5dmd94t\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列#SynchronousQueue\",\"parentId\":\"20220421194024-9ltr7q3\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":4},{\"title\":\"PriorityBlockingQueue\",\"id\":\"20220421194024-0qkwqym\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列#PriorityBlockingQueue\",\"parentId\":\"20220421194024-9ltr7q3\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":4},{\"title\":\"DelayQueue\",\"id\":\"20220421194024-gwhbp1l\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列#DelayQueue\",\"parentId\":\"20220421194024-9ltr7q3\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":4},{\"title\":\"如何选择\",\"id\":\"20220421194024-bbafwco\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列#如何选择\",\"parentId\":\"20220421194024-9ltr7q3\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[{\"title\":\"线程池对于阻塞队列的选择\",\"id\":\"20220421194024-wfrhink\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列#线程池对于阻塞队列的选择\",\"parentId\":\"20220421194024-bbafwco\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5},{\"title\":\"归纳\",\"id\":\"20220421194024-oncdnpz\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列#归纳\",\"parentId\":\"20220421194024-bbafwco\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"阻塞队列的常用方法\",\"id\":\"20220421194024-f1qdcm3\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"sort\":2,\"children\":[{\"title\":\"第一组：add、remove、element\",\"id\":\"20220421194024-6fq31g5\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#第一组：add、remove、element\",\"parentId\":\"20220421194024-f1qdcm3\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[{\"title\":\"add 方法\",\"id\":\"20220421194024-hw2svfq\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#add 方法\",\"parentId\":\"20220421194024-6fq31g5\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5},{\"title\":\"remove 方法\",\"id\":\"20220421194024-1vkhstt\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#remove 方法\",\"parentId\":\"20220421194024-6fq31g5\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5},{\"title\":\"element 方法\",\"id\":\"20220421194024-5kr6svs\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#element 方法\",\"parentId\":\"20220421194024-6fq31g5\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"第二组：offer、poll、peek\",\"id\":\"20220421194024-cel6bgj\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#第二组：offer、poll、peek\",\"parentId\":\"20220421194024-f1qdcm3\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[{\"title\":\"offer 方法\",\"id\":\"20220421194024-5wzpseg\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#offer 方法\",\"parentId\":\"20220421194024-cel6bgj\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5},{\"title\":\"poll 方法\",\"id\":\"20220421194024-818miy8\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#poll 方法\",\"parentId\":\"20220421194024-cel6bgj\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5},{\"title\":\"peek 方法\",\"id\":\"20220421194024-ym52mns\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#peek 方法\",\"parentId\":\"20220421194024-cel6bgj\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5},{\"title\":\"带超时时间的 offer 和 poll\",\"id\":\"20220421194024-zlxgydf\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#带超时时间的 offer 和 poll\",\"parentId\":\"20220421194024-cel6bgj\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5},{\"title\":\"第三组：put、take\",\"id\":\"20220421194024-s1x6qky\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#第三组：put、take\",\"parentId\":\"20220421194024-cel6bgj\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5},{\"title\":\"put 方法\",\"id\":\"20220421194024-udcplfa\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#put 方法\",\"parentId\":\"20220421194024-cel6bgj\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5},{\"title\":\"take 方法\",\"id\":\"20220421194024-zinhklk\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#take 方法\",\"parentId\":\"20220421194024-cel6bgj\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"总结\",\"id\":\"20220421194024-egm4xgr\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#总结\",\"parentId\":\"20220421194024-f1qdcm3\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"什么是阻塞队列\",\"id\":\"20220421194023-4d0fgjl\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/什么是阻塞队列\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/什么是阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"sort\":29,\"children\":[{\"title\":\"阻塞队列的作用\",\"id\":\"20220421194023-ct89u9n\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/什么是阻塞队列#阻塞队列的作用\",\"parentId\":\"20220421194023-4d0fgjl\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/什么是阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":4},{\"title\":\"主要并发队列关系图\",\"id\":\"20220421194023-4gdg5oq\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/什么是阻塞队列#主要并发队列关系图\",\"parentId\":\"20220421194023-4d0fgjl\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/什么是阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":4},{\"title\":\"阻塞队列的特点\",\"id\":\"20220421194023-yvfdoea\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/什么是阻塞队列#阻塞队列的特点\",\"parentId\":\"20220421194023-4d0fgjl\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/什么是阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[{\"title\":\"是否有界（容量有多大）\",\"id\":\"20220421194023-thwd1kf\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/什么是阻塞队列#是否有界（容量有多大）\",\"parentId\":\"20220421194023-yvfdoea\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/什么是阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"并发容器\",\"id\":\"20220421225042-g34phsd\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器\",\"parentPath\":\"/topic/Java并发工具包/并发工具\",\"sort\":6,\"children\":[{\"title\":\"HashMap\",\"id\":\"20220421194023-chqzo14\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"sort\":1,\"children\":[{\"title\":\"HashMap实现原理\",\"id\":\"20220421194023-kqco0df\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap#HashMap实现原理\",\"parentId\":\"20220421194023-chqzo14\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":4},{\"title\":\"功能实现\",\"id\":\"20220421194023-c7q57es\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap#功能实现\",\"parentId\":\"20220421194023-chqzo14\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[{\"title\":\"1. 确定哈希桶数组索引位置\",\"id\":\"20220421194023-pna9o0r\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap#1. 确定哈希桶数组索引位置\",\"parentId\":\"20220421194023-c7q57es\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[{\"title\":\"2. 分析HashMap的put方法\",\"id\":\"20220421194023-r988dwu\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap#2. 分析HashMap的put方法\",\"parentId\":\"20220421194023-pna9o0r\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":6}],\"level\":5},{\"title\":\"3. 扩容机制\",\"id\":\"20220421194023-x0skg7v\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap#3. 扩容机制\",\"parentId\":\"20220421194023-c7q57es\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"为什么hashmap的在链表元素数量超过8时改为红黑树?\",\"id\":\"20220421194023-6azroph\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap#为什么hashmap的在链表元素数量超过8时改为红黑树?\",\"parentId\":\"20220421194023-c7q57es\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"线程安全性\",\"id\":\"20220421194023-hc9vfve\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap#线程安全性\",\"parentId\":\"20220421194023-chqzo14\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"CopyOnWriteArrayList\",\"id\":\"20220421194022-gkzupas\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"sort\":34,\"children\":[{\"title\":\"特点\",\"id\":\"20220421194022-xhc42v3\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#特点\",\"parentId\":\"20220421194022-gkzupas\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":4},{\"title\":\"复制修改\",\"id\":\"20220421194022-f6dagmk\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#复制修改\",\"parentId\":\"20220421194022-gkzupas\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[{\"title\":\"迭代期间允许修改集合内容\",\"id\":\"20220421194022-8p51kd9\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#迭代期间允许修改集合内容\",\"parentId\":\"20220421194022-f6dagmk\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"缺点\",\"id\":\"20220421194022-wei24tc\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#缺点\",\"parentId\":\"20220421194022-gkzupas\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[{\"title\":\"内存占用大\",\"id\":\"20220421194022-vt8lr1s\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#内存占用大\",\"parentId\":\"20220421194022-wei24tc\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"元素较多或者复杂的情况下，复制的开销大\",\"id\":\"20220421194022-1i2c7pa\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#元素较多或者复杂的情况下，复制的开销大\",\"parentId\":\"20220421194022-wei24tc\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"数据一致性无法保证\",\"id\":\"20220421194022-ap6n3fh\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#数据一致性无法保证\",\"parentId\":\"20220421194022-wei24tc\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"只适合读多写少的场景\",\"id\":\"20220421194022-sc0eogs\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#只适合读多写少的场景\",\"parentId\":\"20220421194022-wei24tc\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"源码分析\",\"id\":\"20220421194022-rp1fvlk\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#源码分析\",\"parentId\":\"20220421194022-gkzupas\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[{\"title\":\"数据结构\",\"id\":\"20220421194022-ols3w10\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#数据结构\",\"parentId\":\"20220421194022-rp1fvlk\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"add方法\",\"id\":\"20220421194022-jfyru3k\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#add方法\",\"parentId\":\"20220421194022-rp1fvlk\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"get操作\",\"id\":\"20220421194022-0i2nkyh\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#get操作\",\"parentId\":\"20220421194022-rp1fvlk\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"迭代器COWIterator类\",\"id\":\"20220421194022-8cd7t0h\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#迭代器COWIterator类\",\"parentId\":\"20220421194022-rp1fvlk\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"ConcurrentHashMap详解\",\"id\":\"20220421194022-5ml6ohm\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"sort\":35,\"children\":[{\"title\":\"ConcurrentHashMap_JDK7\",\"id\":\"20220421194022-6zgzl9m\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#ConcurrentHashMap_JDK7\",\"parentId\":\"20220421194022-5ml6ohm\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[{\"title\":\"数据结构\",\"id\":\"20220421194022-sk8dfnt\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#数据结构\",\"parentId\":\"20220421194022-6zgzl9m\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"初始化\",\"id\":\"20220421194022-g7elxkv\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#初始化\",\"parentId\":\"20220421194022-6zgzl9m\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"初始化\",\"id\":\"20220421194022-yxirnxp\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#初始化\",\"parentId\":\"20220421194022-6zgzl9m\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"put过程分析\",\"id\":\"20220421194022-9gz36tc\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#put过程分析\",\"parentId\":\"20220421194022-6zgzl9m\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"初始化槽: ensureSegment\",\"id\":\"20220421194022-rneyw0q\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#初始化槽: ensureSegment\",\"parentId\":\"20220421194022-6zgzl9m\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"获取写入锁-scanandlockforput\",\"id\":\"20220421194022-s2nr2es\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#获取写入锁-scanandlockforput\",\"parentId\":\"20220421194022-6zgzl9m\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"扩容-rehash\",\"id\":\"20220421194022-yqejgid\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#扩容-rehash\",\"parentId\":\"20220421194022-6zgzl9m\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"get 过程分析\",\"id\":\"20220421194022-b31z8ro\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#get 过程分析\",\"parentId\":\"20220421194022-6zgzl9m\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"并发问题分析\",\"id\":\"20220421194022-3aiwwre\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#并发问题分析\",\"parentId\":\"20220421194022-6zgzl9m\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"ConcurrentHashMap_JDK8\",\"id\":\"20220421194022-9m25zzz\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#ConcurrentHashMap_JDK8\",\"parentId\":\"20220421194022-5ml6ohm\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[{\"title\":\"put 方法源码分析\",\"id\":\"20220421194022-n3u48ll\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#put 方法源码分析\",\"parentId\":\"20220421194022-9m25zzz\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"get 方法源码分析\",\"id\":\"20220421194022-snon8lc\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#get 方法源码分析\",\"parentId\":\"20220421194022-9m25zzz\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"对比Java7 和Java8 的异同和优缺点\",\"id\":\"20220421194022-5t06zk3\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#对比Java7 和Java8 的异同和优缺点\",\"parentId\":\"20220421194022-5ml6ohm\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[{\"title\":\"并发度\",\"id\":\"20220421194022-56z19kf\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#并发度\",\"parentId\":\"20220421194022-5t06zk3\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"保证并发安全的原理\",\"id\":\"20220421194022-unwfvqu\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#保证并发安全的原理\",\"parentId\":\"20220421194022-5t06zk3\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"遇到 Hash 碰撞\",\"id\":\"20220421194022-k1yvu6g\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#遇到 Hash 碰撞\",\"parentId\":\"20220421194022-5t06zk3\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"查询时间复杂度\",\"id\":\"20220421194022-k703vus\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#查询时间复杂度\",\"parentId\":\"20220421194022-5t06zk3\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"线程池\",\"id\":\"20220421224850-czk1iq2\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/线程池\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/线程池\",\"parentPath\":\"/topic/Java并发工具包/并发工具\",\"sort\":7,\"children\":[{\"title\":\"为什么多线程会带来性能问题\",\"id\":\"20220421194023-n21nz3d\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/为什么多线程会带来性能问题\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/为什么多线程会带来性能问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"sort\":1,\"children\":[{\"title\":\"线程调度开销\",\"id\":\"20220421194023-zlthf6f\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/为什么多线程会带来性能问题#线程调度开销\",\"parentId\":\"20220421194023-n21nz3d\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/为什么多线程会带来性能问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[{\"title\":\"上下文切换\",\"id\":\"20220421194023-ampsejl\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/为什么多线程会带来性能问题#上下文切换\",\"parentId\":\"20220421194023-zlthf6f\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/为什么多线程会带来性能问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5},{\"title\":\"缓存失效\",\"id\":\"20220421194023-gxegw5b\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/为什么多线程会带来性能问题#缓存失效\",\"parentId\":\"20220421194023-zlthf6f\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/为什么多线程会带来性能问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"协作开销\",\"id\":\"20220421194023-kqso0jm\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/为什么多线程会带来性能问题#协作开销\",\"parentId\":\"20220421194023-n21nz3d\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/为什么多线程会带来性能问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"线程池的优势\",\"id\":\"20220421194024-vgrsujq\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/线程池的优势\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/线程池的优势\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"sort\":2,\"children\":[{\"title\":\"如何提升运行效率\",\"id\":\"20220421194024-6y78ao9\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/线程池的优势#如何提升运行效率\",\"parentId\":\"20220421194024-vgrsujq\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/线程池的优势\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":4},{\"title\":\"使用线程池的好处\",\"id\":\"20220421194024-x77rkxj\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/线程池的优势#使用线程池的好处\",\"parentId\":\"20220421194024-vgrsujq\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/线程池的优势\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":4},{\"title\":\"线程池的思想\",\"id\":\"20220421194024-yyqzh03\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/线程池的优势#线程池的思想\",\"parentId\":\"20220421194024-vgrsujq\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/线程池的优势\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"创建线程池的参数\",\"id\":\"20220421194024-djxcl5s\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"sort\":3,\"children\":[{\"title\":\"参数列表\",\"id\":\"20220421194024-b671uhp\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数#参数列表\",\"parentId\":\"20220421194024-djxcl5s\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":4},{\"title\":\"创建时机\",\"id\":\"20220421194024-7lyw2w7\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数#创建时机\",\"parentId\":\"20220421194024-djxcl5s\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":4},{\"title\":\"线程工厂ThreadFactory\",\"id\":\"20220421194024-nogaxlu\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数#线程工厂ThreadFactory\",\"parentId\":\"20220421194024-djxcl5s\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":4},{\"title\":\"工作队列WorkQueue\",\"id\":\"20220421194024-4kcqxyc\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数#工作队列WorkQueue\",\"parentId\":\"20220421194024-djxcl5s\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":4},{\"title\":\"拒绝策略Handler\",\"id\":\"20220421194024-zl2siby\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数#拒绝策略Handler\",\"parentId\":\"20220421194024-djxcl5s\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[{\"title\":\"DiscardPolicy\",\"id\":\"20220421194024-vtchp4t\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数#DiscardPolicy\",\"parentId\":\"20220421194024-zl2siby\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5},{\"title\":\"DiscardOldestPolicy\",\"id\":\"20220421194024-d1a21wu\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数#DiscardOldestPolicy\",\"parentId\":\"20220421194024-zl2siby\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5},{\"title\":\"CallerRunsPolicy\",\"id\":\"20220421194024-sm0r1i3\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数#CallerRunsPolicy\",\"parentId\":\"20220421194024-zl2siby\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5},{\"title\":\"AbortPolicy\",\"id\":\"20220421194024-9wiz58a\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数#AbortPolicy\",\"parentId\":\"20220421194024-zl2siby\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"如何设置线程数\",\"id\":\"20220429164341-mzc6839\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数/如何设置线程数\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数/如何设置线程数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"children\":[{\"title\":\"现有的解决方案\",\"id\":\"20220429164831-97mzysk\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数/如何设置线程数#现有的解决方案\",\"parentId\":\"20220429164341-mzc6839\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数/如何设置线程数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"children\":[],\"level\":5},{\"title\":\"动态更新的原理\",\"id\":\"20220429165540-guqhe26\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数/如何设置线程数#动态更新的原理\",\"parentId\":\"20220429164341-mzc6839\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数/如何设置线程数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"children\":[],\"level\":5},{\"title\":\"面试考点\",\"id\":\"20220429171440-0qcp4m7\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数/如何设置线程数#面试考点\",\"parentId\":\"20220429164341-mzc6839\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数/如何设置线程数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"线程池线程复用原理\",\"id\":\"20220421194024-csc9ehx\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/线程池线程复用原理\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/线程池线程复用原理\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"sort\":4,\"children\":[{\"title\":\"实现方式\",\"id\":\"20220421194024-vpwln3p\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/线程池线程复用原理#实现方式\",\"parentId\":\"20220421194024-csc9ehx\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/线程池线程复用原理\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":4},{\"title\":\"总结\",\"id\":\"20220421194024-717ovf1\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/线程池线程复用原理#总结\",\"parentId\":\"20220421194024-csc9ehx\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/线程池线程复用原理\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"ForkJoin框架\",\"id\":\"20220421194023-elf7igk\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"sort\":5,\"children\":[{\"title\":\"案例?\",\"id\":\"20220421194023-tzg5g35\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架#案例?\",\"parentId\":\"20220421194023-elf7igk\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":4},{\"title\":\"原理\",\"id\":\"20220421194023-syy1lho\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架#原理\",\"parentId\":\"20220421194023-elf7igk\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[{\"title\":\"work-stealing 工作窃取\",\"id\":\"20220421194023-av4fqp8\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架#work-stealing 工作窃取\",\"parentId\":\"20220421194023-syy1lho\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5},{\"title\":\"执行流程\",\"id\":\"20220421194023-2lsmwfw\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架#执行流程\",\"parentId\":\"20220421194023-syy1lho\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5},{\"title\":\"步骤分解\",\"id\":\"20220421194023-ziwpdpr\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架#步骤分解\",\"parentId\":\"20220421194023-syy1lho\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5},{\"title\":\"外部任务提交\",\"id\":\"20220421194023-bcns9vl\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架#外部任务提交\",\"parentId\":\"20220421194023-syy1lho\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5},{\"title\":\"子任务提交\",\"id\":\"20220421194023-dnjdw7f\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架#子任务提交\",\"parentId\":\"20220421194023-syy1lho\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5},{\"title\":\"执行任务\",\"id\":\"20220421194023-xf41cyy\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架#执行任务\",\"parentId\":\"20220421194023-syy1lho\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5},{\"title\":\"获取任务执行结果\",\"id\":\"20220421194023-adsuwll\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架#获取任务执行结果\",\"parentId\":\"20220421194023-syy1lho\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"各种锁\",\"id\":\"20220421224921-0q4b1mn\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具\",\"sort\":9,\"children\":[{\"title\":\"锁的种类和特点\",\"id\":\"20220421194024-5l8t6o8\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"sort\":2,\"children\":[{\"title\":\"偏向锁/轻量级锁/重量级锁\",\"id\":\"20220421194024-h5c55jn\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点#偏向锁/轻量级锁/重量级锁\",\"parentId\":\"20220421194024-5l8t6o8\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"可重入锁/不可重入锁\",\"id\":\"20220421194024-psvbp68\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点#可重入锁/不可重入锁\",\"parentId\":\"20220421194024-5l8t6o8\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"共享锁/独占锁\",\"id\":\"20220421194024-huov0bn\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点#共享锁/独占锁\",\"parentId\":\"20220421194024-5l8t6o8\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"公平锁/非公平锁\",\"id\":\"20220421194024-moj8qbg\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点#公平锁/非公平锁\",\"parentId\":\"20220421194024-5l8t6o8\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"乐观锁/悲观锁\",\"id\":\"20220421194024-kd10zrr\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点#乐观锁/悲观锁\",\"parentId\":\"20220421194024-5l8t6o8\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"自旋锁/非自旋锁\",\"id\":\"20220421194024-mxhbm3r\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点#自旋锁/非自旋锁\",\"parentId\":\"20220421194024-5l8t6o8\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"不可中断锁/可中断锁\",\"id\":\"20220421194024-n17hmsj\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点#不可中断锁/可中断锁\",\"parentId\":\"20220421194024-5l8t6o8\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"公平锁非公平锁\",\"id\":\"20220421194024-ysp8l1x\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/公平锁非公平锁\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/公平锁非公平锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"sort\":1,\"children\":[{\"title\":\"特点\",\"id\":\"20220421194024-611w97c\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/公平锁非公平锁#特点\",\"parentId\":\"20220421194024-ysp8l1x\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/公平锁非公平锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5},{\"title\":\"案例\",\"id\":\"20220421194024-nzgiykj\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/公平锁非公平锁#案例\",\"parentId\":\"20220421194024-ysp8l1x\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/公平锁非公平锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5},{\"title\":\"源码\",\"id\":\"20220421194024-1bh92oa\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/公平锁非公平锁#源码\",\"parentId\":\"20220421194024-ysp8l1x\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/公平锁非公平锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"自旋锁非自旋锁\",\"id\":\"20220421194024-yg8yxap\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/自旋锁非自旋锁\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/自旋锁非自旋锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"sort\":4,\"children\":[{\"title\":\"对比自旋和非自旋获取锁的流程\",\"id\":\"20220421194024-xy6eth3\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/自旋锁非自旋锁#对比自旋和非自旋获取锁的流程\",\"parentId\":\"20220421194024-yg8yxap\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/自旋锁非自旋锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5},{\"title\":\"自旋锁的好处\",\"id\":\"20220421194024-p0fl9am\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/自旋锁非自旋锁#自旋锁的好处\",\"parentId\":\"20220421194024-yg8yxap\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/自旋锁非自旋锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5},{\"title\":\"自旋锁的缺点\",\"id\":\"20220421194024-x747q9w\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/自旋锁非自旋锁#自旋锁的缺点\",\"parentId\":\"20220421194024-yg8yxap\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/自旋锁非自旋锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5},{\"title\":\"适用场景\",\"id\":\"20220421194024-ntoqquk\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/自旋锁非自旋锁#适用场景\",\"parentId\":\"20220421194024-yg8yxap\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/自旋锁非自旋锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"共享锁独占锁\",\"id\":\"20220421194024-pfoblt6\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"sort\":7,\"children\":[{\"title\":\"读写锁的规则\",\"id\":\"20220421194024-inct3ng\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁#读写锁的规则\",\"parentId\":\"20220421194024-pfoblt6\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5},{\"title\":\"使用方式\",\"id\":\"20220421194024-viyhwby\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁#使用方式\",\"parentId\":\"20220421194024-pfoblt6\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5},{\"title\":\"加锁原理分析\",\"id\":\"20220421194024-5584v3u\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁#加锁原理分析\",\"parentId\":\"20220421194024-pfoblt6\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5},{\"title\":\"插队逻辑\",\"id\":\"20220421194024-kzrefev\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁#插队逻辑\",\"parentId\":\"20220421194024-pfoblt6\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[{\"title\":\"第一种策略：允许插队\",\"id\":\"20220421194024-xtt9bo3\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁#第一种策略：允许插队\",\"parentId\":\"20220421194024-kzrefev\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":6},{\"title\":\"第二种策略：不允许插队\",\"id\":\"20220421194024-vab8sxx\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁#第二种策略：不允许插队\",\"parentId\":\"20220421194024-kzrefev\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":6}],\"level\":5},{\"title\":\"锁的升降级\",\"id\":\"20220421194024-qy1rjr6\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁#锁的升降级\",\"parentId\":\"20220421194024-pfoblt6\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[{\"title\":\"降级的过程\",\"id\":\"20220421194024-agdihem\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁#降级的过程\",\"parentId\":\"20220421194024-qy1rjr6\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":6},{\"title\":\"为什么需要锁的降级\",\"id\":\"20220421194024-x3i0wc5\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁#为什么需要锁的降级\",\"parentId\":\"20220421194024-qy1rjr6\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":6},{\"title\":\"为什么不支持锁的升级？\",\"id\":\"20220421194024-93vneo7\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁#为什么不支持锁的升级？\",\"parentId\":\"20220421194024-qy1rjr6\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":6},{\"title\":\"总结\",\"id\":\"20220421194024-3qkx6j2\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁#总结\",\"parentId\":\"20220421194024-qy1rjr6\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":6}],\"level\":5}],\"level\":4},{\"title\":\"乐观锁和悲观锁\",\"id\":\"20220421194023-puex63d\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/乐观锁和悲观锁\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/乐观锁和悲观锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"sort\":17,\"children\":[{\"title\":\"悲观锁\",\"id\":\"20220421194023-7zp2dq3\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/乐观锁和悲观锁#悲观锁\",\"parentId\":\"20220421194023-puex63d\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/乐观锁和悲观锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5},{\"title\":\"乐观锁\",\"id\":\"20220421194023-5cy6qa6\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/乐观锁和悲观锁#乐观锁\",\"parentId\":\"20220421194023-puex63d\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/乐观锁和悲观锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5},{\"title\":\"典型案例\",\"id\":\"20220421194023-i4p0a7q\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/乐观锁和悲观锁#典型案例\",\"parentId\":\"20220421194023-puex63d\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/乐观锁和悲观锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[{\"title\":\"“汝之蜜糖,彼之砒霜”\",\"id\":\"20220421194023-f8m3kwp\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/乐观锁和悲观锁#“汝之蜜糖,彼之砒霜”\",\"parentId\":\"20220421194023-i4p0a7q\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/乐观锁和悲观锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":6}],\"level\":5},{\"title\":\"两种锁各自的使用场景\",\"id\":\"20220421194023-j635qa4\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/乐观锁和悲观锁#两种锁各自的使用场景\",\"parentId\":\"20220421194023-puex63d\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/乐观锁和悲观锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"JVM锁优化\",\"id\":\"20220421194023-mm3wc10\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/JVM锁优化\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/JVM锁优化\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"sort\":3,\"children\":[{\"title\":\"锁消除\",\"id\":\"20220421194023-2f7z9mm\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/JVM锁优化#锁消除\",\"parentId\":\"20220421194023-mm3wc10\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/JVM锁优化\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"锁粗化\",\"id\":\"20220421194023-fi45rtd\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/JVM锁优化#锁粗化\",\"parentId\":\"20220421194023-mm3wc10\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/JVM锁优化\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"自适应锁自旋\",\"id\":\"20220421194023-nvjn9oa\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/JVM锁优化#自适应锁自旋\",\"parentId\":\"20220421194023-mm3wc10\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/JVM锁优化\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"偏向锁/轻量级锁/重量级锁\",\"id\":\"20220421194023-vvlkzjy\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/JVM锁优化#偏向锁/轻量级锁/重量级锁\",\"parentId\":\"20220421194023-mm3wc10\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/JVM锁优化\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"synchronized加锁流程\",\"id\":\"20220421194023-1sgv6fy\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/JVM锁优化#synchronized加锁流程\",\"parentId\":\"20220421194023-mm3wc10\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/JVM锁优化\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"synchronized和Lock的对比\",\"id\":\"20220421194023-wyopjqc\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"sort\":4,\"children\":[{\"title\":\"相同点\",\"id\":\"20220421194023-e50jqat\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比#相同点\",\"parentId\":\"20220421194023-wyopjqc\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[{\"title\":\"用来保护资源安全\",\"id\":\"20220421194023-vhkm2qj\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比#用来保护资源安全\",\"parentId\":\"20220421194023-e50jqat\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":5},{\"title\":\"都可以保证可见性\",\"id\":\"20220421194023-kpu3pnr\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比#都可以保证可见性\",\"parentId\":\"20220421194023-e50jqat\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":5},{\"title\":\"都可重入\",\"id\":\"20220421194023-fj4p7u3\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比#都可重入\",\"parentId\":\"20220421194023-e50jqat\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"不同点\",\"id\":\"20220421194023-9ocihrd\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比#不同点\",\"parentId\":\"20220421194023-wyopjqc\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[{\"title\":\"用法不同\",\"id\":\"20220421194023-dl0g00i\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比#用法不同\",\"parentId\":\"20220421194023-9ocihrd\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":5},{\"title\":\"加解锁顺序不同\",\"id\":\"20220421194023-z0uqrwg\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比#加解锁顺序不同\",\"parentId\":\"20220421194023-9ocihrd\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":5},{\"title\":\"synchronized锁不够灵活\",\"id\":\"20220421194023-pmdkjn0\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比#synchronized锁不够灵活\",\"parentId\":\"20220421194023-9ocihrd\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":5},{\"title\":\"synchronized锁同时只能被一个线程拥有，Lock没有这个限制\",\"id\":\"20220421194023-nrovusq\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比#synchronized锁同时只能被一个线程拥有，Lock没有这个限制\",\"parentId\":\"20220421194023-9ocihrd\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":5},{\"title\":\"是否可以设置公平锁\",\"id\":\"20220421194023-jfaipd8\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比#是否可以设置公平锁\",\"parentId\":\"20220421194023-9ocihrd\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":5},{\"title\":\"性能区别\",\"id\":\"20220421194023-sv8z5a5\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比#性能区别\",\"parentId\":\"20220421194023-9ocihrd\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"如何选择\",\"id\":\"20220421194023-migtiov\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比#如何选择\",\"parentId\":\"20220421194023-wyopjqc\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"lock的常用方法\",\"id\":\"20220421194023-d5u43he\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"sort\":33,\"children\":[{\"title\":\"lock()\",\"id\":\"20220421194023-09n3cif\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法#lock()\",\"parentId\":\"20220421194023-d5u43he\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"tryLock()\",\"id\":\"20220421194023-fi99szk\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法#tryLock()\",\"parentId\":\"20220421194023-d5u43he\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"tryLock(long time, TimeUnit unit)\",\"id\":\"20220421194023-s7bytjl\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法#tryLock(long time, TimeUnit unit)\",\"parentId\":\"20220421194023-d5u43he\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"lockInterruptibly()\",\"id\":\"20220421194023-npz5jti\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法#lockInterruptibly()\",\"parentId\":\"20220421194023-d5u43he\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"unlock()\",\"id\":\"20220421194023-y6p4poo\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法#unlock()\",\"parentId\":\"20220421194023-d5u43he\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"newCondition()\",\"id\":\"20220421194023-sughpnb\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法#newCondition()\",\"parentId\":\"20220421194023-d5u43he\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2}],\"level\":1},{\"title\":\"底层原理\",\"id\":\"20220421225546-i01zemh\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/底层原理\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/底层原理\",\"parentPath\":\"/topic/Java并发工具包\",\"sort\":3,\"children\":[{\"title\":\"CAS原理\",\"id\":\"20220421194022-1yd15d4\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/底层原理/CAS原理\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/底层原理/CAS原理\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"sort\":1,\"children\":[{\"title\":\"CAS介绍\",\"id\":\"20220421194022-jdia9lk\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/CAS原理#CAS介绍\",\"parentId\":\"20220421194022-1yd15d4\",\"path\":\"/topic/Java并发工具包/底层原理/CAS原理\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":3},{\"title\":\"CAS的思路\",\"id\":\"20220421194022-fyvsc3v\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/CAS原理#CAS的思路\",\"parentId\":\"20220421194022-1yd15d4\",\"path\":\"/topic/Java并发工具包/底层原理/CAS原理\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":3},{\"title\":\"使用示例\",\"id\":\"20220421194022-3x34oxp\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/CAS原理#使用示例\",\"parentId\":\"20220421194022-1yd15d4\",\"path\":\"/topic/Java并发工具包/底层原理/CAS原理\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":3},{\"title\":\"CAS的问题\",\"id\":\"20220421194022-h6qtglq\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/CAS原理#CAS的问题\",\"parentId\":\"20220421194022-1yd15d4\",\"path\":\"/topic/Java并发工具包/底层原理/CAS原理\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[{\"title\":\"ABA问题\",\"id\":\"20220421194022-bag4cfb\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/CAS原理#ABA问题\",\"parentId\":\"20220421194022-h6qtglq\",\"path\":\"/topic/Java并发工具包/底层原理/CAS原理\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":4},{\"title\":\"循环时间长开销大\",\"id\":\"20220421194022-pttbrtt\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/CAS原理#循环时间长开销大\",\"parentId\":\"20220421194022-h6qtglq\",\"path\":\"/topic/Java并发工具包/底层原理/CAS原理\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":4},{\"title\":\"只能保证一个共享变量的原子操作\",\"id\":\"20220421194022-vta6rxb\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/CAS原理#只能保证一个共享变量的原子操作\",\"parentId\":\"20220421194022-h6qtglq\",\"path\":\"/topic/Java并发工具包/底层原理/CAS原理\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"AQS框架\",\"id\":\"20220421194022-1td53tx\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/底层原理/AQS框架\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/底层原理/AQS框架\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"sort\":2,\"children\":[{\"title\":\"模拟场景\",\"id\":\"20220421194022-n0uvyw8\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/AQS框架#模拟场景\",\"parentId\":\"20220421194022-1td53tx\",\"path\":\"/topic/Java并发工具包/底层原理/AQS框架\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":3},{\"title\":\"源码分析\",\"id\":\"20220421194022-7eiw7qv\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/AQS框架#源码分析\",\"parentId\":\"20220421194022-1td53tx\",\"path\":\"/topic/Java并发工具包/底层原理/AQS框架\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":3},{\"title\":\"获取锁流程\",\"id\":\"20220421194022-dtotqd0\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/AQS框架#获取锁流程\",\"parentId\":\"20220421194022-1td53tx\",\"path\":\"/topic/Java并发工具包/底层原理/AQS框架\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[{\"title\":\"用户A加锁\",\"id\":\"20220421194022-9rqlcvk\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/AQS框架#用户A加锁\",\"parentId\":\"20220421194022-dtotqd0\",\"path\":\"/topic/Java并发工具包/底层原理/AQS框架\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":4},{\"title\":\"用户B加锁\",\"id\":\"20220421194022-9b47tov\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/AQS框架#用户B加锁\",\"parentId\":\"20220421194022-dtotqd0\",\"path\":\"/topic/Java并发工具包/底层原理/AQS框架\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":4},{\"title\":\"用户C加锁\",\"id\":\"20220421194022-b6gyak4\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/AQS框架#用户C加锁\",\"parentId\":\"20220421194022-dtotqd0\",\"path\":\"/topic/Java并发工具包/底层原理/AQS框架\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"释放锁流程\",\"id\":\"20220421194022-taw90hy\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/AQS框架#释放锁流程\",\"parentId\":\"20220421194022-1td53tx\",\"path\":\"/topic/Java并发工具包/底层原理/AQS框架\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":3},{\"title\":\"总结\",\"id\":\"20220421194022-kghc8ld\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/AQS框架#总结\",\"parentId\":\"20220421194022-1td53tx\",\"path\":\"/topic/Java并发工具包/底层原理/AQS框架\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"伪共享\",\"id\":\"20220421194023-jhmtygl\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/底层原理/伪共享\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/底层原理/伪共享\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"sort\":3,\"children\":[{\"title\":\"什么是伪共享\",\"id\":\"20220421194023-ctrke5m\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/伪共享#什么是伪共享\",\"parentId\":\"20220421194023-jhmtygl\",\"path\":\"/topic/Java并发工具包/底层原理/伪共享\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":3},{\"title\":\"JVM中的伪共享\",\"id\":\"20220421194023-a71m3j6\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/伪共享#JVM中的伪共享\",\"parentId\":\"20220421194023-jhmtygl\",\"path\":\"/topic/Java并发工具包/底层原理/伪共享\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[{\"title\":\"如何避免\",\"id\":\"20220421194023-r09nmr8\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/伪共享#如何避免\",\"parentId\":\"20220421194023-a71m3j6\",\"path\":\"/topic/Java并发工具包/底层原理/伪共享\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"java内存模型\",\"id\":\"20220421225623-ocb0581\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"sort\":4,\"children\":[{\"title\":\"Java内存模型介绍\",\"id\":\"20220421194023-dz3sn14\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/Java内存模型介绍\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/Java内存模型介绍\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"sort\":25,\"children\":[{\"title\":\"容易混淆的JVM内存结构和Java内存模型\",\"id\":\"20220421194023-ltidan3\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/Java内存模型介绍#容易混淆的JVM内存结构和Java内存模型\",\"parentId\":\"20220421194023-dz3sn14\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/Java内存模型介绍\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[{\"title\":\"JVM内存结构\",\"id\":\"20220421194023-hwhuzyc\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/Java内存模型介绍#JVM内存结构\",\"parentId\":\"20220421194023-ltidan3\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/Java内存模型介绍\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":5},{\"title\":\"JMM的引入\",\"id\":\"20220421194023-giug96m\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/Java内存模型介绍#JMM的引入\",\"parentId\":\"20220421194023-ltidan3\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/Java内存模型介绍\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":5},{\"title\":\"JMM的含义\",\"id\":\"20220421194023-k6l0xcb\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/Java内存模型介绍#JMM的含义\",\"parentId\":\"20220421194023-ltidan3\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/Java内存模型介绍\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"JMM与硬件结构的关系\",\"id\":\"20220421194023-s3ta3ij\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/Java内存模型介绍#JMM与硬件结构的关系\",\"parentId\":\"20220421194023-dz3sn14\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/Java内存模型介绍\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"happens-before规则\",\"id\":\"20220421194023-mz0fp6m\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"sort\":32,\"children\":[{\"title\":\"什么是happens_before关系\",\"id\":\"20220421194023-uxmg6t6\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则#什么是happens_before关系\",\"parentId\":\"20220421194023-mz0fp6m\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":4},{\"title\":\"不具备happens_before的例子\",\"id\":\"20220421194023-23izup0\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则#不具备happens_before的例子\",\"parentId\":\"20220421194023-mz0fp6m\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":4},{\"title\":\"happens_before的规则有哪些\",\"id\":\"20220421194023-y3ut2fh\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则#happens_before的规则有哪些\",\"parentId\":\"20220421194023-mz0fp6m\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[{\"title\":\"单线程规则\",\"id\":\"20220421194023-x980qnq\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则#单线程规则\",\"parentId\":\"20220421194023-y3ut2fh\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":5},{\"title\":\"锁操作规则\",\"id\":\"20220421194023-vgbv8gy\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则#锁操作规则\",\"parentId\":\"20220421194023-y3ut2fh\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":5},{\"title\":\"volatile变量规则\",\"id\":\"20220421194023-ktma0mi\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则#volatile变量规则\",\"parentId\":\"20220421194023-y3ut2fh\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":5},{\"title\":\"线程启动规则\",\"id\":\"20220421194023-gpfpqa2\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则#线程启动规则\",\"parentId\":\"20220421194023-y3ut2fh\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":5},{\"title\":\"线程join规则\",\"id\":\"20220421194023-xuf9tiy\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则#线程join规则\",\"parentId\":\"20220421194023-y3ut2fh\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":5},{\"title\":\"中断规则\",\"id\":\"20220421194023-c2tof50\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则#中断规则\",\"parentId\":\"20220421194023-y3ut2fh\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":5},{\"title\":\"并发工具类的规则\",\"id\":\"20220421194023-n42jz2g\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则#并发工具类的规则\",\"parentId\":\"20220421194023-y3ut2fh\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"总结\",\"id\":\"20220421194023-86u79bh\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则#总结\",\"parentId\":\"20220421194023-mz0fp6m\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2}],\"level\":1}],\"level\":0}"}},"pageContext":{"slug":"/topic/Java并发工具包/并发工具/并发容器/HashMap","topic":"Java并发工具包"}},"staticQueryHashes":["1284643331","2841359383"]}