{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/SpringCloud并发请求其他系统接口，导致链路追踪失效","result":{"data":{"siYuan":{"excerpt":"SpringCloud并发请求其他系统接口，导致链路追踪失效 在有一次使用线程池调用feign接口请求下游接口，下游接口拿不到系统的spanId和traceId，导致多线程下的链路追踪就不起作用，以致于难以排查问题 分析 由于项目中重写了F...","raw":"# SpringCloud并发请求其他系统接口，导致链路追踪失效\n\n在有一次使用线程池调用feign接口请求下游接口，下游接口拿不到系统的spanId和traceId，导致多线程下的链路追踪就不起作用，以致于难以排查问题\n\n## 分析\n\n由于项目中重写了`Feigin`中的`RequestInterceptor`，在重写方法中会通过`RequestContextHolder`提取header头做了一些对应的属性设置，在多线程开启的子线程下 `RequestContextHolder` 拿到的`request`是null，应该是这边导致的问题。\n\n## 原理分析\n\n`RequestContextHolder`是`Spring-Web`提供，用于方便的获取当前请求的信息。\n\n其内部中有两个ThreadLocal，一个是用于当前线程的`requestAttributesHolder`，另一个是作用于子线程的`inheritableRequestAttributesHolder`，在不做任何设置的情况下，是通过当前线程的`requestAttributesHolder`来存储对象的.\n\n```java\npublic abstract class RequestContextHolder  {\n\tprivate static final ThreadLocal<RequestAttributes> requestAttributesHolder =\n\t\t\tnew NamedThreadLocal<>(\"Request attributes\");\n\n\tprivate static final ThreadLocal<RequestAttributes> inheritableRequestAttributesHolder =\n\t\t\tnew NamedInheritableThreadLocal<>(\"Request context\");\n}\n```\n\n在`Spring-Web`的实现中，是在`FrameworkServlet#processRequest`中，在进入请求处理之前，会将`Request`的信息设置到`requestAttributesHolder`中去\n\n```java\nprotected final void processRequest(HttpServletRequest request, HttpServletResponse response)\n      throws ServletException, IOException {\n​\n   RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();\n   ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);\n​\n   initContextHolders(request, localeContext, requestAttributes);\n​\n   try {\n      doService(request, response);\n   }\n}\n​\nprivate void initContextHolders(HttpServletRequest request,\n      @Nullable LocaleContext localeContext, @Nullable RequestAttributes requestAttributes) {\n​\n    if (requestAttributes != null) {\n      RequestContextHolder.setRequestAttributes(requestAttributes, this.threadContextInheritable);\n    }\n}\n```\n\n在从`RequestContextHolder`中取出数据的时候，则会从`requestAttributesHolder`中取，如果取不到则会从\n\n`inheritableRequestAttributesHolder`取。\n\n```java\npublic static RequestAttributes getRequestAttributes() {\n\tRequestAttributes attributes = requestAttributesHolder.get();\n\tif (attributes == null) {\n\t\tattributes = inheritableRequestAttributesHolder.get();\n\t}\n\treturn attributes;\n}\n```\n\n## 解决方案\n\n### 修改`ServletRegistrationBean`配置\n\n我们可以通过设置`threadContextInheritable`来修改存储位置，存储到`inheritableRequestAttributesHolder`中\n\n```java\n @Bean\n    public ServletRegistrationBean apiServlet(DispatcherServlet dispatcherServlet) {\n\t// 设置到子线程\n        dispatcherServlet.setThreadContextInheritable(true);\n        ServletRegistrationBean bean = new ServletRegistrationBean(dispatcherServlet);\n        return bean;\n    }\n```\n\n### 新开子线程之前手动设置子线程共享\n\n```java\nServletRequestAttributes sra = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\nRequestContextHolder.setRequestAttributes(sra, true);\n```\n\n\n# InheritableThreadLocal是怎么做到主子线程共享的\n\n`InheritableThreadLocal`是在创建`Thread`的时候初始化进去的。\n\n来看`Thread`构造方法:\n\n```java\npublic Thread() {\n    this(null, null, \"Thread-\" + nextThreadNum(), 0);\n}\n\npublic Thread(ThreadGroup group, Runnable target, String name,\n                  long stackSize) {\n    this(group, target, name, stackSize, null, true);\n}\n\nprivate Thread(ThreadGroup g, Runnable target, String name,\n                   long stackSize, AccessControlContext acc,\n                   boolean inheritThreadLocals) {\n     ......\n    Thread parent = currentThread();\n    if (inheritThreadLocals && parent.inheritableThreadLocals != null)\n            this.inheritableThreadLocals =\n                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);\n     ......\n}\n```\n\n最后在创建`Thread` 的时候，会调用一个带`inheritThreadLocals`标记的构造方法\n\n如果`inheritThreadLocals`为true，并且当前线程`inheritableThreadLocals`不为空，就将`inheritableThreadLocals`设置成父类的`inheritableThreadLocals`\n\n继续点进去看:\n\n```java\n private ThreadLocalMap(ThreadLocalMap parentMap) {\n            Entry[] parentTable = parentMap.table;\n            int len = parentTable.length;\n            setThreshold(len);\n            table = new Entry[len];\n\n            for (Entry e : parentTable) {\n                if (e != null) {\n                    @SuppressWarnings(\"unchecked\")\n                    ThreadLocal<Object> key = (ThreadLocal<Object>) e.get();\n                    if (key != null) {\n                        Object value = key.childValue(e.value);\n                        Entry c = new Entry(key, value);\n                        int h = key.threadLocalHashCode & (len - 1);\n                        while (table[h] != null)\n                            h = nextIndex(h, len);\n                        table[h] = c;\n                        size++;\n                    }\n                }\n            }\n        }\n```\n\n就是通过`ThreadLocalMap`的构造方法，将父类的值一个一个拷贝到子线程中,然后新创建的`inheritableThreadLocals`就有了值，我们也就能通过这个对象，将父线程的值给拿过来了，自然也就完成了主子线程的传递\n","field":{"slug":"/posts/SpringCloud并发请求其他系统接口，导致链路追踪失效"},"frontmatter":{"title":"SpringCloud并发请求其他系统接口，导致链路追踪失效","tags":[],"date":"2022-04-25","description":"SpringCloud并发请求其他系统接口，导致链路追踪失效 在有一次使用线程池调用feign接口请求下游接口，下游接口拿不到系统的spanId和traceId，导致多线程下的链路追踪就不起作用，以致于难以排查问题 分析 由于项目中重写了F..."}},"prev":{"frontmatter":{"title":"RocketMQ事务消息实现原理"},"field":{"slug":"/posts/RocketMQ事务消息实现原理"}},"next":{"frontmatter":{"title":"兜兜转转，最后用Gastby重写了我的博客"},"field":{"slug":"/posts/兜兜转转，最后用Gastby重写了我的博客"}}},"pageContext":{"slug":"/posts/SpringCloud并发请求其他系统接口，导致链路追踪失效","prevSlug":"/posts/RocketMQ事务消息实现原理","nextSlug":"/posts/兜兜转转，最后用Gastby重写了我的博客"}},"staticQueryHashes":["1284643331","2841359383"]}