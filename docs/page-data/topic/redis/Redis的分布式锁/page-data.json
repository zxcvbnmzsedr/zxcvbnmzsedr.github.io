{
    "componentChunkName": "component---src-templates-topic-page-template-tsx",
    "path": "/topic/redis/Redis的分布式锁",
    "result": {"pageContext":{"id":"/topic/redis/Redis的分布式锁","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"Redis的分布式锁"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"利用redis实现分布式锁"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"三个重要因素"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"加锁:  加锁实际上就是在redis中，给Key键设置一个值，为避免死锁，并给定一个过期时间"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"解锁: 将Key键删除。但也不能乱删，不能说客户端1的请求将客户端2的锁给删除掉，只能自己删除自己的锁"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"超时: 不能长期占用"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"涉及命令"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"SETNX: 当KEY不存在的时候设置KEY的值为value，返回1，当KEY存在的时候，不做任何动作返回0。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-shell"]},"children":[{"type":"text","value":"redis> setnx key value\n\t1\nredis> setnx key value\n\t0\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{"start":2},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"EXPIRE: 为KEY设计一个超时时间，到期自动释放，避免死锁。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"DELETE: 删除KEY，用于业务处理完手动释放锁。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"实现思想"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"随机生成一个UUID，标记是当前线程，调用SETNX方法设置值，并且调用expire方法为锁加一个超期时间，到期自动释放锁。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"获取锁的时候，加一个超期时间，超过时间则放弃去竞争锁。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"释放锁的时候，判断UUID是不是  该锁，如果是则执行DELETE进行释放。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-mermaid"]},"children":[{"type":"text","value":"flowchart TD;\n    获取锁-->B(执行SETNX命令);\n    B-->C{是否返回1};\n    C-->|是|E(执行expire延长时间);\n    E-->F(获取到锁,执行业务逻辑);\n    F-->G(释放锁);\n    G-->结束;\n    B-->|否|结束;\n \n    释放锁-->执行GET;\n    执行GET-->Z{返回的值\\n是否是自己设定的值};\n    Z-->|是|执行del;\n    执行del-->Y(结束);\n    Z-->|否|Y;\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"上面这么实现有什么问题么?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"业务执行的时间大于redis锁过期的时间"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"一个锁设置了1分钟超时释放，如果拿到这个锁的线程在一分钟内没有执行完毕，那么这个锁就会被其他线程拿到，可能会导致严重的线上问题。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"redis部署模式的影响"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在单机模式下，redis是CP模式，在对并发量不大的情况下，是可以用这种代码去实现的，单机也能够扛得住。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果在集群模式下，redis异步复制造成的锁丢失，如果主节点没来的及把刚刚set进来这条数据给从节点，就挂了，就导致锁没有锁上，释放也是同样的逻辑"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因此针对上述的情况，业界有统一的解决方案: Redlock 红锁。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"原子性问题"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"SETNX + EXPIRE不是原子性的，不满足事务性 , 如果expire未执行成功，锁只能主动释放，锁存在永远得不到释放的情况, 可以使用下面的命令进行设置。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-shell"]},"children":[{"type":"text","value":"SET key value NX EX 1000\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"或者可以用lua进行设置"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-lua"]},"children":[{"type":"text","value":"local key     = KEYS[1]\nlocal content = ARGV[1]\nlocal ttl     = tonumber(ARGV[2])\nlocal lockSet = redis.call('setnx', key, content)\nif lockSet == 1 then\n  redis.call('PEXPIRE', key, ttl)\nelse\n  -- 如果value相同，则认为是同一个线程的请求，则认为重入锁\n  local value = redis.call('get', key)\n  if(value == content) then\n    lockSet = 1;\n    redis.call('PEXPIRE', key, ttl)\n  end\nend\nreturn lockSet\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"同样的，get+delete也不是原子性的"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-lua"]},"children":[{"type":"text","value":"local key     = KEYS[1]\nlocal content = ARGV[1]\nlocal value = redis.call('get', key)\nif value == content then\n  return redis.call('del', key)\nelse\n    return 0\nend\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"使用java代码优化上述的问题:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"@RestController\npublic class GoodController {\n    public static final String REDIS_LOCK_KEY = \"redisLockPay\";\n    @Autowired\n    private StringRedisTemplate stringRedisTemplate;\n    @Value(\"${server.port}\")\n    private String serverPort;\n\n    @GetMapping(\"/buy_goods\")\n    public String buy_Goods() {\n        String value = UUID.randomUUID().toString() + Thread.currentThread().getName();\n        try {\n            Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value, 30L, TimeUnit.SECONDS);\n            if (!flag) {\n                return \" 抢夺锁失败，请下次尝试 \";\n            }\n            String result = stringRedisTemplate.opsForValue().get(\"goods:001\");\n            int goodsNumber = result == null ? 0 : Integer.parseInt(result);\n            if (goodsNumber > 0) {\n                int realNumber = goodsNumber - 1;\n                stringRedisTemplate.opsForValue().set(\"goods:001\", realNumber + \"\");\n                System.out.println(\" 你已经成功秒杀商品，此时还剩余： \" + realNumber + \" 件 \" + \" \\t  服务器端口： \" + serverPort);\n                return \" 你已经成功秒杀商品，此时还剩余： \" + realNumber + \" 件 \" + \" \\t  服务器端口： \" + serverPort;\n            } else {\n                System.out.println(\" 商品已经售罄 / 活动结束 / 调用超时，欢迎下次光临 \" + \" \\t  服务器端口： \" + serverPort);\n            }\n            return \" 商品已经售罄 / 活动结束 / 调用超时，欢迎下次光临 \" + \" \\t  服务器端口： \" + serverPort;\n        } finally {\n            Jedis jedis = RedisUtils.getJedis();\n            String script = \"if redis.call('get', KEYS[1]) == ARGV[1] \" + \"then \" + \"return redis.call('del', KEYS[1]) \" + \"else \" + \"   return 0 \" + \"end\";\n            try {\n                Object result = jedis.eval(script, Collections.singletonList(REDIS_LOCK_KEY), Collections.singletonList(value));\n                if (\"1\".equals(result.toString())) {\n                    System.out.println(\"------del REDIS_LOCK_KEY success\");\n                } else {\n                    System.out.println(\"------del REDIS_LOCK_KEY error\");\n                }\n            } finally {\n                if (null != jedis) {\n                    jedis.close();\n                }\n            }\n        }\n    }\n}   \n"}]}]}],"data":{"quirksMode":false}},"headings":[{"depth":1,"value":"Redis的分布式锁","slug":"redis的分布式锁"},{"depth":1,"value":"利用redis实现分布式锁","slug":"利用redis实现分布式锁"},{"depth":2,"value":"三个重要因素","slug":"三个重要因素"},{"depth":2,"value":"涉及命令","slug":"涉及命令"},{"depth":1,"value":"实现思想","slug":"实现思想"},{"depth":2,"value":"业务执行的时间大于redis锁过期的时间","slug":"业务执行的时间大于redis锁过期的时间"},{"depth":2,"value":"redis部署模式的影响","slug":"redis部署模式的影响"},{"depth":2,"value":"原子性问题","slug":"原子性问题"}]}},
    "staticQueryHashes": ["928362550"]}