{
    "componentChunkName": "component---src-templates-article-page-template-tsx",
    "path": "/posts/从CPU亲缘性探究Thread.currentThread",
    "result": {"pageContext":{"id":"/posts/从CPU亲缘性探究Thread.currentThread","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"从CPU亲缘性探究Thread.currentThread"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在美团这篇文章: "},{"type":"element","tagName":"a","properties":{"href":"https://tech.meituan.com/2018/03/16/redis-high-concurrency-optimization.html"},"children":[{"type":"text","value":"《Redis 高负载下的中断优化》"}]},{"type":"text","value":"看到了一个叫做CPU亲缘性的东西"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果某个"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CPU Core"}]},{"type":"text","value":"正在处理Redis的调用，执行到一半时产生了中断，那么CPU不得不停止当前的工作转而处理中断请求，中断期间Redis也无法转交给其他core继续运行，必须等处理完中断后才能继续运行。Redis本身定位就是高速缓存，线上的平均端到端响应时间小于1ms，如果频繁被中断，那么响应时间必然受到极大影响。容易想到，由最初的"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CPU 0"}]},{"type":"text","value":"单核处理中断，改进到多核处理中断，Redis进程被中断影响的几率增大了，因此我们需要对Redis进程也设置CPU亲缘性，使其与处理中断的Core互相错开，避免受到影响。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在网卡收集到数据包的时候，需要CPU进行一个软中断，告诉操作系统内核有数据进来了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以，在大量的网络请求过来之后，可能Redis处理数据的CPU的核心、和响应中断的CPU的核心是同一个核心。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"那就意味着，一旦CPU中断了（即使速度很快），也会影响Redis的处理速度。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"作者还提到:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"由于"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Linux wake affinity"}]},{"type":"text","value":"特性，如果两个进程频繁互动，调度系统会觉得它们很有可能共享同样的数据，把它们放到同一CPU核心或"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"NUMA Node"}]},{"type":"text","value":"有助于提高缓存和内存的访问性能，所以当一个进程唤醒另一个的时候，被唤醒的进程可能会被放到相同的"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CPU core"}]},{"type":"text","value":"或者相同的NUMA节点上。此特性对中断唤醒进程时也起作用，在上一节所述的现象中，所有的网络中断都分配给"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CPU 0"}]},{"type":"text","value":"去处理，当中断处理完成时，由于"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"wakeup affinity"}]},{"type":"text","value":"特性的作用，所唤醒的用户进程也被安排给"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CPU 0"}]},{"type":"text","value":"或其所在的numa节点上其他core。而当两个"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"NUMA node"}]},{"type":"text","value":"处理中断时，这种调度特性有可能导致Redis进程在"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CPU core"}]},{"type":"text","value":"之间频繁迁移，造成性能损失。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"也就是说，如果CPU核心一直在交替处理Redis和网络请求，那么就会导致没有办法进行有效缓存，进而影响性能。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"探究"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以从美团的这篇文章上来看，我觉得JVM实际上也会有这样的问题，就突发奇想了一下，如果JVM的线程调度归个类，让相似的线程使用同一个CPU核心处理，这样不就能够进一步加强并发效率么？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"然后就查询了各种资料，最后发现有个叫做"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Java Thread Affinity"}]},{"type":"text","value":"的东西。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"Java Thread Affinity简介"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"git地址: "},{"type":"element","tagName":"a","properties":{"href":"https://github.com/OpenHFT/Java-Thread-Affinity"},"children":[{"type":"text","value":"https://github.com/OpenHFT/Java-Thread-Affinity"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Java Thread Affinity"}]},{"type":"text","value":"是将Java代码中的线程绑定到"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CPU"}]},{"type":"text","value":"特定的核上，用来提升程序的性能。底层使用了"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"JNA技术"}]},{"type":"text","value":"来提供对底层线程的访问能力"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"JNA（Java Native Access ）提供封装好的java函数用JNI来调用本地共享文件.dll/.so中的函数"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在双核的服务器上使用"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"lscpu"}]},{"type":"text","value":"命令来查看系统的CPU情况，如下所示"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-python"]},"children":[{"type":"text","value":"Architecture:          x86_64\nCPU op-mode(s):        32-bit, 64-bit\nByte Order:            Little Endian\nCPU(s):                2\nOn-line CPU(s) list:   0,1\nThread(s) per core:    2\nCore(s) per socket:    1\n座：                 1\nNUMA 节点：         1\n厂商 ID：           GenuineIntel\nCPU 系列：          6\n型号：              79\n型号名称：        Intel(R) Xeon(R) CPU E5-2682 v4 @ 2.50GHz\n步进：              1\nCPU MHz：             2494.220\nBogoMIPS：            4988.44\n超管理器厂商：  KVM\n虚拟化类型：     完全\nL1d 缓存：          32K\nL1i 缓存：          32K\nL2 缓存：           256K\nL3 缓存：           40960K\nNUMA 节点0 CPU：    0,1\nFlags:                 fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm rdseed adx smap xsaveopt\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"从上面的输出我们可以看到，这个服务器有两个socket，每个socket有一个core，每个"},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"core"}]},{"type":"text","value":"可以同时处理2个线程。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"完整的信息在"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"/proc/cpuinfo"}]},{"type":"text","value":"中："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-python"]},"children":[{"type":"text","value":"processor\t: 0\nvendor_id\t: GenuineIntel\ncpu family\t: 6\nmodel\t\t: 79\nmodel name\t: Intel(R) Xeon(R) CPU E5-2682 v4 @ 2.50GHz\nstepping\t: 1\nmicrocode\t: 0x1\ncpu MHz\t\t: 2494.220\ncache size\t: 40960 KB\nphysical id\t: 0\nsiblings\t: 2\ncore id\t\t: 0\ncpu cores\t: 1\napicid\t\t: 0\ninitial apicid\t: 0\nfpu\t\t: yes\nfpu_exception\t: yes\ncpuid level\t: 13\nwp\t\t: yes\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm rdseed adx smap xsaveopt\nbogomips\t: 4988.44\nclflush size\t: 64\ncache_alignment\t: 64\naddress sizes\t: 46 bits physical, 48 bits virtual\npower management:\n\nprocessor\t: 1\nvendor_id\t: GenuineIntel\ncpu family\t: 6\nmodel\t\t: 79\nmodel name\t: Intel(R) Xeon(R) CPU E5-2682 v4 @ 2.50GHz\nstepping\t: 1\nmicrocode\t: 0x1\ncpu MHz\t\t: 2494.220\ncache size\t: 40960 KB\nphysical id\t: 0\nsiblings\t: 2\ncore id\t\t: 0\ncpu cores\t: 1\napicid\t\t: 1\ninitial apicid\t: 1\nfpu\t\t: yes\nfpu_exception\t: yes\ncpuid level\t: 13\nwp\t\t: yes\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm rdseed adx smap xsaveopt\nbogomips\t: 4988.44\nclflush size\t: 64\ncache_alignment\t: 64\naddress sizes\t: 46 bits physical, 48 bits virtual\npower management:\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Java Thread Affinity"}]},{"type":"text","value":"会读取"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"/proc/cpuinfo"}]},{"type":"text","value":"来确定CPU的"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"layout"}]},{"type":"text","value":"信息，代码中有个CpuLayout与之对应："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://image.ztianzeng.com/uPic/20220513103640.png","alt":""},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"根据"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CPU layout"}]},{"type":"text","value":"的信息， "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"AffinityStrategies"}]},{"type":"text","value":"提供了一些基本的Affinity策略，用来安排不同的"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"thread"}]},{"type":"text","value":"之间的分布关系："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-python"]},"children":[{"type":"text","value":"public enum AffinityStrategies implements AffinityStrategy {\n\n    /**\n     * 任何CPU都行.\n     */\n    ANY {\n        @Override\n        public boolean matches(int cpuId, int cpuId2) {\n            return true;\n        }\n    },\n    /**\n     * 运行在同一个core中.\n     */\n    SAME_CORE {\n        @Override\n        public boolean matches(int cpuId, int cpuId2) {\n            CpuLayout cpuLayout = AffinityLock.cpuLayout();\n            return cpuLayout.socketId(cpuId) == cpuLayout.socketId(cpuId2) &&\n                    cpuLayout.coreId(cpuId) == cpuLayout.coreId(cpuId2);\n        }\n    },\n    /**\n     * 运行在同一个socket中，但是不在同一个core上。.\n     */\n    SAME_SOCKET {\n        @Override\n        public boolean matches(int cpuId, int cpuId2) {\n            CpuLayout cpuLayout = AffinityLock.cpuLayout();\n            return cpuLayout.socketId(cpuId) == cpuLayout.socketId(cpuId2) &&\n                    cpuLayout.coreId(cpuId) != cpuLayout.coreId(cpuId2);\n        }\n    },\n    /**\n     * 运行在不同的socket中\n     */\n    DIFFERENT_CORE {\n        @Override\n        public boolean matches(int cpuId, int cpuId2) {\n            CpuLayout cpuLayout = AffinityLock.cpuLayout();\n            return cpuLayout.socketId(cpuId) != cpuLayout.socketId(cpuId2) ||\n                    cpuLayout.coreId(cpuId) != cpuLayout.coreId(cpuId2);\n        }\n    },\n    /**\n     * 运行在不同的core上\n     */\n    DIFFERENT_SOCKET {\n        @Override\n        public boolean matches(int cpuId, int cpuId2) {\n            CpuLayout cpuLayout = AffinityLock.cpuLayout();\n            return cpuLayout.socketId(cpuId) != cpuLayout.socketId(cpuId2);\n        }\n    }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"由于MacOS系统的局限性，没有办法通过"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"/proc/cpuinfo"}]},{"type":"text","value":"获取到CPU信息，全部都是走的默认"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"NoCpuLayout"}]},{"type":"text","value":"来进行处理，我的Mac是16核，默认16核全部参与工作。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"使用方式"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"限制线程在单个CPU核心上运行"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"try (AffinityLock al = AffinityLock.acquireLock()) {\n    // do some work while locked to a CPU.\n    System.out.println(al.cpuId());\n    while(true) {}\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"指定CPU运行"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"try (AffinityLock al = AffinityLock.acquireLock(5)) {\n    // do some work while locked to a CPU.\n    System.out.println(al.cpuId());\n    while(true) {}\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"线程池指定"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Affinity"}]},{"type":"text","value":"提供了线程工厂方法，可以构造自己的线程池的亲缘策略"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"ExecutorService ES = Executors.newFixedThreadPool(4,new AffinityThreadFactory(\"bg\", SAME_CORE, DIFFERENT_SOCKET, ANY));\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"原理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"一般服务器都是Linux的，所以只看Linux下的实现。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Java Thread Affinity"}]},{"type":"text","value":"有个"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CLibrary"}]},{"type":"text","value":"的匿名内部类，用来封装操作系统提供的API"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":" interface CLibrary extends Library {\n        CLibrary INSTANCE = (CLibrary) Native.loadLibrary(LIBRARY_NAME, CLibrary.class);\n\n        int sched_setaffinity(final int pid,\n                              final int cpusetsize,\n                              final cpu_set_t cpuset) throws LastErrorException;\n\n        int sched_getaffinity(final int pid,\n                              final int cpusetsize,\n                              final cpu_set_t cpuset) throws LastErrorException;\n\n        int getpid() throws LastErrorException;\n\n        int sched_getcpu() throws LastErrorException;\n\n        int uname(final utsname name) throws LastErrorException;\n\n        int syscall(int number, Object... args) throws LastErrorException;\n    }\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"sched_setaffinity可以将某个进程绑定到一个特定的CPU，这是Linux提供了设置CPU亲和力的方法。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"通过调用这个方法，将cpu的掩码绑定到对应的pid上面，就能够形成亲和。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"总结"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Java Thread Affinity"}]},{"type":"text","value":"可以从JAVA代码中对程序中Thread使用的CPU进行控制。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"能够通过自行设置亲和力的方式，来避免操作系统本身的调度。"}]}],"data":{"quirksMode":false}},"articleNode":{"field":{"contentType":"posts","topic":null},"frontmatter":{"id":"/posts/从CPU亲缘性探究Thread.currentThread","title":"从CPU亲缘性探究Thread.currentThread","date":"2022-05-12 20:47","absolute_path":"/posts/从CPU亲缘性探究Thread.currentThread"},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"从CPU亲缘性探究Thread.currentThread"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在美团这篇文章: "},{"type":"element","tagName":"a","properties":{"href":"https://tech.meituan.com/2018/03/16/redis-high-concurrency-optimization.html"},"children":[{"type":"text","value":"《Redis 高负载下的中断优化》"}]},{"type":"text","value":"看到了一个叫做CPU亲缘性的东西"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果某个"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CPU Core"}]},{"type":"text","value":"正在处理Redis的调用，执行到一半时产生了中断，那么CPU不得不停止当前的工作转而处理中断请求，中断期间Redis也无法转交给其他core继续运行，必须等处理完中断后才能继续运行。Redis本身定位就是高速缓存，线上的平均端到端响应时间小于1ms，如果频繁被中断，那么响应时间必然受到极大影响。容易想到，由最初的"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CPU 0"}]},{"type":"text","value":"单核处理中断，改进到多核处理中断，Redis进程被中断影响的几率增大了，因此我们需要对Redis进程也设置CPU亲缘性，使其与处理中断的Core互相错开，避免受到影响。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在网卡收集到数据包的时候，需要CPU进行一个软中断，告诉操作系统内核有数据进来了。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以，在大量的网络请求过来之后，可能Redis处理数据的CPU的核心、和响应中断的CPU的核心是同一个核心。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"那就意味着，一旦CPU中断了（即使速度很快），也会影响Redis的处理速度。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"作者还提到:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"由于"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Linux wake affinity"}]},{"type":"text","value":"特性，如果两个进程频繁互动，调度系统会觉得它们很有可能共享同样的数据，把它们放到同一CPU核心或"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"NUMA Node"}]},{"type":"text","value":"有助于提高缓存和内存的访问性能，所以当一个进程唤醒另一个的时候，被唤醒的进程可能会被放到相同的"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CPU core"}]},{"type":"text","value":"或者相同的NUMA节点上。此特性对中断唤醒进程时也起作用，在上一节所述的现象中，所有的网络中断都分配给"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CPU 0"}]},{"type":"text","value":"去处理，当中断处理完成时，由于"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"wakeup affinity"}]},{"type":"text","value":"特性的作用，所唤醒的用户进程也被安排给"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CPU 0"}]},{"type":"text","value":"或其所在的numa节点上其他core。而当两个"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"NUMA node"}]},{"type":"text","value":"处理中断时，这种调度特性有可能导致Redis进程在"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CPU core"}]},{"type":"text","value":"之间频繁迁移，造成性能损失。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"也就是说，如果CPU核心一直在交替处理Redis和网络请求，那么就会导致没有办法进行有效缓存，进而影响性能。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"探究"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以从美团的这篇文章上来看，我觉得JVM实际上也会有这样的问题，就突发奇想了一下，如果JVM的线程调度归个类，让相似的线程使用同一个CPU核心处理，这样不就能够进一步加强并发效率么？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"然后就查询了各种资料，最后发现有个叫做"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Java Thread Affinity"}]},{"type":"text","value":"的东西。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"Java Thread Affinity简介"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"git地址: "},{"type":"element","tagName":"a","properties":{"href":"https://github.com/OpenHFT/Java-Thread-Affinity"},"children":[{"type":"text","value":"https://github.com/OpenHFT/Java-Thread-Affinity"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Java Thread Affinity"}]},{"type":"text","value":"是将Java代码中的线程绑定到"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CPU"}]},{"type":"text","value":"特定的核上，用来提升程序的性能。底层使用了"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"JNA技术"}]},{"type":"text","value":"来提供对底层线程的访问能力"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"JNA（Java Native Access ）提供封装好的java函数用JNI来调用本地共享文件.dll/.so中的函数"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在双核的服务器上使用"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"lscpu"}]},{"type":"text","value":"命令来查看系统的CPU情况，如下所示"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-python"]},"children":[{"type":"text","value":"Architecture:          x86_64\nCPU op-mode(s):        32-bit, 64-bit\nByte Order:            Little Endian\nCPU(s):                2\nOn-line CPU(s) list:   0,1\nThread(s) per core:    2\nCore(s) per socket:    1\n座：                 1\nNUMA 节点：         1\n厂商 ID：           GenuineIntel\nCPU 系列：          6\n型号：              79\n型号名称：        Intel(R) Xeon(R) CPU E5-2682 v4 @ 2.50GHz\n步进：              1\nCPU MHz：             2494.220\nBogoMIPS：            4988.44\n超管理器厂商：  KVM\n虚拟化类型：     完全\nL1d 缓存：          32K\nL1i 缓存：          32K\nL2 缓存：           256K\nL3 缓存：           40960K\nNUMA 节点0 CPU：    0,1\nFlags:                 fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm rdseed adx smap xsaveopt\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"从上面的输出我们可以看到，这个服务器有两个socket，每个socket有一个core，每个"},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"core"}]},{"type":"text","value":"可以同时处理2个线程。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"完整的信息在"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"/proc/cpuinfo"}]},{"type":"text","value":"中："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-python"]},"children":[{"type":"text","value":"processor\t: 0\nvendor_id\t: GenuineIntel\ncpu family\t: 6\nmodel\t\t: 79\nmodel name\t: Intel(R) Xeon(R) CPU E5-2682 v4 @ 2.50GHz\nstepping\t: 1\nmicrocode\t: 0x1\ncpu MHz\t\t: 2494.220\ncache size\t: 40960 KB\nphysical id\t: 0\nsiblings\t: 2\ncore id\t\t: 0\ncpu cores\t: 1\napicid\t\t: 0\ninitial apicid\t: 0\nfpu\t\t: yes\nfpu_exception\t: yes\ncpuid level\t: 13\nwp\t\t: yes\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm rdseed adx smap xsaveopt\nbogomips\t: 4988.44\nclflush size\t: 64\ncache_alignment\t: 64\naddress sizes\t: 46 bits physical, 48 bits virtual\npower management:\n\nprocessor\t: 1\nvendor_id\t: GenuineIntel\ncpu family\t: 6\nmodel\t\t: 79\nmodel name\t: Intel(R) Xeon(R) CPU E5-2682 v4 @ 2.50GHz\nstepping\t: 1\nmicrocode\t: 0x1\ncpu MHz\t\t: 2494.220\ncache size\t: 40960 KB\nphysical id\t: 0\nsiblings\t: 2\ncore id\t\t: 0\ncpu cores\t: 1\napicid\t\t: 1\ninitial apicid\t: 1\nfpu\t\t: yes\nfpu_exception\t: yes\ncpuid level\t: 13\nwp\t\t: yes\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm rdseed adx smap xsaveopt\nbogomips\t: 4988.44\nclflush size\t: 64\ncache_alignment\t: 64\naddress sizes\t: 46 bits physical, 48 bits virtual\npower management:\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Java Thread Affinity"}]},{"type":"text","value":"会读取"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"/proc/cpuinfo"}]},{"type":"text","value":"来确定CPU的"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"layout"}]},{"type":"text","value":"信息，代码中有个CpuLayout与之对应："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://image.ztianzeng.com/uPic/20220513103640.png","alt":""},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"根据"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CPU layout"}]},{"type":"text","value":"的信息， "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"AffinityStrategies"}]},{"type":"text","value":"提供了一些基本的Affinity策略，用来安排不同的"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"thread"}]},{"type":"text","value":"之间的分布关系："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-python"]},"children":[{"type":"text","value":"public enum AffinityStrategies implements AffinityStrategy {\n\n    /**\n     * 任何CPU都行.\n     */\n    ANY {\n        @Override\n        public boolean matches(int cpuId, int cpuId2) {\n            return true;\n        }\n    },\n    /**\n     * 运行在同一个core中.\n     */\n    SAME_CORE {\n        @Override\n        public boolean matches(int cpuId, int cpuId2) {\n            CpuLayout cpuLayout = AffinityLock.cpuLayout();\n            return cpuLayout.socketId(cpuId) == cpuLayout.socketId(cpuId2) &&\n                    cpuLayout.coreId(cpuId) == cpuLayout.coreId(cpuId2);\n        }\n    },\n    /**\n     * 运行在同一个socket中，但是不在同一个core上。.\n     */\n    SAME_SOCKET {\n        @Override\n        public boolean matches(int cpuId, int cpuId2) {\n            CpuLayout cpuLayout = AffinityLock.cpuLayout();\n            return cpuLayout.socketId(cpuId) == cpuLayout.socketId(cpuId2) &&\n                    cpuLayout.coreId(cpuId) != cpuLayout.coreId(cpuId2);\n        }\n    },\n    /**\n     * 运行在不同的socket中\n     */\n    DIFFERENT_CORE {\n        @Override\n        public boolean matches(int cpuId, int cpuId2) {\n            CpuLayout cpuLayout = AffinityLock.cpuLayout();\n            return cpuLayout.socketId(cpuId) != cpuLayout.socketId(cpuId2) ||\n                    cpuLayout.coreId(cpuId) != cpuLayout.coreId(cpuId2);\n        }\n    },\n    /**\n     * 运行在不同的core上\n     */\n    DIFFERENT_SOCKET {\n        @Override\n        public boolean matches(int cpuId, int cpuId2) {\n            CpuLayout cpuLayout = AffinityLock.cpuLayout();\n            return cpuLayout.socketId(cpuId) != cpuLayout.socketId(cpuId2);\n        }\n    }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"由于MacOS系统的局限性，没有办法通过"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"/proc/cpuinfo"}]},{"type":"text","value":"获取到CPU信息，全部都是走的默认"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"NoCpuLayout"}]},{"type":"text","value":"来进行处理，我的Mac是16核，默认16核全部参与工作。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"使用方式"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"限制线程在单个CPU核心上运行"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"try (AffinityLock al = AffinityLock.acquireLock()) {\n    // do some work while locked to a CPU.\n    System.out.println(al.cpuId());\n    while(true) {}\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"指定CPU运行"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"try (AffinityLock al = AffinityLock.acquireLock(5)) {\n    // do some work while locked to a CPU.\n    System.out.println(al.cpuId());\n    while(true) {}\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"线程池指定"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Affinity"}]},{"type":"text","value":"提供了线程工厂方法，可以构造自己的线程池的亲缘策略"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"ExecutorService ES = Executors.newFixedThreadPool(4,new AffinityThreadFactory(\"bg\", SAME_CORE, DIFFERENT_SOCKET, ANY));\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"原理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"一般服务器都是Linux的，所以只看Linux下的实现。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Java Thread Affinity"}]},{"type":"text","value":"有个"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"CLibrary"}]},{"type":"text","value":"的匿名内部类，用来封装操作系统提供的API"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":" interface CLibrary extends Library {\n        CLibrary INSTANCE = (CLibrary) Native.loadLibrary(LIBRARY_NAME, CLibrary.class);\n\n        int sched_setaffinity(final int pid,\n                              final int cpusetsize,\n                              final cpu_set_t cpuset) throws LastErrorException;\n\n        int sched_getaffinity(final int pid,\n                              final int cpusetsize,\n                              final cpu_set_t cpuset) throws LastErrorException;\n\n        int getpid() throws LastErrorException;\n\n        int sched_getcpu() throws LastErrorException;\n\n        int uname(final utsname name) throws LastErrorException;\n\n        int syscall(int number, Object... args) throws LastErrorException;\n    }\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"sched_setaffinity可以将某个进程绑定到一个特定的CPU，这是Linux提供了设置CPU亲和力的方法。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"通过调用这个方法，将cpu的掩码绑定到对应的pid上面，就能够形成亲和。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"总结"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Java Thread Affinity"}]},{"type":"text","value":"可以从JAVA代码中对程序中Thread使用的CPU进行控制。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"能够通过自行设置亲和力的方式，来避免操作系统本身的调度。"}]}],"data":{"quirksMode":false}},"headings":[{"depth":1,"value":"从CPU亲缘性探究Thread.currentThread"},{"depth":1,"value":"探究"},{"depth":1,"value":"Java Thread Affinity简介"},{"depth":2,"value":"使用方式"},{"depth":2,"value":"原理"},{"depth":1,"value":"总结"}],"path":"/posts/从CPU亲缘性探究Thread.currentThread"},"headings":[{"depth":1,"value":"从CPU亲缘性探究Thread.currentThread","slug":"从cpu亲缘性探究threadcurrentthread"},{"depth":1,"value":"探究","slug":"探究"},{"depth":1,"value":"Java Thread Affinity简介","slug":"java-thread-affinity简介"},{"depth":2,"value":"使用方式","slug":"使用方式"},{"depth":2,"value":"原理","slug":"原理"},{"depth":1,"value":"总结","slug":"总结-1"}]}},
    "staticQueryHashes": ["630634786","928362550"]}