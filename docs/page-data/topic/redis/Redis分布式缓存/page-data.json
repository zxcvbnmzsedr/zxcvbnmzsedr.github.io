{
    "componentChunkName": "component---src-templates-topic-page-template-tsx",
    "path": "/topic/redis/Redis分布式缓存",
    "result": {"pageContext":{"id":"/topic/redis/Redis分布式缓存","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"Redis分布式缓存"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"用redis作为最基本的功能，缓存mysql中的数据，加快响应速度"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"双写一致性"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"双写一致性，是redis做为缓存的时候一道非常经典的问题"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因为无论先操作db还是cache，都会有各自的问题，根本原因是cache和db的更新不是一个原子操作，因此总会有不一致的问题。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"一致性可以分为三个等级:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"强一致性"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"弱一致性"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"最终一致性"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"缓存更新策略"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"最常见的策略"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/db-and-cache-01-01.jpg","alt":"img"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"优点剖析"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"1. “先淘汰缓存，再写数据库” 合理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"为什么说这也算优点呢？试想一下"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果把写流程改一下："},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"先更新缓存，再更新DB"}]},{"type":"text","value":"。 如果我们更新缓存成功，而更新数据库失败，就会导致缓存中的数据是错误的，而我们大部分的业务一般能忍受数据延迟，但是数据错误这是无法接受的，所以先淘汰缓存是比较合理的。 如果把写流程改一下："},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"不删缓存，先更新DB，再更新缓存"}]},{"type":"text","value":"。 如果我们更新DB成功，而更新缓存失败，则会导致缓存中就会一直是旧的数据（也算是一种错误数据），所以先淘汰缓存是比较合理的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"2. 异步刷新，补缺补漏"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在很多业务场景中，缓存只是辅助，"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"所以在很多业务中，缓存的读写失败不会影响主流程"}]},{"type":"text","value":"，啥意思呢？就是说很多情况下，即使操作缓存失败（比如步骤1.1中的’DEL缓存失败’），程序还是会继续往下走（继续步骤1.2 更新数据库)，所以这个时候异步刷新就能在一定程度上，对1.1的失败进行错误数据的修补"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"缺点剖析"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"1. 容灾不足"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在分布式领域，“Everything will fails”，任何可能出现问题的地方都会出现问题"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们来分析一下写流程，第一步，’DEL缓存失败’怎么办？流程是否还继续走？如果继续执行，那么从’更新完DB’到异步’刷新缓存’缓存期间，数据处于滞后状态。而且如果缓存处于不可写状态，那么异步刷新那步也可能会失败，那缓存就会长期处于旧数据，问题就比较严重了"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果A线程更新数据库内容失败，导致B线程请求再次访问缓存时，发现redis里面没数据，缓存缺失，再去读取mysql时， 从数据库中读取到旧值"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"2. 并发问题"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"**写写并发：**试想一下，同时有多个服务器的多个线程进行’步骤1.2更新DB’，更新DB完成之后，它们就要进行异步刷缓存，我们都知道多服务器的异步操作，是无法保证顺序的，所以后面的刷新操作存在相互覆盖的并发问题，"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"也就是说，存在先更新的DB操作，反而很晚才去刷新缓存"}]},{"type":"text","value":"，那这个时候，数据也是错的"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"**读写并发：**再试想一下，服务器A在进行’读操作’，，在A服务器刚完成2.2时，服务器B在进行’写操作’，假设B服务器1.3完成之后，服务器A的1.3才被执行，这个时候就相当于更新前的老数据写入缓存，最终数据还是错的"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"方案总结"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"适合大部分的业务场景，很多人都在用，香还是很香的，实现起来也简单。\n"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"适合使用的场景：并发量、一致性要求都不是很高的情况"}]},{"type":"text","value":"。\n我觉得这个方案有一个比较大的缺陷在于"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"刷新缓存有可能会失败，而失败之后缓存中数据就一直会处于错误状态，所以它并不能保证数据的最终一致性"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"为了保证“数据最终一致性”，我们引入binlog，通过解析binlog来刷新缓存，这样即使刷新失败，依然可以进行日志回放，再次刷新缓存"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/db-and-cache-02-01.jpg","alt":"img"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"写流程："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一步先删除缓存，删除之后再更新DB，我们监听从库(资源少的话主库也ok)的binlog，通过分析binlog我们解析出需要需要刷新的数据，然后读主库把最新的数据写入缓存。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这里需要提一下：最后刷新前的读主库或者读从库，甚至不读库直接通过binlog解析出需要的数据都是ok的，这由业务决定，"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"比如刷新的数据只是表的一行，那直接通过binlog就完全能解析出来；然而如果需要刷新的数据来自多行，多张表，甚至多个库的话，那就需要读主库或是从库才行"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"读流程："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据刷回缓存"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"方案分析"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"优点剖析"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"1. 容灾"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"写步骤1.4或1.5 如果失败，可以进行日志回放，再次重试。\n无论步骤1.1是否删除成功，后续的刷新操作是有保证的"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"妈耶，怎么就一个优点，讲道理这个其实很常用的，那我们再来看看缺点"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"缺点剖析"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"分析缺点之前，我们先来看一下知识点"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"对于同一张表的同一条记录的更新，Databus会以串行形式的通知下游服务，也就是说，只有当我们正确返回后，它才会推送该记录的下一次更新。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"对于同一张表的不同记录的更新， Databus会以事件时间为顺序的通知下游服务，但并不会等待我们返回后才推送下一条，也就是说它是非串行的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"对于不同表，根据其下游的消费速度，不同表之间没有明确的时间顺序。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"1. 只适合简单业务，复杂业务容易发生并发问题"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这里先来解释一下这里说的“简单业务”是啥意思？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"简单业务：每次需要刷新的数据，都来自"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"单表单行"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"为什么复杂业务就不行呢？我举个例子\n我们假设 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"一个订单 = A表信息 + B表信息"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/db-and-cache-02-02.jpg","alt":"img"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"由于A表先变化，经过1，2，3步后，线程1获取了A’B （A表是新数据，B表的老数据），当线程1还没来得及刷新缓存时，并发发生了："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"此时，B表发生了更新，经过4，5，6，7将最新的数据A’B’写入缓存，此时此刻缓存数据是符合要求的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但是，后来线程1进行了第8步，将A’B写入数据，使得缓存最终结果 与 DB 不一致。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{},"children":[{"type":"text","value":"缺点1的改进"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"针对单库多表单次更新的改进：利用事务"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/db-and-cache-02-03.jpg","alt":""},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"当AB表的更新发生在一个事务内时，不管线程1、线程2如何读取，他们都能获取两张表的最新数据，所以刷新缓存的数据都是符合要求的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但是这种方案具有局限性：那就是只对单次更新有效，或者说更新频率低的情况下才适应，比如我们并发的单独更新C表，并发问题依然会发生。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"这种方案只针对多表单次更新的情况"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"针对多表多次更新的改进：增量更新"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/db-and-cache-02-04.jpg","alt":"img"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"每张表的更新，在同步缓存时，只获取该表的字段覆盖缓存。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这样，线程1，线程2总能获取对应表最新的字段，而且Databus对于同表同行会以串行的形式通知下游，所以能保证缓存的最终一致性。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这里有一点需要提一下：更新“某张表多行记录“时，这个操作要在一个事务内，不然并发问题依然存在，正如前面分析的"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"2. 依然是并发问题"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"即使对于"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"缺点1"}]},{"type":"text","value":"我们提出了改进方案，虽然它解决了部分问题，但在极端场景下依然存在并发问题。\n这个场景，就是"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"缓存中没有数据"}]},{"type":"text","value":"的情况："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"读的时候，缓存中的数据已失效，此时又发生了更新"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"数据更新的时候，缓存中的数据已失效，此时又发生了更新"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这个时候，我们在上面提到的“增量更新”就不起作用了，我们需要读取"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"所有的表"}]},{"type":"text","value":"来拼凑出初始数据，那这个时候又涉及到"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"读所有表的操作"}]},{"type":"text","value":"了，那我们在"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"缺点1"}]},{"type":"text","value":"中提到的并发问题会再次发生"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"方案总结"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"适合使用的场景：业务简单，读写QPS比较低的情况"}]},{"type":"text","value":"。\n今天这个方案呢，优缺点都比较明显，binlog用来刷新缓存是一个很棒的选择，它天然的顺序性用来做同步操作很具有优势；其实"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"它的并发问题来自于Canal 或 Databus。拿Databus来说，由于不同行、表、库的binlog的消费并不是时间串行的"}]},{"type":"text","value":"，那怎么解决这个问题呢"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"强一致性，包含两种含义："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"缓存和DB数据一致"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"缓存中没有数据（或者说：不会去读缓存中的老版本数据）"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"首先我们来分析一下，既然已经实现了“"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"最终一致性"}]},{"type":"text","value":"”，那它和“"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"强一致性"}]},{"type":"text","value":"”的区别是什么呢？没错，就是“"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"时间差"}]},{"type":"text","value":"”，所以："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"“"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"最终一致性方案"}]},{"type":"text","value":"” + “"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"时间差"}]},{"type":"text","value":"” = “"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"强一致性方案"}]},{"type":"text","value":"”"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"那我们的工作呢，就是加上时间差，实现方式："},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"我们加一个缓存，将近期被修改的数据进行标记锁定。读的时候，标记锁定的数据强行走DB，没锁定的数据，先走缓存"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/db-and-cache-04-01.jpg","alt":"img"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"写流程："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们把修改的数据通过Cache_0标记“正在被修改”，如果标记成功，则继续往下走；"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"那如果标记失败，则要放弃这次修改。"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"何为标记锁定呢？比如你可以设定一个有效期为10S的key，Key存在即为锁定。一般来说10S对于后面的同步操作来说基本是够了~"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"如果说，还想更严谨一点，怕DB主从延迟太久、MQ延迟太久，或Databus监听的从库挂机之类的情况，我们可以考虑增加一个监控定时任务"}]},{"type":"text","value":"。\n比如我们增加一个时间间隔2S的worker的去对比以下两个数据："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"时间1： 最后修改数据库的时间"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"VS"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"时间2： 最后由更新引起的’MQ刷新缓存对应数据的实际更新数据库’的时间"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"数据1： 可由步骤1.1获得，并存储\n数据2： 需要由binlog中解析获得，需要透传到MQ，这样后面就能存储了\n这里提一下：如果多库的情况的话，存储这两个key需要与库一一对应"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果 时间1 VS 时间2 相差超过5S，那我们就自动把相应的缓存分片读降级。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"读流程："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"先读Cache_0，看看要读的数据是否被标记，如果被标记，则直接读主库；"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"方案分析"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"优点剖析"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"1. 容灾完善"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们一步一步来分析："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h6","properties":{},"children":[{"type":"text","value":"写流程容灾分析"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"写1.1 标记失败"}]},{"type":"text","value":"：没关系，放弃整个更新操作"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"写1.3 DEL缓存失败"}]},{"type":"text","value":"：没关系，后面会覆盖"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"写1.5 写MQ失败"}]},{"type":"text","value":"：没关系，Databus或Canal都会重试"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"消费MQ的：1.6 || 1.7 失败"}]},{"type":"text","value":"：没关系，重新消费即可"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h6","properties":{},"children":[{"type":"text","value":"读流程容灾分析"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"读2.1 读Cache_0失败"}]},{"type":"text","value":"：没关系，直接读主库"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"读2.3 异步写MQ失败"}]},{"type":"text","value":"：没关系，缓存为空，是OK的，下次还读库就好了"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"2. 无并发问题"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这个方案让“读库 + 刷缓存”的操作串行化，这就不存在老数据覆盖新数据的并发问题了"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"缺点剖析"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"1. 增加Cache_0强依赖"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这个其实有点没办法，你要强一致性，必然要牺牲一些的。\n但是呢，你这个可以吧Cache_0设计成多机器多分片，这样的话，即使部分分片挂了，也只有小部分流量透过Cache直接打到DB上，这是完全是可接受的"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"2. 复杂度是比较高的"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"涉及到Databus、MQ、定时任务等等组件，实现起来复杂度还是有的"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"方案总结"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"OK，到此呢，我们已经实现了**“数据库和缓存强一致性”**，这个系列就先这样啦，等我学到了更好的方案，再来分享~"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://blog.kido.site/2018/11/24/db-and-cache-preface/"},"children":[{"type":"text","value":"https://blog.kido.site/2018/11/24/db-and-cache-preface/"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"style","properties":{"className":["grvsc-styles"]},"children":[{"type":"text","value":"\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n"}]}],"data":{"quirksMode":false}},"html":"<h1 id=\"Redis分布式缓存\">Redis分布式缓存</h1>\n<p updated=\"20220705131435\">用redis作为最基本的功能，缓存mysql中的数据，加快响应速度</p>\n<h1 id=\"双写一致性\">双写一致性</h1>\n<p updated=\"20220705131435\">双写一致性，是redis做为缓存的时候一道非常经典的问题</p>\n<p updated=\"20220705131435\">因为无论先操作db还是cache，都会有各自的问题，根本原因是cache和db的更新不是一个原子操作，因此总会有不一致的问题。</p>\n<p updated=\"20220705131435\">一致性可以分为三个等级:</p>\n<ol updated=\"20220705131435\">\n<li id=\"20220705131435-4nejdwv\" updated=\"20220705131435\">\n<p updated=\"20220705131435\">强一致性</p>\n<ul updated=\"20220705131435\">\n<li id=\"20220705131435-8spaemj\" updated=\"20220705131435\">\n<p updated=\"20220705131435\">这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大</p>\n</li>\n</ul>\n</li>\n<li id=\"20220705131435-o819opf\" updated=\"20220705131435\">\n<p updated=\"20220705131435\">弱一致性</p>\n<ul updated=\"20220705131435\">\n<li id=\"20220705131435-n03pclm\" updated=\"20220705131435\">\n<p updated=\"20220705131435\">这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态</p>\n</li>\n</ul>\n</li>\n<li id=\"20220705131435-7uwaaxn\" updated=\"20220705131435\">\n<p updated=\"20220705131435\">最终一致性</p>\n<ul updated=\"20220705131435\">\n<li id=\"20220705131435-o264b2e\" updated=\"20220705131435\">\n<p updated=\"20220705131435\">最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型</p>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"缓存更新策略\">缓存更新策略</h1>\n<h2 id=\"最常见的策略\">最常见的策略</h2>\n<p updated=\"20220705131435\"><span class=\"img\"><img src=\"https://www.shiyitopo.tech/uPic/db-and-cache-01-01.jpg\" alt=\"img\" /></span></p>\n<h4 id=\"优点剖析\">优点剖析</h4>\n<h4 id=\"1---先淘汰缓存-再写数据库--合理\">1. “先淘汰缓存，再写数据库” 合理</h4>\n<p updated=\"20220705131435\">为什么说这也算优点呢？试想一下</p>\n<p updated=\"20220705131435\">如果把写流程改一下：<strong>先更新缓存，再更新DB</strong>。 如果我们更新缓存成功，而更新数据库失败，就会导致缓存中的数据是错误的，而我们大部分的业务一般能忍受数据延迟，但是数据错误这是无法接受的，所以先淘汰缓存是比较合理的。 如果把写流程改一下：<strong>不删缓存，先更新DB，再更新缓存</strong>。 如果我们更新DB成功，而更新缓存失败，则会导致缓存中就会一直是旧的数据（也算是一种错误数据），所以先淘汰缓存是比较合理的。</p>\n<h4 id=\"2--异步刷新-补缺补漏\">2. 异步刷新，补缺补漏</h4>\n<p updated=\"20220705131435\">在很多业务场景中，缓存只是辅助，<strong>所以在很多业务中，缓存的读写失败不会影响主流程</strong>，啥意思呢？就是说很多情况下，即使操作缓存失败（比如步骤1.1中的’DEL缓存失败’），程序还是会继续往下走（继续步骤1.2 更新数据库)，所以这个时候异步刷新就能在一定程度上，对1.1的失败进行错误数据的修补</p>\n<h4 id=\"缺点剖析\">缺点剖析</h4>\n<h4 id=\"1--容灾不足\">1. 容灾不足</h4>\n<blockquote updated=\"20220705131435\">\n<p updated=\"20220705131435\">在分布式领域，“Everything will fails”，任何可能出现问题的地方都会出现问题</p>\n</blockquote>\n<p updated=\"20220705131435\">我们来分析一下写流程，第一步，’DEL缓存失败’怎么办？流程是否还继续走？如果继续执行，那么从’更新完DB’到异步’刷新缓存’缓存期间，数据处于滞后状态。而且如果缓存处于不可写状态，那么异步刷新那步也可能会失败，那缓存就会长期处于旧数据，问题就比较严重了</p>\n<p updated=\"20220705131435\">如果A线程更新数据库内容失败，导致B线程请求再次访问缓存时，发现redis里面没数据，缓存缺失，再去读取mysql时， 从数据库中读取到旧值</p>\n<h4 id=\"2--并发问题\">2. 并发问题</h4>\n<p updated=\"20220705131435\"><strong>写写并发：</strong>试想一下，同时有多个服务器的多个线程进行’步骤1.2更新DB’，更新DB完成之后，它们就要进行异步刷缓存，我们都知道多服务器的异步操作，是无法保证顺序的，所以后面的刷新操作存在相互覆盖的并发问题，<strong>也就是说，存在先更新的DB操作，反而很晚才去刷新缓存</strong>，那这个时候，数据也是错的</p>\n<p updated=\"20220705131435\"><strong>读写并发：</strong>再试想一下，服务器A在进行’读操作’，，在A服务器刚完成2.2时，服务器B在进行’写操作’，假设B服务器1.3完成之后，服务器A的1.3才被执行，这个时候就相当于更新前的老数据写入缓存，最终数据还是错的</p>\n<h4 id=\"方案总结\">方案总结</h4>\n<p updated=\"20220705131435\">适合大部分的业务场景，很多人都在用，香还是很香的，实现起来也简单。<br />\n<strong>适合使用的场景：并发量、一致性要求都不是很高的情况</strong>。<br />\n我觉得这个方案有一个比较大的缺陷在于<strong>刷新缓存有可能会失败，而失败之后缓存中数据就一直会处于错误状态，所以它并不能保证数据的最终一致性</strong></p>\n<p updated=\"20220705131435\">为了保证“数据最终一致性”，我们引入binlog，通过解析binlog来刷新缓存，这样即使刷新失败，依然可以进行日志回放，再次刷新缓存</p>\n<p updated=\"20220705131435\"><span class=\"img\"><img src=\"https://www.shiyitopo.tech/uPic/db-and-cache-02-01.jpg\" alt=\"img\" /></span></p>\n<h3 id=\"写流程-\">写流程：</h3>\n<p updated=\"20220705131435\">第一步先删除缓存，删除之后再更新DB，我们监听从库(资源少的话主库也ok)的binlog，通过分析binlog我们解析出需要需要刷新的数据，然后读主库把最新的数据写入缓存。</p>\n<blockquote updated=\"20220705131435\">\n<p updated=\"20220705131435\">这里需要提一下：最后刷新前的读主库或者读从库，甚至不读库直接通过binlog解析出需要的数据都是ok的，这由业务决定，<strong>比如刷新的数据只是表的一行，那直接通过binlog就完全能解析出来；然而如果需要刷新的数据来自多行，多张表，甚至多个库的话，那就需要读主库或是从库才行</strong></p>\n</blockquote>\n<h3 id=\"读流程-\">读流程：</h3>\n<p updated=\"20220705131435\">第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据刷回缓存</p>\n<h2 id=\"方案分析\">方案分析</h2>\n<h3 id=\"优点剖析-\">优点剖析</h3>\n<h4 id=\"1--容灾\">1. 容灾</h4>\n<p updated=\"20220705131435\">写步骤1.4或1.5 如果失败，可以进行日志回放，再次重试。<br />\n无论步骤1.1是否删除成功，后续的刷新操作是有保证的</p>\n<blockquote updated=\"20220705131435\">\n<p updated=\"20220705131435\">妈耶，怎么就一个优点，讲道理这个其实很常用的，那我们再来看看缺点</p>\n</blockquote>\n<h3 id=\"缺点剖析-\">缺点剖析</h3>\n<blockquote updated=\"20220705131435\">\n<p updated=\"20220705131435\">分析缺点之前，我们先来看一下知识点</p>\n<ol updated=\"20220705131435\">\n<li id=\"20220705131435-1cl6vpv\" updated=\"20220705131435\">\n<p updated=\"20220705131435\">对于同一张表的同一条记录的更新，Databus会以串行形式的通知下游服务，也就是说，只有当我们正确返回后，它才会推送该记录的下一次更新。</p>\n</li>\n<li id=\"20220705131435-2r6r6ih\" updated=\"20220705131435\">\n<p updated=\"20220705131435\">对于同一张表的不同记录的更新， Databus会以事件时间为顺序的通知下游服务，但并不会等待我们返回后才推送下一条，也就是说它是非串行的。</p>\n</li>\n<li id=\"20220705131435-axzxp6x\" updated=\"20220705131435\">\n<p updated=\"20220705131435\">对于不同表，根据其下游的消费速度，不同表之间没有明确的时间顺序。</p>\n</li>\n</ol>\n</blockquote>\n<h4 id=\"1--只适合简单业务-复杂业务容易发生并发问题\">1. 只适合简单业务，复杂业务容易发生并发问题</h4>\n<p updated=\"20220705131435\">这里先来解释一下这里说的“简单业务”是啥意思？</p>\n<blockquote updated=\"20220705131435\">\n<p updated=\"20220705131435\">简单业务：每次需要刷新的数据，都来自<strong>单表单行</strong>。</p>\n</blockquote>\n<p updated=\"20220705131435\">为什么复杂业务就不行呢？我举个例子<br />\n我们假设 <strong>一个订单 = A表信息 + B表信息</strong></p>\n<p updated=\"20220705131435\"><span class=\"img\"><img src=\"https://www.shiyitopo.tech/uPic/db-and-cache-02-02.jpg\" alt=\"img\" /></span></p>\n<p updated=\"20220705131435\">由于A表先变化，经过1，2，3步后，线程1获取了A’B （A表是新数据，B表的老数据），当线程1还没来得及刷新缓存时，并发发生了：</p>\n<p updated=\"20220705131435\">此时，B表发生了更新，经过4，5，6，7将最新的数据A’B’写入缓存，此时此刻缓存数据是符合要求的。</p>\n<p updated=\"20220705131435\">但是，后来线程1进行了第8步，将A’B写入数据，使得缓存最终结果 与 DB 不一致。</p>\n<h5 id=\"缺点1的改进\">缺点1的改进</h5>\n<ul updated=\"20220705131435\">\n<li id=\"20220705131435-dfu4qo5\" updated=\"20220705131435\">\n<p updated=\"20220705131435\"><strong>针对单库多表单次更新的改进：利用事务</strong></p>\n</li>\n</ul>\n<p updated=\"20220705131435\"><span class=\"img\"><img src=\"https://www.shiyitopo.tech/uPic/db-and-cache-02-03.jpg\" alt=\"\" /></span></p>\n<p updated=\"20220705131435\">当AB表的更新发生在一个事务内时，不管线程1、线程2如何读取，他们都能获取两张表的最新数据，所以刷新缓存的数据都是符合要求的。</p>\n<blockquote updated=\"20220705131435\">\n<p updated=\"20220705131435\">但是这种方案具有局限性：那就是只对单次更新有效，或者说更新频率低的情况下才适应，比如我们并发的单独更新C表，并发问题依然会发生。</p>\n</blockquote>\n<p updated=\"20220705131435\">所以<strong>这种方案只针对多表单次更新的情况</strong>。</p>\n<ul updated=\"20220705131435\">\n<li id=\"20220705131435-p182xw7\" updated=\"20220705131435\">\n<p updated=\"20220705131435\"><strong>针对多表多次更新的改进：增量更新</strong></p>\n</li>\n</ul>\n<p updated=\"20220705131435\"><span class=\"img\"><img src=\"https://www.shiyitopo.tech/uPic/db-and-cache-02-04.jpg\" alt=\"img\" /></span></p>\n<p updated=\"20220705131435\">每张表的更新，在同步缓存时，只获取该表的字段覆盖缓存。</p>\n<p updated=\"20220705131435\">这样，线程1，线程2总能获取对应表最新的字段，而且Databus对于同表同行会以串行的形式通知下游，所以能保证缓存的最终一致性。</p>\n<blockquote updated=\"20220705131435\">\n<p updated=\"20220705131435\">这里有一点需要提一下：更新“某张表多行记录“时，这个操作要在一个事务内，不然并发问题依然存在，正如前面分析的</p>\n</blockquote>\n<h4 id=\"2--依然是并发问题\">2. 依然是并发问题</h4>\n<p updated=\"20220705131435\">即使对于<strong>缺点1</strong>我们提出了改进方案，虽然它解决了部分问题，但在极端场景下依然存在并发问题。<br />\n这个场景，就是<strong>缓存中没有数据</strong>的情况：</p>\n<ul updated=\"20220705131435\">\n<li id=\"20220705131435-gud8r0s\" updated=\"20220705131435\">\n<p updated=\"20220705131435\"><strong>读的时候，缓存中的数据已失效，此时又发生了更新</strong></p>\n</li>\n<li id=\"20220705131435-3ww25nb\" updated=\"20220705131435\">\n<p updated=\"20220705131435\"><strong>数据更新的时候，缓存中的数据已失效，此时又发生了更新</strong></p>\n</li>\n</ul>\n<p updated=\"20220705131435\">这个时候，我们在上面提到的“增量更新”就不起作用了，我们需要读取<strong>所有的表</strong>来拼凑出初始数据，那这个时候又涉及到<strong>读所有表的操作</strong>了，那我们在<strong>缺点1</strong>中提到的并发问题会再次发生</p>\n<h2 id=\"方案总结-\">方案总结</h2>\n<p updated=\"20220705131435\"><strong>适合使用的场景：业务简单，读写QPS比较低的情况</strong>。<br />\n今天这个方案呢，优缺点都比较明显，binlog用来刷新缓存是一个很棒的选择，它天然的顺序性用来做同步操作很具有优势；其实<strong>它的并发问题来自于Canal 或 Databus。拿Databus来说，由于不同行、表、库的binlog的消费并不是时间串行的</strong>，那怎么解决这个问题呢</p>\n<blockquote updated=\"20220705131435\">\n<p updated=\"20220705131435\">强一致性，包含两种含义：</p>\n<ul updated=\"20220705131435\">\n<li id=\"20220705131435-thlocfc\" updated=\"20220705131435\">\n<p updated=\"20220705131435\">缓存和DB数据一致</p>\n</li>\n<li id=\"20220705131435-xmuk3bo\" updated=\"20220705131435\">\n<p updated=\"20220705131435\">缓存中没有数据（或者说：不会去读缓存中的老版本数据）</p>\n</li>\n</ul>\n</blockquote>\n<p updated=\"20220705131435\">首先我们来分析一下，既然已经实现了“<strong>最终一致性</strong>”，那它和“<strong>强一致性</strong>”的区别是什么呢？没错，就是“<strong>时间差</strong>”，所以：</p>\n<blockquote updated=\"20220705131435\">\n<p updated=\"20220705131435\">“<strong>最终一致性方案</strong>” + “<strong>时间差</strong>” = “<strong>强一致性方案</strong>”</p>\n</blockquote>\n<p updated=\"20220705131435\">那我们的工作呢，就是加上时间差，实现方式：<strong>我们加一个缓存，将近期被修改的数据进行标记锁定。读的时候，标记锁定的数据强行走DB，没锁定的数据，先走缓存</strong></p>\n<p updated=\"20220705131435\"><span class=\"img\"><img src=\"https://www.shiyitopo.tech/uPic/db-and-cache-04-01.jpg\" alt=\"img\" /></span></p>\n<h3 id=\"写流程--\">写流程：</h3>\n<p updated=\"20220705131435\">我们把修改的数据通过Cache_0标记“正在被修改”，如果标记成功，则继续往下走；<strong>那如果标记失败，则要放弃这次修改。</strong></p>\n<blockquote updated=\"20220705131435\">\n<p updated=\"20220705131435\">何为标记锁定呢？比如你可以设定一个有效期为10S的key，Key存在即为锁定。一般来说10S对于后面的同步操作来说基本是够了~</p>\n</blockquote>\n<p updated=\"20220705131435\"><strong>如果说，还想更严谨一点，怕DB主从延迟太久、MQ延迟太久，或Databus监听的从库挂机之类的情况，我们可以考虑增加一个监控定时任务</strong>。<br />\n比如我们增加一个时间间隔2S的worker的去对比以下两个数据：</p>\n<ul updated=\"20220705131435\">\n<li id=\"20220705131435-stka9ql\" updated=\"20220705131435\">\n<p updated=\"20220705131435\"><strong>时间1： 最后修改数据库的时间</strong><br />\n<strong>VS</strong></p>\n</li>\n<li id=\"20220705131435-bo9rsfc\" updated=\"20220705131435\">\n<p updated=\"20220705131435\"><strong>时间2： 最后由更新引起的’MQ刷新缓存对应数据的实际更新数据库’的时间</strong></p>\n</li>\n</ul>\n<blockquote updated=\"20220705131435\">\n<p updated=\"20220705131435\">数据1： 可由步骤1.1获得，并存储<br />\n数据2： 需要由binlog中解析获得，需要透传到MQ，这样后面就能存储了<br />\n这里提一下：如果多库的情况的话，存储这两个key需要与库一一对应</p>\n</blockquote>\n<p updated=\"20220705131435\">如果 时间1 VS 时间2 相差超过5S，那我们就自动把相应的缓存分片读降级。</p>\n<h3 id=\"读流程--\">读流程：</h3>\n<p updated=\"20220705131435\">先读Cache_0，看看要读的数据是否被标记，如果被标记，则直接读主库；</p>\n<h2 id=\"方案分析-\">方案分析</h2>\n<h3 id=\"优点剖析--\">优点剖析</h3>\n<h4 id=\"1--容灾完善\">1. 容灾完善</h4>\n<p updated=\"20220705131435\">我们一步一步来分析：</p>\n<h6 id=\"写流程容灾分析\">写流程容灾分析</h6>\n<ul updated=\"20220705131435\">\n<li id=\"20220705131435-92uojtp\" updated=\"20220705131435\">\n<p updated=\"20220705131435\"><strong>写1.1 标记失败</strong>：没关系，放弃整个更新操作</p>\n</li>\n<li id=\"20220705131435-34q6pjr\" updated=\"20220705131435\">\n<p updated=\"20220705131435\"><strong>写1.3 DEL缓存失败</strong>：没关系，后面会覆盖</p>\n</li>\n<li id=\"20220705131435-zhh9u8h\" updated=\"20220705131435\">\n<p updated=\"20220705131435\"><strong>写1.5 写MQ失败</strong>：没关系，Databus或Canal都会重试</p>\n</li>\n<li id=\"20220705131435-n05tzn3\" updated=\"20220705131435\">\n<p updated=\"20220705131435\"><strong>消费MQ的：1.6 || 1.7 失败</strong>：没关系，重新消费即可</p>\n</li>\n</ul>\n<h6 id=\"读流程容灾分析\">读流程容灾分析</h6>\n<ul updated=\"20220705131435\">\n<li id=\"20220705131435-q0cvx80\" updated=\"20220705131435\">\n<p updated=\"20220705131435\"><strong>读2.1 读Cache_0失败</strong>：没关系，直接读主库</p>\n</li>\n<li id=\"20220705131435-vh7tj0f\" updated=\"20220705131435\">\n<p updated=\"20220705131435\"><strong>读2.3 异步写MQ失败</strong>：没关系，缓存为空，是OK的，下次还读库就好了</p>\n</li>\n</ul>\n<h4 id=\"2--无并发问题\">2. 无并发问题</h4>\n<p updated=\"20220705131435\">这个方案让“读库 + 刷缓存”的操作串行化，这就不存在老数据覆盖新数据的并发问题了</p>\n<h3 id=\"缺点剖析--\">缺点剖析</h3>\n<h4 id=\"1--增加Cache-0强依赖\">1. 增加Cache_0强依赖</h4>\n<p updated=\"20220705131435\">这个其实有点没办法，你要强一致性，必然要牺牲一些的。<br />\n但是呢，你这个可以吧Cache_0设计成多机器多分片，这样的话，即使部分分片挂了，也只有小部分流量透过Cache直接打到DB上，这是完全是可接受的</p>\n<h4 id=\"2--复杂度是比较高的\">2. 复杂度是比较高的</h4>\n<p updated=\"20220705131435\">涉及到Databus、MQ、定时任务等等组件，实现起来复杂度还是有的</p>\n<h2 id=\"方案总结--\">方案总结</h2>\n<p updated=\"20220705131435\">OK，到此呢，我们已经实现了<strong>“数据库和缓存强一致性”</strong>，这个系列就先这样啦，等我学到了更好的方案，再来分享~</p>\n<p updated=\"20220705131435\">https://blog.kido.site/2018/11/24/db-and-cache-preface/</p>\n","articleNode":{"field":{"contentType":"topic","topic":"redis"},"frontmatter":{"id":"/topic/redis/Redis分布式缓存","title":"Redis分布式缓存","date":"2022-04-28 14:17","absolute_path":"/topic/redis/Redis分布式缓存"},"htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"Redis分布式缓存"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"用redis作为最基本的功能，缓存mysql中的数据，加快响应速度"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"双写一致性"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"双写一致性，是redis做为缓存的时候一道非常经典的问题"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因为无论先操作db还是cache，都会有各自的问题，根本原因是cache和db的更新不是一个原子操作，因此总会有不一致的问题。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"一致性可以分为三个等级:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"强一致性"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"弱一致性"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"最终一致性"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"缓存更新策略"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"最常见的策略"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/db-and-cache-01-01.jpg","alt":"img"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"优点剖析"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"1. “先淘汰缓存，再写数据库” 合理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"为什么说这也算优点呢？试想一下"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果把写流程改一下："},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"先更新缓存，再更新DB"}]},{"type":"text","value":"。 如果我们更新缓存成功，而更新数据库失败，就会导致缓存中的数据是错误的，而我们大部分的业务一般能忍受数据延迟，但是数据错误这是无法接受的，所以先淘汰缓存是比较合理的。 如果把写流程改一下："},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"不删缓存，先更新DB，再更新缓存"}]},{"type":"text","value":"。 如果我们更新DB成功，而更新缓存失败，则会导致缓存中就会一直是旧的数据（也算是一种错误数据），所以先淘汰缓存是比较合理的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"2. 异步刷新，补缺补漏"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在很多业务场景中，缓存只是辅助，"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"所以在很多业务中，缓存的读写失败不会影响主流程"}]},{"type":"text","value":"，啥意思呢？就是说很多情况下，即使操作缓存失败（比如步骤1.1中的’DEL缓存失败’），程序还是会继续往下走（继续步骤1.2 更新数据库)，所以这个时候异步刷新就能在一定程度上，对1.1的失败进行错误数据的修补"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"缺点剖析"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"1. 容灾不足"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在分布式领域，“Everything will fails”，任何可能出现问题的地方都会出现问题"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们来分析一下写流程，第一步，’DEL缓存失败’怎么办？流程是否还继续走？如果继续执行，那么从’更新完DB’到异步’刷新缓存’缓存期间，数据处于滞后状态。而且如果缓存处于不可写状态，那么异步刷新那步也可能会失败，那缓存就会长期处于旧数据，问题就比较严重了"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果A线程更新数据库内容失败，导致B线程请求再次访问缓存时，发现redis里面没数据，缓存缺失，再去读取mysql时， 从数据库中读取到旧值"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"2. 并发问题"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"**写写并发：**试想一下，同时有多个服务器的多个线程进行’步骤1.2更新DB’，更新DB完成之后，它们就要进行异步刷缓存，我们都知道多服务器的异步操作，是无法保证顺序的，所以后面的刷新操作存在相互覆盖的并发问题，"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"也就是说，存在先更新的DB操作，反而很晚才去刷新缓存"}]},{"type":"text","value":"，那这个时候，数据也是错的"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"**读写并发：**再试想一下，服务器A在进行’读操作’，，在A服务器刚完成2.2时，服务器B在进行’写操作’，假设B服务器1.3完成之后，服务器A的1.3才被执行，这个时候就相当于更新前的老数据写入缓存，最终数据还是错的"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"方案总结"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"适合大部分的业务场景，很多人都在用，香还是很香的，实现起来也简单。\n"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"适合使用的场景：并发量、一致性要求都不是很高的情况"}]},{"type":"text","value":"。\n我觉得这个方案有一个比较大的缺陷在于"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"刷新缓存有可能会失败，而失败之后缓存中数据就一直会处于错误状态，所以它并不能保证数据的最终一致性"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"为了保证“数据最终一致性”，我们引入binlog，通过解析binlog来刷新缓存，这样即使刷新失败，依然可以进行日志回放，再次刷新缓存"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/db-and-cache-02-01.jpg","alt":"img"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"写流程："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一步先删除缓存，删除之后再更新DB，我们监听从库(资源少的话主库也ok)的binlog，通过分析binlog我们解析出需要需要刷新的数据，然后读主库把最新的数据写入缓存。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这里需要提一下：最后刷新前的读主库或者读从库，甚至不读库直接通过binlog解析出需要的数据都是ok的，这由业务决定，"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"比如刷新的数据只是表的一行，那直接通过binlog就完全能解析出来；然而如果需要刷新的数据来自多行，多张表，甚至多个库的话，那就需要读主库或是从库才行"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"读流程："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据刷回缓存"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"方案分析"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"优点剖析"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"1. 容灾"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"写步骤1.4或1.5 如果失败，可以进行日志回放，再次重试。\n无论步骤1.1是否删除成功，后续的刷新操作是有保证的"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"妈耶，怎么就一个优点，讲道理这个其实很常用的，那我们再来看看缺点"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"缺点剖析"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"分析缺点之前，我们先来看一下知识点"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"对于同一张表的同一条记录的更新，Databus会以串行形式的通知下游服务，也就是说，只有当我们正确返回后，它才会推送该记录的下一次更新。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"对于同一张表的不同记录的更新， Databus会以事件时间为顺序的通知下游服务，但并不会等待我们返回后才推送下一条，也就是说它是非串行的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"对于不同表，根据其下游的消费速度，不同表之间没有明确的时间顺序。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"1. 只适合简单业务，复杂业务容易发生并发问题"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这里先来解释一下这里说的“简单业务”是啥意思？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"简单业务：每次需要刷新的数据，都来自"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"单表单行"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"为什么复杂业务就不行呢？我举个例子\n我们假设 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"一个订单 = A表信息 + B表信息"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/db-and-cache-02-02.jpg","alt":"img"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"由于A表先变化，经过1，2，3步后，线程1获取了A’B （A表是新数据，B表的老数据），当线程1还没来得及刷新缓存时，并发发生了："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"此时，B表发生了更新，经过4，5，6，7将最新的数据A’B’写入缓存，此时此刻缓存数据是符合要求的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但是，后来线程1进行了第8步，将A’B写入数据，使得缓存最终结果 与 DB 不一致。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h5","properties":{},"children":[{"type":"text","value":"缺点1的改进"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"针对单库多表单次更新的改进：利用事务"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/db-and-cache-02-03.jpg","alt":""},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"当AB表的更新发生在一个事务内时，不管线程1、线程2如何读取，他们都能获取两张表的最新数据，所以刷新缓存的数据都是符合要求的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但是这种方案具有局限性：那就是只对单次更新有效，或者说更新频率低的情况下才适应，比如我们并发的单独更新C表，并发问题依然会发生。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"这种方案只针对多表单次更新的情况"}]},{"type":"text","value":"。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"针对多表多次更新的改进：增量更新"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/db-and-cache-02-04.jpg","alt":"img"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"每张表的更新，在同步缓存时，只获取该表的字段覆盖缓存。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这样，线程1，线程2总能获取对应表最新的字段，而且Databus对于同表同行会以串行的形式通知下游，所以能保证缓存的最终一致性。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这里有一点需要提一下：更新“某张表多行记录“时，这个操作要在一个事务内，不然并发问题依然存在，正如前面分析的"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"2. 依然是并发问题"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"即使对于"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"缺点1"}]},{"type":"text","value":"我们提出了改进方案，虽然它解决了部分问题，但在极端场景下依然存在并发问题。\n这个场景，就是"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"缓存中没有数据"}]},{"type":"text","value":"的情况："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"读的时候，缓存中的数据已失效，此时又发生了更新"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"数据更新的时候，缓存中的数据已失效，此时又发生了更新"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这个时候，我们在上面提到的“增量更新”就不起作用了，我们需要读取"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"所有的表"}]},{"type":"text","value":"来拼凑出初始数据，那这个时候又涉及到"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"读所有表的操作"}]},{"type":"text","value":"了，那我们在"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"缺点1"}]},{"type":"text","value":"中提到的并发问题会再次发生"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"方案总结"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"适合使用的场景：业务简单，读写QPS比较低的情况"}]},{"type":"text","value":"。\n今天这个方案呢，优缺点都比较明显，binlog用来刷新缓存是一个很棒的选择，它天然的顺序性用来做同步操作很具有优势；其实"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"它的并发问题来自于Canal 或 Databus。拿Databus来说，由于不同行、表、库的binlog的消费并不是时间串行的"}]},{"type":"text","value":"，那怎么解决这个问题呢"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"强一致性，包含两种含义："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"缓存和DB数据一致"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"缓存中没有数据（或者说：不会去读缓存中的老版本数据）"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"首先我们来分析一下，既然已经实现了“"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"最终一致性"}]},{"type":"text","value":"”，那它和“"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"强一致性"}]},{"type":"text","value":"”的区别是什么呢？没错，就是“"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"时间差"}]},{"type":"text","value":"”，所以："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"“"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"最终一致性方案"}]},{"type":"text","value":"” + “"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"时间差"}]},{"type":"text","value":"” = “"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"强一致性方案"}]},{"type":"text","value":"”"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"那我们的工作呢，就是加上时间差，实现方式："},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"我们加一个缓存，将近期被修改的数据进行标记锁定。读的时候，标记锁定的数据强行走DB，没锁定的数据，先走缓存"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/db-and-cache-04-01.jpg","alt":"img"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"写流程："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们把修改的数据通过Cache_0标记“正在被修改”，如果标记成功，则继续往下走；"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"那如果标记失败，则要放弃这次修改。"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"何为标记锁定呢？比如你可以设定一个有效期为10S的key，Key存在即为锁定。一般来说10S对于后面的同步操作来说基本是够了~"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"如果说，还想更严谨一点，怕DB主从延迟太久、MQ延迟太久，或Databus监听的从库挂机之类的情况，我们可以考虑增加一个监控定时任务"}]},{"type":"text","value":"。\n比如我们增加一个时间间隔2S的worker的去对比以下两个数据："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"时间1： 最后修改数据库的时间"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"VS"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"时间2： 最后由更新引起的’MQ刷新缓存对应数据的实际更新数据库’的时间"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"数据1： 可由步骤1.1获得，并存储\n数据2： 需要由binlog中解析获得，需要透传到MQ，这样后面就能存储了\n这里提一下：如果多库的情况的话，存储这两个key需要与库一一对应"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"如果 时间1 VS 时间2 相差超过5S，那我们就自动把相应的缓存分片读降级。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"读流程："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"先读Cache_0，看看要读的数据是否被标记，如果被标记，则直接读主库；"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"方案分析"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"优点剖析"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"1. 容灾完善"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"我们一步一步来分析："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h6","properties":{},"children":[{"type":"text","value":"写流程容灾分析"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"写1.1 标记失败"}]},{"type":"text","value":"：没关系，放弃整个更新操作"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"写1.3 DEL缓存失败"}]},{"type":"text","value":"：没关系，后面会覆盖"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"写1.5 写MQ失败"}]},{"type":"text","value":"：没关系，Databus或Canal都会重试"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"消费MQ的：1.6 || 1.7 失败"}]},{"type":"text","value":"：没关系，重新消费即可"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h6","properties":{},"children":[{"type":"text","value":"读流程容灾分析"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"读2.1 读Cache_0失败"}]},{"type":"text","value":"：没关系，直接读主库"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"读2.3 异步写MQ失败"}]},{"type":"text","value":"：没关系，缓存为空，是OK的，下次还读库就好了"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"2. 无并发问题"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这个方案让“读库 + 刷缓存”的操作串行化，这就不存在老数据覆盖新数据的并发问题了"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"缺点剖析"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"1. 增加Cache_0强依赖"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这个其实有点没办法，你要强一致性，必然要牺牲一些的。\n但是呢，你这个可以吧Cache_0设计成多机器多分片，这样的话，即使部分分片挂了，也只有小部分流量透过Cache直接打到DB上，这是完全是可接受的"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"2. 复杂度是比较高的"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"涉及到Databus、MQ、定时任务等等组件，实现起来复杂度还是有的"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"方案总结"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"OK，到此呢，我们已经实现了**“数据库和缓存强一致性”**，这个系列就先这样啦，等我学到了更好的方案，再来分享~"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://blog.kido.site/2018/11/24/db-and-cache-preface/"},"children":[{"type":"text","value":"https://blog.kido.site/2018/11/24/db-and-cache-preface/"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"style","properties":{"className":["grvsc-styles"]},"children":[{"type":"text","value":"\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n"}]}],"data":{"quirksMode":false}},"html":"<h1 id=\"Redis分布式缓存\">Redis分布式缓存</h1>\n<p updated=\"20220705131435\">用redis作为最基本的功能，缓存mysql中的数据，加快响应速度</p>\n<h1 id=\"双写一致性\">双写一致性</h1>\n<p updated=\"20220705131435\">双写一致性，是redis做为缓存的时候一道非常经典的问题</p>\n<p updated=\"20220705131435\">因为无论先操作db还是cache，都会有各自的问题，根本原因是cache和db的更新不是一个原子操作，因此总会有不一致的问题。</p>\n<p updated=\"20220705131435\">一致性可以分为三个等级:</p>\n<ol updated=\"20220705131435\">\n<li id=\"20220705131435-4nejdwv\" updated=\"20220705131435\">\n<p updated=\"20220705131435\">强一致性</p>\n<ul updated=\"20220705131435\">\n<li id=\"20220705131435-8spaemj\" updated=\"20220705131435\">\n<p updated=\"20220705131435\">这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大</p>\n</li>\n</ul>\n</li>\n<li id=\"20220705131435-o819opf\" updated=\"20220705131435\">\n<p updated=\"20220705131435\">弱一致性</p>\n<ul updated=\"20220705131435\">\n<li id=\"20220705131435-n03pclm\" updated=\"20220705131435\">\n<p updated=\"20220705131435\">这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态</p>\n</li>\n</ul>\n</li>\n<li id=\"20220705131435-7uwaaxn\" updated=\"20220705131435\">\n<p updated=\"20220705131435\">最终一致性</p>\n<ul updated=\"20220705131435\">\n<li id=\"20220705131435-o264b2e\" updated=\"20220705131435\">\n<p updated=\"20220705131435\">最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型</p>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"缓存更新策略\">缓存更新策略</h1>\n<h2 id=\"最常见的策略\">最常见的策略</h2>\n<p updated=\"20220705131435\"><span class=\"img\"><img src=\"https://www.shiyitopo.tech/uPic/db-and-cache-01-01.jpg\" alt=\"img\" /></span></p>\n<h4 id=\"优点剖析\">优点剖析</h4>\n<h4 id=\"1---先淘汰缓存-再写数据库--合理\">1. “先淘汰缓存，再写数据库” 合理</h4>\n<p updated=\"20220705131435\">为什么说这也算优点呢？试想一下</p>\n<p updated=\"20220705131435\">如果把写流程改一下：<strong>先更新缓存，再更新DB</strong>。 如果我们更新缓存成功，而更新数据库失败，就会导致缓存中的数据是错误的，而我们大部分的业务一般能忍受数据延迟，但是数据错误这是无法接受的，所以先淘汰缓存是比较合理的。 如果把写流程改一下：<strong>不删缓存，先更新DB，再更新缓存</strong>。 如果我们更新DB成功，而更新缓存失败，则会导致缓存中就会一直是旧的数据（也算是一种错误数据），所以先淘汰缓存是比较合理的。</p>\n<h4 id=\"2--异步刷新-补缺补漏\">2. 异步刷新，补缺补漏</h4>\n<p updated=\"20220705131435\">在很多业务场景中，缓存只是辅助，<strong>所以在很多业务中，缓存的读写失败不会影响主流程</strong>，啥意思呢？就是说很多情况下，即使操作缓存失败（比如步骤1.1中的’DEL缓存失败’），程序还是会继续往下走（继续步骤1.2 更新数据库)，所以这个时候异步刷新就能在一定程度上，对1.1的失败进行错误数据的修补</p>\n<h4 id=\"缺点剖析\">缺点剖析</h4>\n<h4 id=\"1--容灾不足\">1. 容灾不足</h4>\n<blockquote updated=\"20220705131435\">\n<p updated=\"20220705131435\">在分布式领域，“Everything will fails”，任何可能出现问题的地方都会出现问题</p>\n</blockquote>\n<p updated=\"20220705131435\">我们来分析一下写流程，第一步，’DEL缓存失败’怎么办？流程是否还继续走？如果继续执行，那么从’更新完DB’到异步’刷新缓存’缓存期间，数据处于滞后状态。而且如果缓存处于不可写状态，那么异步刷新那步也可能会失败，那缓存就会长期处于旧数据，问题就比较严重了</p>\n<p updated=\"20220705131435\">如果A线程更新数据库内容失败，导致B线程请求再次访问缓存时，发现redis里面没数据，缓存缺失，再去读取mysql时， 从数据库中读取到旧值</p>\n<h4 id=\"2--并发问题\">2. 并发问题</h4>\n<p updated=\"20220705131435\"><strong>写写并发：</strong>试想一下，同时有多个服务器的多个线程进行’步骤1.2更新DB’，更新DB完成之后，它们就要进行异步刷缓存，我们都知道多服务器的异步操作，是无法保证顺序的，所以后面的刷新操作存在相互覆盖的并发问题，<strong>也就是说，存在先更新的DB操作，反而很晚才去刷新缓存</strong>，那这个时候，数据也是错的</p>\n<p updated=\"20220705131435\"><strong>读写并发：</strong>再试想一下，服务器A在进行’读操作’，，在A服务器刚完成2.2时，服务器B在进行’写操作’，假设B服务器1.3完成之后，服务器A的1.3才被执行，这个时候就相当于更新前的老数据写入缓存，最终数据还是错的</p>\n<h4 id=\"方案总结\">方案总结</h4>\n<p updated=\"20220705131435\">适合大部分的业务场景，很多人都在用，香还是很香的，实现起来也简单。<br />\n<strong>适合使用的场景：并发量、一致性要求都不是很高的情况</strong>。<br />\n我觉得这个方案有一个比较大的缺陷在于<strong>刷新缓存有可能会失败，而失败之后缓存中数据就一直会处于错误状态，所以它并不能保证数据的最终一致性</strong></p>\n<p updated=\"20220705131435\">为了保证“数据最终一致性”，我们引入binlog，通过解析binlog来刷新缓存，这样即使刷新失败，依然可以进行日志回放，再次刷新缓存</p>\n<p updated=\"20220705131435\"><span class=\"img\"><img src=\"https://www.shiyitopo.tech/uPic/db-and-cache-02-01.jpg\" alt=\"img\" /></span></p>\n<h3 id=\"写流程-\">写流程：</h3>\n<p updated=\"20220705131435\">第一步先删除缓存，删除之后再更新DB，我们监听从库(资源少的话主库也ok)的binlog，通过分析binlog我们解析出需要需要刷新的数据，然后读主库把最新的数据写入缓存。</p>\n<blockquote updated=\"20220705131435\">\n<p updated=\"20220705131435\">这里需要提一下：最后刷新前的读主库或者读从库，甚至不读库直接通过binlog解析出需要的数据都是ok的，这由业务决定，<strong>比如刷新的数据只是表的一行，那直接通过binlog就完全能解析出来；然而如果需要刷新的数据来自多行，多张表，甚至多个库的话，那就需要读主库或是从库才行</strong></p>\n</blockquote>\n<h3 id=\"读流程-\">读流程：</h3>\n<p updated=\"20220705131435\">第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据刷回缓存</p>\n<h2 id=\"方案分析\">方案分析</h2>\n<h3 id=\"优点剖析-\">优点剖析</h3>\n<h4 id=\"1--容灾\">1. 容灾</h4>\n<p updated=\"20220705131435\">写步骤1.4或1.5 如果失败，可以进行日志回放，再次重试。<br />\n无论步骤1.1是否删除成功，后续的刷新操作是有保证的</p>\n<blockquote updated=\"20220705131435\">\n<p updated=\"20220705131435\">妈耶，怎么就一个优点，讲道理这个其实很常用的，那我们再来看看缺点</p>\n</blockquote>\n<h3 id=\"缺点剖析-\">缺点剖析</h3>\n<blockquote updated=\"20220705131435\">\n<p updated=\"20220705131435\">分析缺点之前，我们先来看一下知识点</p>\n<ol updated=\"20220705131435\">\n<li id=\"20220705131435-1cl6vpv\" updated=\"20220705131435\">\n<p updated=\"20220705131435\">对于同一张表的同一条记录的更新，Databus会以串行形式的通知下游服务，也就是说，只有当我们正确返回后，它才会推送该记录的下一次更新。</p>\n</li>\n<li id=\"20220705131435-2r6r6ih\" updated=\"20220705131435\">\n<p updated=\"20220705131435\">对于同一张表的不同记录的更新， Databus会以事件时间为顺序的通知下游服务，但并不会等待我们返回后才推送下一条，也就是说它是非串行的。</p>\n</li>\n<li id=\"20220705131435-axzxp6x\" updated=\"20220705131435\">\n<p updated=\"20220705131435\">对于不同表，根据其下游的消费速度，不同表之间没有明确的时间顺序。</p>\n</li>\n</ol>\n</blockquote>\n<h4 id=\"1--只适合简单业务-复杂业务容易发生并发问题\">1. 只适合简单业务，复杂业务容易发生并发问题</h4>\n<p updated=\"20220705131435\">这里先来解释一下这里说的“简单业务”是啥意思？</p>\n<blockquote updated=\"20220705131435\">\n<p updated=\"20220705131435\">简单业务：每次需要刷新的数据，都来自<strong>单表单行</strong>。</p>\n</blockquote>\n<p updated=\"20220705131435\">为什么复杂业务就不行呢？我举个例子<br />\n我们假设 <strong>一个订单 = A表信息 + B表信息</strong></p>\n<p updated=\"20220705131435\"><span class=\"img\"><img src=\"https://www.shiyitopo.tech/uPic/db-and-cache-02-02.jpg\" alt=\"img\" /></span></p>\n<p updated=\"20220705131435\">由于A表先变化，经过1，2，3步后，线程1获取了A’B （A表是新数据，B表的老数据），当线程1还没来得及刷新缓存时，并发发生了：</p>\n<p updated=\"20220705131435\">此时，B表发生了更新，经过4，5，6，7将最新的数据A’B’写入缓存，此时此刻缓存数据是符合要求的。</p>\n<p updated=\"20220705131435\">但是，后来线程1进行了第8步，将A’B写入数据，使得缓存最终结果 与 DB 不一致。</p>\n<h5 id=\"缺点1的改进\">缺点1的改进</h5>\n<ul updated=\"20220705131435\">\n<li id=\"20220705131435-dfu4qo5\" updated=\"20220705131435\">\n<p updated=\"20220705131435\"><strong>针对单库多表单次更新的改进：利用事务</strong></p>\n</li>\n</ul>\n<p updated=\"20220705131435\"><span class=\"img\"><img src=\"https://www.shiyitopo.tech/uPic/db-and-cache-02-03.jpg\" alt=\"\" /></span></p>\n<p updated=\"20220705131435\">当AB表的更新发生在一个事务内时，不管线程1、线程2如何读取，他们都能获取两张表的最新数据，所以刷新缓存的数据都是符合要求的。</p>\n<blockquote updated=\"20220705131435\">\n<p updated=\"20220705131435\">但是这种方案具有局限性：那就是只对单次更新有效，或者说更新频率低的情况下才适应，比如我们并发的单独更新C表，并发问题依然会发生。</p>\n</blockquote>\n<p updated=\"20220705131435\">所以<strong>这种方案只针对多表单次更新的情况</strong>。</p>\n<ul updated=\"20220705131435\">\n<li id=\"20220705131435-p182xw7\" updated=\"20220705131435\">\n<p updated=\"20220705131435\"><strong>针对多表多次更新的改进：增量更新</strong></p>\n</li>\n</ul>\n<p updated=\"20220705131435\"><span class=\"img\"><img src=\"https://www.shiyitopo.tech/uPic/db-and-cache-02-04.jpg\" alt=\"img\" /></span></p>\n<p updated=\"20220705131435\">每张表的更新，在同步缓存时，只获取该表的字段覆盖缓存。</p>\n<p updated=\"20220705131435\">这样，线程1，线程2总能获取对应表最新的字段，而且Databus对于同表同行会以串行的形式通知下游，所以能保证缓存的最终一致性。</p>\n<blockquote updated=\"20220705131435\">\n<p updated=\"20220705131435\">这里有一点需要提一下：更新“某张表多行记录“时，这个操作要在一个事务内，不然并发问题依然存在，正如前面分析的</p>\n</blockquote>\n<h4 id=\"2--依然是并发问题\">2. 依然是并发问题</h4>\n<p updated=\"20220705131435\">即使对于<strong>缺点1</strong>我们提出了改进方案，虽然它解决了部分问题，但在极端场景下依然存在并发问题。<br />\n这个场景，就是<strong>缓存中没有数据</strong>的情况：</p>\n<ul updated=\"20220705131435\">\n<li id=\"20220705131435-gud8r0s\" updated=\"20220705131435\">\n<p updated=\"20220705131435\"><strong>读的时候，缓存中的数据已失效，此时又发生了更新</strong></p>\n</li>\n<li id=\"20220705131435-3ww25nb\" updated=\"20220705131435\">\n<p updated=\"20220705131435\"><strong>数据更新的时候，缓存中的数据已失效，此时又发生了更新</strong></p>\n</li>\n</ul>\n<p updated=\"20220705131435\">这个时候，我们在上面提到的“增量更新”就不起作用了，我们需要读取<strong>所有的表</strong>来拼凑出初始数据，那这个时候又涉及到<strong>读所有表的操作</strong>了，那我们在<strong>缺点1</strong>中提到的并发问题会再次发生</p>\n<h2 id=\"方案总结-\">方案总结</h2>\n<p updated=\"20220705131435\"><strong>适合使用的场景：业务简单，读写QPS比较低的情况</strong>。<br />\n今天这个方案呢，优缺点都比较明显，binlog用来刷新缓存是一个很棒的选择，它天然的顺序性用来做同步操作很具有优势；其实<strong>它的并发问题来自于Canal 或 Databus。拿Databus来说，由于不同行、表、库的binlog的消费并不是时间串行的</strong>，那怎么解决这个问题呢</p>\n<blockquote updated=\"20220705131435\">\n<p updated=\"20220705131435\">强一致性，包含两种含义：</p>\n<ul updated=\"20220705131435\">\n<li id=\"20220705131435-thlocfc\" updated=\"20220705131435\">\n<p updated=\"20220705131435\">缓存和DB数据一致</p>\n</li>\n<li id=\"20220705131435-xmuk3bo\" updated=\"20220705131435\">\n<p updated=\"20220705131435\">缓存中没有数据（或者说：不会去读缓存中的老版本数据）</p>\n</li>\n</ul>\n</blockquote>\n<p updated=\"20220705131435\">首先我们来分析一下，既然已经实现了“<strong>最终一致性</strong>”，那它和“<strong>强一致性</strong>”的区别是什么呢？没错，就是“<strong>时间差</strong>”，所以：</p>\n<blockquote updated=\"20220705131435\">\n<p updated=\"20220705131435\">“<strong>最终一致性方案</strong>” + “<strong>时间差</strong>” = “<strong>强一致性方案</strong>”</p>\n</blockquote>\n<p updated=\"20220705131435\">那我们的工作呢，就是加上时间差，实现方式：<strong>我们加一个缓存，将近期被修改的数据进行标记锁定。读的时候，标记锁定的数据强行走DB，没锁定的数据，先走缓存</strong></p>\n<p updated=\"20220705131435\"><span class=\"img\"><img src=\"https://www.shiyitopo.tech/uPic/db-and-cache-04-01.jpg\" alt=\"img\" /></span></p>\n<h3 id=\"写流程--\">写流程：</h3>\n<p updated=\"20220705131435\">我们把修改的数据通过Cache_0标记“正在被修改”，如果标记成功，则继续往下走；<strong>那如果标记失败，则要放弃这次修改。</strong></p>\n<blockquote updated=\"20220705131435\">\n<p updated=\"20220705131435\">何为标记锁定呢？比如你可以设定一个有效期为10S的key，Key存在即为锁定。一般来说10S对于后面的同步操作来说基本是够了~</p>\n</blockquote>\n<p updated=\"20220705131435\"><strong>如果说，还想更严谨一点，怕DB主从延迟太久、MQ延迟太久，或Databus监听的从库挂机之类的情况，我们可以考虑增加一个监控定时任务</strong>。<br />\n比如我们增加一个时间间隔2S的worker的去对比以下两个数据：</p>\n<ul updated=\"20220705131435\">\n<li id=\"20220705131435-stka9ql\" updated=\"20220705131435\">\n<p updated=\"20220705131435\"><strong>时间1： 最后修改数据库的时间</strong><br />\n<strong>VS</strong></p>\n</li>\n<li id=\"20220705131435-bo9rsfc\" updated=\"20220705131435\">\n<p updated=\"20220705131435\"><strong>时间2： 最后由更新引起的’MQ刷新缓存对应数据的实际更新数据库’的时间</strong></p>\n</li>\n</ul>\n<blockquote updated=\"20220705131435\">\n<p updated=\"20220705131435\">数据1： 可由步骤1.1获得，并存储<br />\n数据2： 需要由binlog中解析获得，需要透传到MQ，这样后面就能存储了<br />\n这里提一下：如果多库的情况的话，存储这两个key需要与库一一对应</p>\n</blockquote>\n<p updated=\"20220705131435\">如果 时间1 VS 时间2 相差超过5S，那我们就自动把相应的缓存分片读降级。</p>\n<h3 id=\"读流程--\">读流程：</h3>\n<p updated=\"20220705131435\">先读Cache_0，看看要读的数据是否被标记，如果被标记，则直接读主库；</p>\n<h2 id=\"方案分析-\">方案分析</h2>\n<h3 id=\"优点剖析--\">优点剖析</h3>\n<h4 id=\"1--容灾完善\">1. 容灾完善</h4>\n<p updated=\"20220705131435\">我们一步一步来分析：</p>\n<h6 id=\"写流程容灾分析\">写流程容灾分析</h6>\n<ul updated=\"20220705131435\">\n<li id=\"20220705131435-92uojtp\" updated=\"20220705131435\">\n<p updated=\"20220705131435\"><strong>写1.1 标记失败</strong>：没关系，放弃整个更新操作</p>\n</li>\n<li id=\"20220705131435-34q6pjr\" updated=\"20220705131435\">\n<p updated=\"20220705131435\"><strong>写1.3 DEL缓存失败</strong>：没关系，后面会覆盖</p>\n</li>\n<li id=\"20220705131435-zhh9u8h\" updated=\"20220705131435\">\n<p updated=\"20220705131435\"><strong>写1.5 写MQ失败</strong>：没关系，Databus或Canal都会重试</p>\n</li>\n<li id=\"20220705131435-n05tzn3\" updated=\"20220705131435\">\n<p updated=\"20220705131435\"><strong>消费MQ的：1.6 || 1.7 失败</strong>：没关系，重新消费即可</p>\n</li>\n</ul>\n<h6 id=\"读流程容灾分析\">读流程容灾分析</h6>\n<ul updated=\"20220705131435\">\n<li id=\"20220705131435-q0cvx80\" updated=\"20220705131435\">\n<p updated=\"20220705131435\"><strong>读2.1 读Cache_0失败</strong>：没关系，直接读主库</p>\n</li>\n<li id=\"20220705131435-vh7tj0f\" updated=\"20220705131435\">\n<p updated=\"20220705131435\"><strong>读2.3 异步写MQ失败</strong>：没关系，缓存为空，是OK的，下次还读库就好了</p>\n</li>\n</ul>\n<h4 id=\"2--无并发问题\">2. 无并发问题</h4>\n<p updated=\"20220705131435\">这个方案让“读库 + 刷缓存”的操作串行化，这就不存在老数据覆盖新数据的并发问题了</p>\n<h3 id=\"缺点剖析--\">缺点剖析</h3>\n<h4 id=\"1--增加Cache-0强依赖\">1. 增加Cache_0强依赖</h4>\n<p updated=\"20220705131435\">这个其实有点没办法，你要强一致性，必然要牺牲一些的。<br />\n但是呢，你这个可以吧Cache_0设计成多机器多分片，这样的话，即使部分分片挂了，也只有小部分流量透过Cache直接打到DB上，这是完全是可接受的</p>\n<h4 id=\"2--复杂度是比较高的\">2. 复杂度是比较高的</h4>\n<p updated=\"20220705131435\">涉及到Databus、MQ、定时任务等等组件，实现起来复杂度还是有的</p>\n<h2 id=\"方案总结--\">方案总结</h2>\n<p updated=\"20220705131435\">OK，到此呢，我们已经实现了<strong>“数据库和缓存强一致性”</strong>，这个系列就先这样啦，等我学到了更好的方案，再来分享~</p>\n<p updated=\"20220705131435\">https://blog.kido.site/2018/11/24/db-and-cache-preface/</p>\n","headings":[{"depth":1,"value":"Redis分布式缓存"},{"depth":1,"value":"双写一致性"},{"depth":1,"value":"缓存更新策略"},{"depth":2,"value":"最常见的策略"},{"depth":4,"value":"优点剖析"},{"depth":4,"value":"1. “先淘汰缓存，再写数据库” 合理"},{"depth":4,"value":"2. 异步刷新，补缺补漏"},{"depth":4,"value":"缺点剖析"},{"depth":4,"value":"1. 容灾不足"},{"depth":4,"value":"2. 并发问题"},{"depth":4,"value":"方案总结"},{"depth":3,"value":"写流程："},{"depth":3,"value":"读流程："},{"depth":2,"value":"方案分析"},{"depth":3,"value":"优点剖析"},{"depth":4,"value":"1. 容灾"},{"depth":3,"value":"缺点剖析"},{"depth":4,"value":"1. 只适合简单业务，复杂业务容易发生并发问题"},{"depth":5,"value":"缺点1的改进"},{"depth":4,"value":"2. 依然是并发问题"},{"depth":2,"value":"方案总结"},{"depth":3,"value":"写流程："},{"depth":3,"value":"读流程："},{"depth":2,"value":"方案分析"},{"depth":3,"value":"优点剖析"},{"depth":4,"value":"1. 容灾完善"},{"depth":6,"value":"写流程容灾分析"},{"depth":6,"value":"读流程容灾分析"},{"depth":4,"value":"2. 无并发问题"},{"depth":3,"value":"缺点剖析"},{"depth":4,"value":"1. 增加Cache_0强依赖"},{"depth":4,"value":"2. 复杂度是比较高的"},{"depth":2,"value":"方案总结"}],"path":"/topic/redis/Redis分布式缓存"},"tree":{"title":"redis","id":"20220428141727-a3p03i0","parentId":"","href":"/topic/redis","path":"/topic/redis","children":[{"title":"Redis为什么这么快","id":"20220428141727-jbyo2wp","type":"d","href":"/topic/redis/Redis为什么这么快","parentId":"","path":"/topic/redis/Redis为什么这么快","parentPath":"/topic/redis","sort":1,"children":[{"title":"完全基于内存","id":"20220428141727-m8thckv","type":"h","href":"/topic/redis/Redis为什么这么快#完全基于内存","parentId":"20220428141727-jbyo2wp","path":"/topic/redis/Redis为什么这么快","parentPath":"/topic/redis","children":[],"level":2},{"title":"数据结构简单","id":"20220428141727-0532nq9","type":"h","href":"/topic/redis/Redis为什么这么快#数据结构简单","parentId":"20220428141727-jbyo2wp","path":"/topic/redis/Redis为什么这么快","parentPath":"/topic/redis","children":[],"level":2},{"title":"工作线程采用单线程，避免了线程上下文切换所带来的损耗","id":"20220428141727-kw7bg9v","type":"h","href":"/topic/redis/Redis为什么这么快#工作线程采用单线程，避免了线程上下文切换所带来的损耗","parentId":"20220428141727-jbyo2wp","path":"/topic/redis/Redis为什么这么快","parentPath":"/topic/redis","children":[],"level":2},{"title":"对于客户端的连接采用多路复用和非阻塞I/O","id":"20220428141727-m7ruuk1","type":"h","href":"/topic/redis/Redis为什么这么快#对于客户端的连接采用多路复用和非阻塞I/O","parentId":"20220428141727-jbyo2wp","path":"/topic/redis/Redis为什么这么快","parentPath":"/topic/redis","children":[],"level":2},{"title":"redis单线程的问题","id":"20220428141728-w6wf4kq","type":"d","href":"/topic/redis/Redis为什么这么快/redis单线程的问题","parentId":"","path":"/topic/redis/Redis为什么这么快/redis单线程的问题","parentPath":"/topic/redis/Redis为什么这么快","sort":11,"children":[],"level":2}],"level":1},{"title":"Redis基本数据结构","id":"20220428141727-imsmasu","type":"d","href":"/topic/redis/Redis基本数据结构","parentId":"","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","sort":2,"children":[{"title":"常用的","id":"20220428141727-1gclyg6","type":"h","href":"/topic/redis/Redis基本数据结构#常用的","parentId":"20220428141727-imsmasu","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[{"title":"string","id":"20220428141727-u2m7nzt","type":"h","href":"/topic/redis/Redis基本数据结构#string","parentId":"20220428141727-1gclyg6","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[],"level":3},{"title":"hash","id":"20220428141727-po0l8p4","type":"h","href":"/topic/redis/Redis基本数据结构#hash","parentId":"20220428141727-1gclyg6","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[],"level":3},{"title":"list","id":"20220428141727-nyjx5v1","type":"h","href":"/topic/redis/Redis基本数据结构#list","parentId":"20220428141727-1gclyg6","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[],"level":3},{"title":"set","id":"20220428141727-ujl3jkq","type":"h","href":"/topic/redis/Redis基本数据结构#set","parentId":"20220428141727-1gclyg6","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[],"level":3},{"title":"zset","id":"20220428141727-8lh8dqt","type":"h","href":"/topic/redis/Redis基本数据结构#zset","parentId":"20220428141727-1gclyg6","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[],"level":3}],"level":2},{"title":"扩展结构","id":"20220428141727-9xu8ei1","type":"h","href":"/topic/redis/Redis基本数据结构#扩展结构","parentId":"20220428141727-imsmasu","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[{"title":"bitmap","id":"20220428141727-89gt7iy","type":"h","href":"/topic/redis/Redis基本数据结构#bitmap","parentId":"20220428141727-9xu8ei1","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[],"level":3},{"title":"hyperloglog","id":"20220428141727-08upaib","type":"h","href":"/topic/redis/Redis基本数据结构#hyperloglog","parentId":"20220428141727-9xu8ei1","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[],"level":3},{"title":"GEO","id":"20220428141727-6z03dvm","type":"h","href":"/topic/redis/Redis基本数据结构#GEO","parentId":"20220428141727-9xu8ei1","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[],"level":3}],"level":2},{"title":"扩展功能","id":"20220428141727-x5n4s7y","type":"h","href":"/topic/redis/Redis基本数据结构#扩展功能","parentId":"20220428141727-imsmasu","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[{"title":"pub/sub","id":"20220428141727-zay76x9","type":"h","href":"/topic/redis/Redis基本数据结构#pub/sub","parentId":"20220428141727-x5n4s7y","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[],"level":3},{"title":"pipeline","id":"20220428141727-m3750uw","type":"h","href":"/topic/redis/Redis基本数据结构#pipeline","parentId":"20220428141727-x5n4s7y","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[],"level":3},{"title":"Lua 脚本","id":"20220428141727-6rc0qt7","type":"h","href":"/topic/redis/Redis基本数据结构#Lua 脚本","parentId":"20220428141727-x5n4s7y","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[],"level":3},{"title":"事务","id":"20220428141727-8i9gpxn","type":"h","href":"/topic/redis/Redis基本数据结构#事务","parentId":"20220428141727-x5n4s7y","path":"/topic/redis/Redis基本数据结构","parentPath":"/topic/redis","children":[],"level":3}],"level":2},{"title":"String的底层实现","id":"20220428141728-d2hmuxd","type":"d","href":"/topic/redis/Redis基本数据结构/String的底层实现","parentId":"","path":"/topic/redis/Redis基本数据结构/String的底层实现","parentPath":"/topic/redis/Redis基本数据结构","sort":1,"children":[{"title":"SDS 结构","id":"20220428141728-y2039os","type":"h","href":"/topic/redis/Redis基本数据结构/String的底层实现#SDS 结构","parentId":"20220428141728-d2hmuxd","path":"/topic/redis/Redis基本数据结构/String的底层实现","parentPath":"/topic/redis/Redis基本数据结构","children":[],"level":3},{"title":"相对于C语言的优势","id":"20220428141728-8t63ohh","type":"h","href":"/topic/redis/Redis基本数据结构/String的底层实现#相对于C语言的优势","parentId":"20220428141728-d2hmuxd","path":"/topic/redis/Redis基本数据结构/String的底层实现","parentPath":"/topic/redis/Redis基本数据结构","children":[{"title":"统计长度时间复杂度 O(1)","id":"20220428141728-xeqpgol","type":"h","href":"/topic/redis/Redis基本数据结构/String的底层实现#统计长度时间复杂度 O(1)","parentId":"20220428141728-8t63ohh","path":"/topic/redis/Redis基本数据结构/String的底层实现","parentPath":"/topic/redis/Redis基本数据结构","children":[],"level":4},{"title":"数据溢出","id":"20220428141728-coew455","type":"h","href":"/topic/redis/Redis基本数据结构/String的底层实现#数据溢出","parentId":"20220428141728-8t63ohh","path":"/topic/redis/Redis基本数据结构/String的底层实现","parentPath":"/topic/redis/Redis基本数据结构","children":[],"level":4},{"title":"内存重分配策略","id":"20220428141728-mbwnou1","type":"h","href":"/topic/redis/Redis基本数据结构/String的底层实现#内存重分配策略","parentId":"20220428141728-8t63ohh","path":"/topic/redis/Redis基本数据结构/String的底层实现","parentPath":"/topic/redis/Redis基本数据结构","children":[],"level":4},{"title":"数据格式多样性","id":"20220428141728-5h2se0u","type":"h","href":"/topic/redis/Redis基本数据结构/String的底层实现#数据格式多样性","parentId":"20220428141728-8t63ohh","path":"/topic/redis/Redis基本数据结构/String的底层实现","parentPath":"/topic/redis/Redis基本数据结构","children":[],"level":4}],"level":3},{"title":"三大编码","id":"20220428141728-t4votze","type":"h","href":"/topic/redis/Redis基本数据结构/String的底层实现#三大编码","parentId":"20220428141728-d2hmuxd","path":"/topic/redis/Redis基本数据结构/String的底层实现","parentPath":"/topic/redis/Redis基本数据结构","children":[],"level":3}],"level":2},{"title":"List的底层实现","id":"20220428141727-skh553t","type":"d","href":"/topic/redis/Redis基本数据结构/List的底层实现","parentId":"","path":"/topic/redis/Redis基本数据结构/List的底层实现","parentPath":"/topic/redis/Redis基本数据结构","sort":2,"children":[],"level":2},{"title":"Hash的底层实现","id":"20220428141727-g51ewzt","type":"d","href":"/topic/redis/Redis基本数据结构/Hash的底层实现","parentId":"","path":"/topic/redis/Redis基本数据结构/Hash的底层实现","parentPath":"/topic/redis/Redis基本数据结构","sort":3,"children":[{"title":"ZipList编码的哈希对象","id":"20220428141727-fo8pixs","type":"h","href":"/topic/redis/Redis基本数据结构/Hash的底层实现#ZipList编码的哈希对象","parentId":"20220428141727-g51ewzt","path":"/topic/redis/Redis基本数据结构/Hash的底层实现","parentPath":"/topic/redis/Redis基本数据结构","children":[],"level":3},{"title":"hashtable对象","id":"20220428141727-f7zok8f","type":"h","href":"/topic/redis/Redis基本数据结构/Hash的底层实现#hashtable对象","parentId":"20220428141727-g51ewzt","path":"/topic/redis/Redis基本数据结构/Hash的底层实现","parentPath":"/topic/redis/Redis基本数据结构","children":[],"level":3}],"level":2},{"title":"Set的底层实现","id":"20220428141728-5c6e914","type":"d","href":"/topic/redis/Redis基本数据结构/Set的底层实现","parentId":"","path":"/topic/redis/Redis基本数据结构/Set的底层实现","parentPath":"/topic/redis/Redis基本数据结构","sort":4,"children":[],"level":2},{"title":"ZSet的底层实现","id":"20220428141728-58eined","type":"d","href":"/topic/redis/Redis基本数据结构/ZSet的底层实现","parentId":"","path":"/topic/redis/Redis基本数据结构/ZSet的底层实现","parentPath":"/topic/redis/Redis基本数据结构","sort":5,"children":[{"title":"跳表是什么?","id":"20220428141728-9by553n","type":"h","href":"/topic/redis/Redis基本数据结构/ZSet的底层实现#跳表是什么?","parentId":"20220428141728-58eined","path":"/topic/redis/Redis基本数据结构/ZSet的底层实现","parentPath":"/topic/redis/Redis基本数据结构","children":[{"title":"优缺点","id":"20220428141728-rvbr2il","type":"h","href":"/topic/redis/Redis基本数据结构/ZSet的底层实现#优缺点","parentId":"20220428141728-9by553n","path":"/topic/redis/Redis基本数据结构/ZSet的底层实现","parentPath":"/topic/redis/Redis基本数据结构","children":[],"level":4}],"level":3}],"level":2}],"level":1},{"title":"Redis分布式缓存","id":"20220428141727-3x1i5zp","type":"d","href":"/topic/redis/Redis分布式缓存","parentId":"","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","sort":3,"children":[{"title":"双写一致性","id":"20220428141727-zahxna7","type":"h","href":"/topic/redis/Redis分布式缓存#双写一致性","parentId":"20220428141727-3x1i5zp","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":2},{"title":"缓存更新策略","id":"20220428141727-iqgn80l","type":"h","href":"/topic/redis/Redis分布式缓存#缓存更新策略","parentId":"20220428141727-3x1i5zp","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[{"title":"最常见的策略","id":"20220428141727-45wxv7a","type":"h","href":"/topic/redis/Redis分布式缓存#最常见的策略","parentId":"20220428141727-iqgn80l","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[{"title":"优点剖析","id":"20220428141727-tfanvhu","type":"h","href":"/topic/redis/Redis分布式缓存#优点剖析","parentId":"20220428141727-45wxv7a","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":4},{"title":"1. “先淘汰缓存，再写数据库” 合理","id":"20220428141727-vzyp7bi","type":"h","href":"/topic/redis/Redis分布式缓存#1. “先淘汰缓存，再写数据库” 合理","parentId":"20220428141727-45wxv7a","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":4},{"title":"2. 异步刷新，补缺补漏","id":"20220428141727-kbueoxr","type":"h","href":"/topic/redis/Redis分布式缓存#2. 异步刷新，补缺补漏","parentId":"20220428141727-45wxv7a","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":4},{"title":"缺点剖析","id":"20220428141727-sd1lbh3","type":"h","href":"/topic/redis/Redis分布式缓存#缺点剖析","parentId":"20220428141727-45wxv7a","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":4},{"title":"1. 容灾不足","id":"20220428141727-aff14q4","type":"h","href":"/topic/redis/Redis分布式缓存#1. 容灾不足","parentId":"20220428141727-45wxv7a","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":4},{"title":"2. 并发问题","id":"20220428141727-7kjhtfn","type":"h","href":"/topic/redis/Redis分布式缓存#2. 并发问题","parentId":"20220428141727-45wxv7a","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":4},{"title":"方案总结","id":"20220428141727-5w2loli","type":"h","href":"/topic/redis/Redis分布式缓存#方案总结","parentId":"20220428141727-45wxv7a","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":4},{"title":"写流程：","id":"20220428141727-s959uv0","type":"h","href":"/topic/redis/Redis分布式缓存#写流程：","parentId":"20220428141727-45wxv7a","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":4},{"title":"读流程：","id":"20220428141727-sceljri","type":"h","href":"/topic/redis/Redis分布式缓存#读流程：","parentId":"20220428141727-45wxv7a","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":4}],"level":3},{"title":"方案分析","id":"20220428141727-7flpl0m","type":"h","href":"/topic/redis/Redis分布式缓存#方案分析","parentId":"20220428141727-iqgn80l","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[{"title":"优点剖析","id":"20220428141727-1cqjx66","type":"h","href":"/topic/redis/Redis分布式缓存#优点剖析","parentId":"20220428141727-7flpl0m","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[{"title":"1. 容灾","id":"20220428141727-w9bvsqf","type":"h","href":"/topic/redis/Redis分布式缓存#1. 容灾","parentId":"20220428141727-1cqjx66","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":5}],"level":4},{"title":"缺点剖析","id":"20220428141727-n1twxfd","type":"h","href":"/topic/redis/Redis分布式缓存#缺点剖析","parentId":"20220428141727-7flpl0m","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[{"title":"1. 只适合简单业务，复杂业务容易发生并发问题","id":"20220428141727-t5kobxh","type":"h","href":"/topic/redis/Redis分布式缓存#1. 只适合简单业务，复杂业务容易发生并发问题","parentId":"20220428141727-n1twxfd","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[{"title":"缺点1的改进","id":"20220428141727-bz5ta88","type":"h","href":"/topic/redis/Redis分布式缓存#缺点1的改进","parentId":"20220428141727-t5kobxh","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":6}],"level":5},{"title":"2. 依然是并发问题","id":"20220428141727-gysgmg1","type":"h","href":"/topic/redis/Redis分布式缓存#2. 依然是并发问题","parentId":"20220428141727-n1twxfd","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":5}],"level":4}],"level":3},{"title":"方案总结","id":"20220428141727-01sdgjy","type":"h","href":"/topic/redis/Redis分布式缓存#方案总结","parentId":"20220428141727-iqgn80l","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[{"title":"写流程：","id":"20220428141727-eglmgkf","type":"h","href":"/topic/redis/Redis分布式缓存#写流程：","parentId":"20220428141727-01sdgjy","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":4},{"title":"读流程：","id":"20220428141727-1vywbk4","type":"h","href":"/topic/redis/Redis分布式缓存#读流程：","parentId":"20220428141727-01sdgjy","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":4}],"level":3},{"title":"方案分析","id":"20220428141727-137lw2k","type":"h","href":"/topic/redis/Redis分布式缓存#方案分析","parentId":"20220428141727-iqgn80l","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[{"title":"优点剖析","id":"20220428141727-p0zad1o","type":"h","href":"/topic/redis/Redis分布式缓存#优点剖析","parentId":"20220428141727-137lw2k","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[{"title":"1. 容灾完善","id":"20220428141727-cawius6","type":"h","href":"/topic/redis/Redis分布式缓存#1. 容灾完善","parentId":"20220428141727-p0zad1o","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[{"title":"写流程容灾分析","id":"20220428141727-2d2z7fz","type":"h","href":"/topic/redis/Redis分布式缓存#写流程容灾分析","parentId":"20220428141727-cawius6","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":6},{"title":"读流程容灾分析","id":"20220428141727-4hr5okn","type":"h","href":"/topic/redis/Redis分布式缓存#读流程容灾分析","parentId":"20220428141727-cawius6","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":6}],"level":5},{"title":"2. 无并发问题","id":"20220428141727-uvwj2ga","type":"h","href":"/topic/redis/Redis分布式缓存#2. 无并发问题","parentId":"20220428141727-p0zad1o","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":5}],"level":4},{"title":"缺点剖析","id":"20220428141727-fmiz5zl","type":"h","href":"/topic/redis/Redis分布式缓存#缺点剖析","parentId":"20220428141727-137lw2k","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[{"title":"1. 增加Cache_0强依赖","id":"20220428141727-hr6lxu9","type":"h","href":"/topic/redis/Redis分布式缓存#1. 增加Cache_0强依赖","parentId":"20220428141727-fmiz5zl","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":5},{"title":"2. 复杂度是比较高的","id":"20220428141727-vbiftey","type":"h","href":"/topic/redis/Redis分布式缓存#2. 复杂度是比较高的","parentId":"20220428141727-fmiz5zl","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":5}],"level":4}],"level":3},{"title":"方案总结","id":"20220428141727-0an20z6","type":"h","href":"/topic/redis/Redis分布式缓存#方案总结","parentId":"20220428141727-iqgn80l","path":"/topic/redis/Redis分布式缓存","parentPath":"/topic/redis","children":[],"level":3}],"level":2},{"title":"缓存击穿","id":"20220428141728-p93afgy","type":"d","href":"/topic/redis/Redis分布式缓存/缓存击穿","parentId":"","path":"/topic/redis/Redis分布式缓存/缓存击穿","parentPath":"/topic/redis/Redis分布式缓存","sort":1,"children":[{"title":"解决方案","id":"20220428141728-27esyuz","type":"h","href":"/topic/redis/Redis分布式缓存/缓存击穿#解决方案","parentId":"20220428141728-p93afgy","path":"/topic/redis/Redis分布式缓存/缓存击穿","parentPath":"/topic/redis/Redis分布式缓存","children":[{"title":"不过期","id":"20220428141728-foxjedm","type":"h","href":"/topic/redis/Redis分布式缓存/缓存击穿#不过期","parentId":"20220428141728-27esyuz","path":"/topic/redis/Redis分布式缓存/缓存击穿","parentPath":"/topic/redis/Redis分布式缓存","children":[],"level":4},{"title":"互斥锁","id":"20220428141728-68zg08m","type":"h","href":"/topic/redis/Redis分布式缓存/缓存击穿#互斥锁","parentId":"20220428141728-27esyuz","path":"/topic/redis/Redis分布式缓存/缓存击穿","parentPath":"/topic/redis/Redis分布式缓存","children":[],"level":4}],"level":3}],"level":2},{"title":"缓存穿透","id":"20220428141728-64iljj5","type":"d","href":"/topic/redis/Redis分布式缓存/缓存穿透","parentId":"","path":"/topic/redis/Redis分布式缓存/缓存穿透","parentPath":"/topic/redis/Redis分布式缓存","sort":3,"children":[{"title":"接口校验","id":"20220428141728-wny00tb","type":"h","href":"/topic/redis/Redis分布式缓存/缓存穿透#接口校验","parentId":"20220428141728-64iljj5","path":"/topic/redis/Redis分布式缓存/缓存穿透","parentPath":"/topic/redis/Redis分布式缓存","children":[],"level":3},{"title":"空对象缓存或者缺省值","id":"20220428141728-6wjc642","type":"h","href":"/topic/redis/Redis分布式缓存/缓存穿透#空对象缓存或者缺省值","parentId":"20220428141728-64iljj5","path":"/topic/redis/Redis分布式缓存/缓存穿透","parentPath":"/topic/redis/Redis分布式缓存","children":[],"level":3},{"title":"布隆过滤器","id":"20220428141728-r9yad28","type":"h","href":"/topic/redis/Redis分布式缓存/缓存穿透#布隆过滤器","parentId":"20220428141728-64iljj5","path":"/topic/redis/Redis分布式缓存/缓存穿透","parentPath":"/topic/redis/Redis分布式缓存","children":[],"level":3}],"level":2},{"title":"缓存雪崩","id":"20220428141728-9ti4duq","type":"d","href":"/topic/redis/Redis分布式缓存/缓存雪崩","parentId":"","path":"/topic/redis/Redis分布式缓存/缓存雪崩","parentPath":"/topic/redis/Redis分布式缓存","sort":4,"children":[{"title":"解决方案","id":"20220428141728-zu9jxq3","type":"h","href":"/topic/redis/Redis分布式缓存/缓存雪崩#解决方案","parentId":"20220428141728-9ti4duq","path":"/topic/redis/Redis分布式缓存/缓存雪崩","parentPath":"/topic/redis/Redis分布式缓存","children":[{"title":"三步骤","id":"20220428141728-0vnf8gp","type":"h","href":"/topic/redis/Redis分布式缓存/缓存雪崩#三步骤","parentId":"20220428141728-zu9jxq3","path":"/topic/redis/Redis分布式缓存/缓存雪崩","parentPath":"/topic/redis/Redis分布式缓存","children":[],"level":4}],"level":3}],"level":2},{"title":"缓存预热","id":"20220428141728-fz10tn2","type":"d","href":"/topic/redis/Redis分布式缓存/缓存预热","parentId":"","path":"/topic/redis/Redis分布式缓存/缓存预热","parentPath":"/topic/redis/Redis分布式缓存","sort":7,"children":[],"level":2}],"level":1},{"title":"Redis的分布式锁","id":"20220428141727-sgydg0x","type":"d","href":"/topic/redis/Redis的分布式锁","parentId":"","path":"/topic/redis/Redis的分布式锁","parentPath":"/topic/redis","sort":4,"children":[{"title":"利用redis实现分布式锁","id":"20220428141727-e4nwnv1","type":"h","href":"/topic/redis/Redis的分布式锁#利用redis实现分布式锁","parentId":"20220428141727-sgydg0x","path":"/topic/redis/Redis的分布式锁","parentPath":"/topic/redis","children":[{"title":"三个重要因素","id":"20220428141727-zthzzjq","type":"h","href":"/topic/redis/Redis的分布式锁#三个重要因素","parentId":"20220428141727-e4nwnv1","path":"/topic/redis/Redis的分布式锁","parentPath":"/topic/redis","children":[],"level":3},{"title":"涉及命令","id":"20220428141727-hs1yg88","type":"h","href":"/topic/redis/Redis的分布式锁#涉及命令","parentId":"20220428141727-e4nwnv1","path":"/topic/redis/Redis的分布式锁","parentPath":"/topic/redis","children":[],"level":3}],"level":2},{"title":"实现思想","id":"20220428141727-5jo3h6s","type":"h","href":"/topic/redis/Redis的分布式锁#实现思想","parentId":"20220428141727-sgydg0x","path":"/topic/redis/Redis的分布式锁","parentPath":"/topic/redis","children":[{"title":"业务执行的时间大于redis锁过期的时间","id":"20220428141727-q83o36l","type":"h","href":"/topic/redis/Redis的分布式锁#业务执行的时间大于redis锁过期的时间","parentId":"20220428141727-5jo3h6s","path":"/topic/redis/Redis的分布式锁","parentPath":"/topic/redis","children":[],"level":3},{"title":"redis部署模式的影响","id":"20220428141727-9xczwbf","type":"h","href":"/topic/redis/Redis的分布式锁#redis部署模式的影响","parentId":"20220428141727-5jo3h6s","path":"/topic/redis/Redis的分布式锁","parentPath":"/topic/redis","children":[],"level":3},{"title":"原子性问题","id":"20220428141727-u4jomll","type":"h","href":"/topic/redis/Redis的分布式锁#原子性问题","parentId":"20220428141727-5jo3h6s","path":"/topic/redis/Redis的分布式锁","parentPath":"/topic/redis","children":[],"level":3}],"level":2},{"title":"看门狗模式","id":"20220428141728-gdeeql2","type":"d","href":"/topic/redis/Redis的分布式锁/看门狗模式","parentId":"","path":"/topic/redis/Redis的分布式锁/看门狗模式","parentPath":"/topic/redis/Redis的分布式锁","sort":1,"children":[],"level":2},{"title":"Redlock","id":"20220428141728-qbzn1tc","type":"d","href":"/topic/redis/Redis的分布式锁/Redlock","parentId":"","path":"/topic/redis/Redis的分布式锁/Redlock","parentPath":"/topic/redis/Redis的分布式锁","sort":2,"children":[{"title":"问题1","id":"20220428141728-lg0r797","type":"h","href":"/topic/redis/Redis的分布式锁/Redlock#问题1","parentId":"20220428141728-qbzn1tc","path":"/topic/redis/Redis的分布式锁/Redlock","parentPath":"/topic/redis/Redis的分布式锁","children":[],"level":3},{"title":"问题2","id":"20220428141728-nhr8fen","type":"h","href":"/topic/redis/Redis的分布式锁/Redlock#问题2","parentId":"20220428141728-qbzn1tc","path":"/topic/redis/Redis的分布式锁/Redlock","parentPath":"/topic/redis/Redis的分布式锁","children":[],"level":3},{"title":"问题3","id":"20220428141728-5jc3ave","type":"h","href":"/topic/redis/Redis的分布式锁/Redlock#问题3","parentId":"20220428141728-qbzn1tc","path":"/topic/redis/Redis的分布式锁/Redlock","parentPath":"/topic/redis/Redis的分布式锁","children":[],"level":3}],"level":2}],"level":1},{"title":"Redis集群","id":"20220428141727-awm7yu5","type":"d","href":"/topic/redis/Redis集群","parentId":"","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","sort":6,"children":[{"title":"三种集群方案","id":"20220428141727-id6w37y","type":"h","href":"/topic/redis/Redis集群#三种集群方案","parentId":"20220428141727-awm7yu5","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[],"level":2},{"title":"主从复制模式","id":"20220428141727-01yokji","type":"h","href":"/topic/redis/Redis集群#主从复制模式","parentId":"20220428141727-awm7yu5","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[{"title":"原理","id":"20220428141727-2xgqon2","type":"h","href":"/topic/redis/Redis集群#原理","parentId":"20220428141727-01yokji","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[],"level":3},{"title":"redis主从复制的坑","id":"20220428141727-h04f0fa","type":"h","href":"/topic/redis/Redis集群#redis主从复制的坑","parentId":"20220428141727-01yokji","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[],"level":3}],"level":2},{"title":"哨兵模式","id":"20220428141727-jxcatge","type":"h","href":"/topic/redis/Redis集群#哨兵模式","parentId":"20220428141727-awm7yu5","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[{"title":"哨兵模式的作用","id":"20220428141727-3jb6vil","type":"h","href":"/topic/redis/Redis集群#哨兵模式的作用","parentId":"20220428141727-jxcatge","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[],"level":3},{"title":"故障切换的过程","id":"20220428141727-uscl9hh","type":"h","href":"/topic/redis/Redis集群#故障切换的过程","parentId":"20220428141727-jxcatge","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[],"level":3},{"title":"哨兵模式的工作方式：","id":"20220428141727-fe5liq6","type":"h","href":"/topic/redis/Redis集群#哨兵模式的工作方式：","parentId":"20220428141727-jxcatge","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[],"level":3},{"title":"哨兵模式的优缺点","id":"20220428141727-fq18erp","type":"h","href":"/topic/redis/Redis集群#哨兵模式的优缺点","parentId":"20220428141727-jxcatge","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[],"level":3}],"level":2},{"title":"Cluster 集群模式（Redis官方）","id":"20220428141727-z0udk1o","type":"h","href":"/topic/redis/Redis集群#Cluster 集群模式（Redis官方）","parentId":"20220428141727-awm7yu5","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[{"title":"集群的数据分片","id":"20220428141727-zez6jhc","type":"h","href":"/topic/redis/Redis集群#集群的数据分片","parentId":"20220428141727-z0udk1o","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[],"level":3},{"title":"Redis 集群的主从复制模型","id":"20220428141727-guu9h2l","type":"h","href":"/topic/redis/Redis集群#Redis 集群的主从复制模型","parentId":"20220428141727-z0udk1o","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[],"level":3},{"title":"集群的特点","id":"20220428141727-a9a9ogo","type":"h","href":"/topic/redis/Redis集群#集群的特点","parentId":"20220428141727-z0udk1o","path":"/topic/redis/Redis集群","parentPath":"/topic/redis","children":[],"level":3}],"level":2},{"title":"Redis数据淘汰策略","id":"20220428141727-oaw8wmd","type":"d","href":"/topic/redis/Redis集群/Redis数据淘汰策略","parentId":"","path":"/topic/redis/Redis集群/Redis数据淘汰策略","parentPath":"/topic/redis/Redis集群","sort":5,"children":[{"title":"Redis的内存淘汰策略，有以下几种","id":"20220428141727-aort8cn","type":"h","href":"/topic/redis/Redis集群/Redis数据淘汰策略#Redis的内存淘汰策略，有以下几种","parentId":"20220428141727-oaw8wmd","path":"/topic/redis/Redis集群/Redis数据淘汰策略","parentPath":"/topic/redis/Redis集群","children":[],"level":3},{"title":"数据库中有 3000w 的数据，而 Redis 中只有 100w 数据，如何保证 Redis 中存放的都是热点数据","id":"20220428141727-egla613","type":"h","href":"/topic/redis/Redis集群/Redis数据淘汰策略#数据库中有 3000w 的数据，而 Redis 中只有 100w 数据，如何保证 Redis 中存放的都是热点数据","parentId":"20220428141727-oaw8wmd","path":"/topic/redis/Redis集群/Redis数据淘汰策略","parentPath":"/topic/redis/Redis集群","children":[],"level":3}],"level":2},{"title":"redis持久化","id":"20220428141728-ahu8hnn","type":"d","href":"/topic/redis/Redis集群/redis持久化","parentId":"","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","sort":8,"children":[{"title":"策略","id":"20220428141728-h8spnbe","type":"h","href":"/topic/redis/Redis集群/redis持久化#策略","parentId":"20220428141728-ahu8hnn","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[],"level":3},{"title":"AOF持久化","id":"20220428141728-8sb3e90","type":"h","href":"/topic/redis/Redis集群/redis持久化#AOF持久化","parentId":"20220428141728-ahu8hnn","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[{"title":"执行流程","id":"20220428141728-xdy9wq3","type":"h","href":"/topic/redis/Redis集群/redis持久化#执行流程","parentId":"20220428141728-8sb3e90","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[],"level":4},{"title":"怎么防止AOF文件越来越大？","id":"20220428141728-2fjjnsi","type":"h","href":"/topic/redis/Redis集群/redis持久化#怎么防止AOF文件越来越大？","parentId":"20220428141728-8sb3e90","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[{"title":"AOF文件追加阻塞？","id":"20220428141728-jggnla6","type":"h","href":"/topic/redis/Redis集群/redis持久化#AOF文件追加阻塞？","parentId":"20220428141728-2fjjnsi","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[],"level":5}],"level":4}],"level":3},{"title":"RDB持久化","id":"20220428141728-3uk1dzb","type":"h","href":"/topic/redis/Redis集群/redis持久化#RDB持久化","parentId":"20220428141728-ahu8hnn","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[{"title":"执行流程","id":"20220428141728-b6xujxs","type":"h","href":"/topic/redis/Redis集群/redis持久化#执行流程","parentId":"20220428141728-3uk1dzb","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[],"level":4}],"level":3},{"title":"混合持久化（Redis4.0+）","id":"20220428141728-z9bdsb4","type":"h","href":"/topic/redis/Redis集群/redis持久化#混合持久化（Redis4.0+）","parentId":"20220428141728-ahu8hnn","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[{"title":"执行流程","id":"20220428141728-flzi42f","type":"h","href":"/topic/redis/Redis集群/redis持久化#执行流程","parentId":"20220428141728-z9bdsb4","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[],"level":4}],"level":3},{"title":"Redis的数据恢复策略","id":"20220428141728-x9y47t6","type":"h","href":"/topic/redis/Redis集群/redis持久化#Redis的数据恢复策略","parentId":"20220428141728-ahu8hnn","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[],"level":3},{"title":"Redis持久化策略该如何进行选择","id":"20220428141728-54y3bdq","type":"h","href":"/topic/redis/Redis集群/redis持久化#Redis持久化策略该如何进行选择","parentId":"20220428141728-ahu8hnn","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[{"title":"1.不需要考虑数据丢失的情况","id":"20220428141728-ujbrmwt","type":"h","href":"/topic/redis/Redis集群/redis持久化#1.不需要考虑数据丢失的情况","parentId":"20220428141728-54y3bdq","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[],"level":4},{"title":"2.单机实例情况下","id":"20220428141728-zahznfw","type":"h","href":"/topic/redis/Redis集群/redis持久化#2.单机实例情况下","parentId":"20220428141728-54y3bdq","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[],"level":4},{"title":"3.在主从环境下","id":"20220428141728-jbd8vij","type":"h","href":"/topic/redis/Redis集群/redis持久化#3.在主从环境下","parentId":"20220428141728-54y3bdq","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[{"title":"那么在从服务器进行数据热备份的情况下，是否还需要持久化呢？","id":"20220428141728-sjs8krt","type":"h","href":"/topic/redis/Redis集群/redis持久化#那么在从服务器进行数据热备份的情况下，是否还需要持久化呢？","parentId":"20220428141728-jbd8vij","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[],"level":5},{"title":"4.异地灾备","id":"20220428141728-aryf17w","type":"h","href":"/topic/redis/Redis集群/redis持久化#4.异地灾备","parentId":"20220428141728-jbd8vij","path":"/topic/redis/Redis集群/redis持久化","parentPath":"/topic/redis/Redis集群","children":[],"level":5}],"level":4}],"level":3}],"level":2},{"title":"Redis数据删除策略","id":"20220428141727-pvzi1zo","type":"d","href":"/topic/redis/Redis集群/Redis数据删除策略","parentId":"","path":"/topic/redis/Redis集群/Redis数据删除策略","parentPath":"/topic/redis/Redis集群","sort":13,"children":[{"title":"惰性删除","id":"20220428141727-o0rija8","type":"h","href":"/topic/redis/Redis集群/Redis数据删除策略#惰性删除","parentId":"20220428141727-pvzi1zo","path":"/topic/redis/Redis集群/Redis数据删除策略","parentPath":"/topic/redis/Redis集群","children":[],"level":3},{"title":"定期删除","id":"20220428141727-wq9axfb","type":"h","href":"/topic/redis/Redis集群/Redis数据删除策略#定期删除","parentId":"20220428141727-pvzi1zo","path":"/topic/redis/Redis集群/Redis数据删除策略","parentPath":"/topic/redis/Redis集群","children":[],"level":3},{"title":"AOF、RDB 和复制功能对过期键的处理","id":"20220428141727-gr8a4lk","type":"h","href":"/topic/redis/Redis集群/Redis数据删除策略#AOF、RDB 和复制功能对过期键的处理","parentId":"20220428141727-pvzi1zo","path":"/topic/redis/Redis集群/Redis数据删除策略","parentPath":"/topic/redis/Redis集群","children":[{"title":"RDB","id":"20220428141727-xhxrdyf","type":"h","href":"/topic/redis/Redis集群/Redis数据删除策略#RDB","parentId":"20220428141727-gr8a4lk","path":"/topic/redis/Redis集群/Redis数据删除策略","parentPath":"/topic/redis/Redis集群","children":[],"level":4},{"title":"AOF","id":"20220428141727-z7l5azb","type":"h","href":"/topic/redis/Redis集群/Redis数据删除策略#AOF","parentId":"20220428141727-gr8a4lk","path":"/topic/redis/Redis集群/Redis数据删除策略","parentPath":"/topic/redis/Redis集群","children":[],"level":4},{"title":"复制","id":"20220428141727-vdap5h4","type":"h","href":"/topic/redis/Redis集群/Redis数据删除策略#复制","parentId":"20220428141727-gr8a4lk","path":"/topic/redis/Redis集群/Redis数据删除策略","parentPath":"/topic/redis/Redis集群","children":[],"level":4}],"level":3},{"title":"疑问点？","id":"20220428141727-5x39avu","type":"h","href":"/topic/redis/Redis集群/Redis数据删除策略#疑问点？","parentId":"20220428141727-pvzi1zo","path":"/topic/redis/Redis集群/Redis数据删除策略","parentPath":"/topic/redis/Redis集群","children":[{"title":"如果主从服务器链接断开怎么办？","id":"20220428141727-4505lb0","type":"h","href":"/topic/redis/Redis集群/Redis数据删除策略#如果主从服务器链接断开怎么办？","parentId":"20220428141727-5x39avu","path":"/topic/redis/Redis集群/Redis数据删除策略","parentPath":"/topic/redis/Redis集群","children":[],"level":4},{"title":"如果发生网络抖动，主服务器发送的 del 命令没有传递到从服务器怎么办？","id":"20220428141727-4x9rpfk","type":"h","href":"/topic/redis/Redis集群/Redis数据删除策略#如果发生网络抖动，主服务器发送的 del 命令没有传递到从服务器怎么办？","parentId":"20220428141727-5x39avu","path":"/topic/redis/Redis集群/Redis数据删除策略","parentPath":"/topic/redis/Redis集群","children":[],"level":4}],"level":3}],"level":2}],"level":1}],"level":0},"headings":[{"depth":1,"value":"Redis分布式缓存","slug":"redis分布式缓存"},{"depth":1,"value":"双写一致性","slug":"双写一致性"},{"depth":1,"value":"缓存更新策略","slug":"缓存更新策略"},{"depth":2,"value":"最常见的策略","slug":"最常见的策略"},{"depth":4,"value":"优点剖析","slug":"优点剖析"},{"depth":4,"value":"1. “先淘汰缓存，再写数据库” 合理","slug":"1-先淘汰缓存再写数据库-合理"},{"depth":4,"value":"2. 异步刷新，补缺补漏","slug":"2-异步刷新补缺补漏"},{"depth":4,"value":"缺点剖析","slug":"缺点剖析"},{"depth":4,"value":"1. 容灾不足","slug":"1-容灾不足"},{"depth":4,"value":"2. 并发问题","slug":"2-并发问题"},{"depth":4,"value":"方案总结","slug":"方案总结"},{"depth":3,"value":"写流程：","slug":"写流程"},{"depth":3,"value":"读流程：","slug":"读流程"},{"depth":2,"value":"方案分析","slug":"方案分析"},{"depth":3,"value":"优点剖析","slug":"优点剖析-1"},{"depth":4,"value":"1. 容灾","slug":"1-容灾"},{"depth":3,"value":"缺点剖析","slug":"缺点剖析-1"},{"depth":4,"value":"1. 只适合简单业务，复杂业务容易发生并发问题","slug":"1-只适合简单业务复杂业务容易发生并发问题"},{"depth":5,"value":"缺点1的改进","slug":"缺点1的改进"},{"depth":4,"value":"2. 依然是并发问题","slug":"2-依然是并发问题"},{"depth":2,"value":"方案总结","slug":"方案总结-1"},{"depth":3,"value":"写流程：","slug":"写流程-1"},{"depth":3,"value":"读流程：","slug":"读流程-1"},{"depth":2,"value":"方案分析","slug":"方案分析-1"},{"depth":3,"value":"优点剖析","slug":"优点剖析-2"},{"depth":4,"value":"1. 容灾完善","slug":"1-容灾完善"},{"depth":6,"value":"写流程容灾分析","slug":"写流程容灾分析"},{"depth":6,"value":"读流程容灾分析","slug":"读流程容灾分析"},{"depth":4,"value":"2. 无并发问题","slug":"2-无并发问题"},{"depth":3,"value":"缺点剖析","slug":"缺点剖析-2"},{"depth":4,"value":"1. 增加Cache_0强依赖","slug":"1-增加cache_0强依赖"},{"depth":4,"value":"2. 复杂度是比较高的","slug":"2-复杂度是比较高的"},{"depth":2,"value":"方案总结","slug":"方案总结-2"}]}},
    "staticQueryHashes": ["630634786","928362550"]}