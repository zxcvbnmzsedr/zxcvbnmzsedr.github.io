{
    "componentChunkName": "component---src-templates-topic-page-template-tsx",
    "path": "/topic/Java并发工具包/并发基础/线程基础/waitnotifynotifyAll",
    "result": {"pageContext":{"id":"/topic/Java并发工具包/并发基础/线程基础/waitnotifynotifyAll","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"waitnotifynotifyAll"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"为什么wait必须在synchronized保护的代码中使用"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在使用wait方法时，必须在synchronized代码块中才能够正确的执行，否则会抛出"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"IllegalMonitorStateException: current thread is not owner"}]},{"type":"text","value":"异常."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"wait"}]},{"type":"text","value":" 方法的源码注释如下："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"# “wait method should always be used in a loop:\n synchronized (obj) {\n     while (condition does not hold)\n         obj.wait();\n     ... // Perform action appropriate to condition\n}\n\n# This method should only be called by a thread that is the owner of this object's monitor.”\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"翻译下，即： "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"wait"}]},{"type":"text","value":" 方法应在 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"synchronized"}]},{"type":"text","value":" 保护的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"while"}]},{"type":"text","value":" 代码块中使用，并始终判断执行条件是否满足，如果满足就往下继续执行，如果不满足就执行 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"wait"}]},{"type":"text","value":" 方法。在执行 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"wait"}]},{"type":"text","value":" 方法之前，必须先持有对象的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"monitor"}]},{"type":"text","value":" 锁，即 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"synchronized"}]},{"type":"text","value":" 锁。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"为什么这样设计？这样设计又有什么好处？"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"反向思考，如果不要求 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"wait"}]},{"type":"text","value":" 方法放在 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"synchronized"}]},{"type":"text","value":" 保护的同步代码中使用，而是可以随意调用，那么就有可能写出这样的代码，如下："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"class BlockingQueue {\n    Queue<String> buffer = new LinkedList<String>();\n    public void offer(String data) {\n        buffer.add(data);\n        // Since someone may be waiting in take\n        notify();  \n    }\n    \n    public String take() throws InterruptedException {\n        while (buffer.isEmpty()) {\n\n            wait();\n        }\n        return buffer.remove();\n    }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"在代码中有两个方法："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"offer"}]},{"type":"text","value":" 方法负责往 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"buffer"}]},{"type":"text","value":" 中添加数据，添加完之后执行 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"notify"}]},{"type":"text","value":" 方法来唤醒之前等待的线程"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"take"}]},{"type":"text","value":" 方法负责检查整个 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"buffer"}]},{"type":"text","value":" 是否为空，如果为空就进入等待，如果不为空就取出一个数据。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但是这段代码并没有受 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"synchronized"}]},{"type":"text","value":" 保护，于是便有可能发生以下场景："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"首先，消费者线程调用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"take"}]},{"type":"text","value":" 方法并判断 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"buffer.isEmpty"}]},{"type":"text","value":" 方法是否返回 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"true"}]},{"type":"text","value":"，若为 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"true"}]},{"type":"text","value":" 代表 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"buffer"}]},{"type":"text","value":" 是空的，则线程希望进入等待，但是在线程调用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"wait"}]},{"type":"text","value":" 方法之前，就被调度器暂停了，所以此时还没来得及执行 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"wait"}]},{"type":"text","value":" 方法。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"此时生产者开始运行，执行了整个 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"offer"}]},{"type":"text","value":" 方法，它往 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"buffer"}]},{"type":"text","value":" 中添加了数据，并执行了 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"notify"}]},{"type":"text","value":" 方法，但 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"notify"}]},{"type":"text","value":" 并没有任何效果，因为消费者线程的 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"wait"}]},{"type":"text","value":" 方法没来得及执行，所以没有线程在等待被唤醒。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"此时，刚才被调度器暂停的消费者线程回来继续执行 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"wait"}]},{"type":"text","value":" 方法并进入了等待。"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"把代码改写成源码注释所要求的被 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"synchronized"}]},{"type":"text","value":" 保护的同步代码块的形式，代码如下:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public void offer(String data) {\n   synchronized (this) {\n      buffer.add(data);\n      notify();\n  }\n}\n\npublic String take() throws InterruptedException {\n   synchronized (this) {\n    while (buffer.isEmpty()) {\n         wait();\n       }\n     return buffer.remove();\n  }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这样就可以确保 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"notify"}]},{"type":"text","value":" 方法永远不会在 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"buffer.isEmpty"}]},{"type":"text","value":" 和 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"wait"}]},{"type":"text","value":" 方法之间被调用，提升了程序的安全性。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"另外，"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"wait"}]},{"type":"text","value":" 方法会释放 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"monitor"}]},{"type":"text","value":" 锁，这也要求必须首先进入到 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"synchronized"}]},{"type":"text","value":" 内持有这把锁。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这里还存在一个“虚假唤醒”（"},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"spurious wakeup"}]},{"type":"text","value":"）的问题，线程可能在既没有被 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"notify/notifyAll"}]},{"type":"text","value":"，也没有被中断或者超时的情况下被唤醒，这种唤醒是不希望看到的。虽然在实际生产中，虚假唤醒发生的概率很小，但是程序依然需要保证在发生虚假唤醒的时候的正确性，所以就需要采用 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"while"}]},{"type":"text","value":" 循环的结构。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"while (condition does not hold)\n    obj.wait();\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"这样即便被虚假唤醒了，也会再次检查 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"while"}]},{"type":"text","value":" 里面的条件，如果不满足条件，就会继续 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"wait"}]},{"type":"text","value":"，也就消除了虚假唤醒的风险。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"为什么 wait/notify/notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"因为Java中每个对象都有一把叫做monitor的锁，由于每个对象都能够上锁，所以就要求在对象头中保存锁的信息，这个锁是对象级别的而不是线程级别的。wait/notify/notifyAll都属于锁级别的操作，他们的锁属于对象，所以把他们定义在Object类中最为合适，因为Object类是所有对象的父类。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"假设，我们把wait/notify/notifyAll给定义在Thread中，这个时候需要一个线程需要持有多个对象的锁，以便于满足业务需求，也就是把wait定义在Thread中的时候，我们无法灵活的控制一个线程持有多把锁的逻辑，一个wait就把整个线程锁住了。既然是让线程去等待某个对象的锁，就 应该是操作对象来实现，而不是操作线程"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"wait/notify 和 sleep 方法的异同？"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"相同点："}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"都能够让线程进入阻塞状态。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"都能够响应interrupt异常，在等待的过程中能够响应中断信号，并报出InterruptedException异常"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"不同点:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"wait/notify是Object的方法。sleep是Thread的方法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"在Synchronized包裹的代码中，调用sleep不会释放monitor锁，而调用wait会释放monitor锁"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"使用sleep需要设置时间，时间到了之后会进入runable状态继续执行，而wait调用之后，如果没有notify去唤醒则一直会阻塞下去"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"wait必须在synchronized包裹的代码中使用，而sleep则不需要"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"headings":[{"depth":1,"value":"waitnotifynotifyAll","slug":"waitnotifynotifyall"},{"depth":2,"value":"为什么wait必须在synchronized保护的代码中使用","slug":"为什么wait必须在synchronized保护的代码中使用"},{"depth":2,"value":"为什么 wait/notify/notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？","slug":"为什么-waitnotifynotifyall-被定义在-object-类中而-sleep-定义在-thread-类中"},{"depth":2,"value":"wait/notify 和 sleep 方法的异同？","slug":"waitnotify-和-sleep-方法的异同"}]}},
    "staticQueryHashes": ["928362550"]}