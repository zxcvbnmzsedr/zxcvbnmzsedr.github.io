{"componentChunkName":"component---src-templates-topic-post-template-js","path":"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解","result":{"data":{"siYuan":{"excerpt":"ConcurrentHashMap详解 ConcurrentHashMap是JUC包中提供的一个高性能并且线程安全的map集合。 相对于Hashtable这种, 对操作进行synchronized加锁的，ConcurrentHashMap却...","raw":"# ConcurrentHashMap详解\n\nConcurrentHashMap是JUC包中提供的一个高性能并且线程安全的map集合。\n\n相对于Hashtable这种, 对操作进行synchronized加锁的，ConcurrentHashMap却是用分段锁或者cas来操作的极大地提高了效率。\n\nConcurrentHashMap在JDK 1.7和1.8中的实现并不相同，所以我们分开来说。\n\n## ConcurrentHashMap_JDK7\n\n在JDK1.5~1.7版本，Java使用了分段锁机制实现ConcurrentHashMap。\n\n分段锁，简单来说就是将Hash表划分成多段——Segment数组，每段单独进行上锁，每个段这个时候就相当于一个线程安全的HashTable。\n\n在进行put的时候，根据Hash算法定位到某个Segment元素上，然后对此Segment进行加锁即可，避免了整个Hash表加锁。\n\n### 数据结构\n\n在不指定的时候，ConcurrentHashMap会将默认初始化一个长度为16的segment数组。\n\nConcurrentHashMap本质上是一个Segment 数组，Segment通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。\n\n![ConcurrentHashMap](https://www.shiyitopo.tech/uPic/ConcurrentHashMap.png)\n\n### 初始化\n\n### 初始化\n\n```java\n/**\n     * 初始化创建一个指定了初始容量、负载因子、并行等级的map\n     * \n     * @param initialCapacity 初始容量，这个值指的是整个ConcurrentHashMap的初始容量,实际操作的时候需要平均分给每个 \n     * Segment。\n     * @param loadFactor 负载因子，用于判断扩容的临界值\n     * @param concurrencyLevel 默认16，并发数、Segment数组大小、并行级别。\n     * 默认16就意味着最多只有16个线程同时写\n     */\n    @SuppressWarnings(\"unchecked\")\n    public ConcurrentHashMap(int initialCapacity,\n                             float loadFactor, int concurrencyLevel) {\n        if (!(loadFactor > 0) || initialCapacity < 0 || concurrencyLevel <= 0)\n            throw new IllegalArgumentException();\n        if (concurrencyLevel > MAX_SEGMENTS)\n            concurrencyLevel = MAX_SEGMENTS;\n        // Find power-of-two sizes best matching arguments\n        int sshift = 0;\n        int ssize = 1;\n        // 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方\n        while (ssize < concurrencyLevel) {\n            ++sshift;\n            ssize <<= 1;\n        }\n       // concurrencyLevel 为 16，sshift 为 4\n       // 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值\n        this.segmentShift = 32 - sshift;\n        this.segmentMask = ssize - 1;\n        if (initialCapacity > MAXIMUM_CAPACITY)\n            initialCapacity = MAXIMUM_CAPACITY;\n      // initialCapacity 是设置整个 map 初始的大小，\n      // 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小\n      // 如 initialCapacity 为 64，那么每个 Segment 或称之为\"槽\"可以分到 4 个\n        int c = initialCapacity / ssize;\n        if (c * ssize < initialCapacity)\n            ++c;\n         // 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，\n        // 插入一个元素不至于扩容，插入第二个的时候才会扩容\n        int cap = MIN_SEGMENT_TABLE_CAPACITY;\n        while (cap < c)\n            cap <<= 1;\n        // create segments and segments[0]\n        // 创建 Segment 数组，\n      // 并创建数组的第一个元素 segment[0]\n        Segment<K,V> s0 =\n            new Segment<K,V>(loadFactor, (int)(cap * loadFactor),\n                             (HashEntry<K,V>[])new HashEntry[cap]);\n        Segment<K,V>[] ss = (Segment<K,V>[])new Segment[ssize];\n        // 往数组写入segment[0]\n        UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]\n        this.segments = ss;\n    }\n```\n\n初始化完成，我们得到了一个 Segment 数组。\n\n我们就当是用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后:\n\n- Segment 数组长度为 16，不可以扩容\n- Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容\n- 这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍\n- 当前 segmentShift 的值为 32 - 4 = 28，segmentMask 为 16 - 1 = 15，姑且把它们简单翻译为移位数和掩码，这两个值马上就会用到\n\n### put过程分析\n\nConcurrentHashMap是通过key的hash寻找两次进行插入，第一次是找出Segment，第二次是找出具体的Hash\n\n```java\n public V put(K key, V value) {\n        Segment<K,V> s;\n        if (value == null)\n            throw new NullPointerException();\n   \t\t\t// 计算key的Hash值\n        int hash = hash(key.hashCode());\n        //  根据 hash 值找到 Segment 数组中的位置 j\n        //    hash 是 32 位，无符号右移 segmentShift(28) 位，剩下高 4 位，\n        //    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的高 4 位，也就是槽的数组下标\n        int j = (hash >>> segmentShift) & segmentMask;\n   \t\t\t// 初始化的时候初始化了 segment[0]，但是其他位置还是 null，\n       // ensureSegment(j) 对 segment[j] 进行初始化\n        if ((s = (Segment<K,V>)UNSAFE.getObject          // nonvolatile; recheck\n             (segments, (j << SSHIFT) + SBASE)) == null) //  in ensureSegment\n            s = ensureSegment(j);\n         // 找到槽s了，通过槽s暴露出的方法进行put操作\n        return s.put(key, hash, value, false);\n    }\n```\n\nSegment暴露出来的put方法:\n\n```java\nfinal V put(K key, int hash, V value, boolean onlyIfAbsent) {\n            // 分段锁来了~，这一步只对这一段进行了一个加锁，以确保线程安全\n            HashEntry<K,V> node = tryLock() ? null :\n                scanAndLockForPut(key, hash, value);\n            V oldValue;\n            try {\n                // segment内部的数组,存放元素的地方\n                HashEntry<K,V>[] tab = table;\n              \t// 第二次，利用hash值取得在内部数组中的位置\n                int index = (tab.length - 1) & hash;\n                // first 是数组该位置处的链表的表头\n                HashEntry<K,V> first = entryAt(tab, index);\n              \t// 接下来就是一大段循环链表的操作，用于插入具体元素\n                for (HashEntry<K,V> e = first;;) {\n                  \t// 当链表中的元素不为空的时候\n                    if (e != null) {\n                        K k;\n                      \t// 加入，put的元素正好存在链表中，则把老的给替换掉\n                        if ((k = e.key) == key ||\n                            (e.hash == hash && key.equals(k))) {\n                            oldValue = e.value;\n                            if (!onlyIfAbsent) {\n                                e.value = value;\n                                ++modCount;\n                            }\n                            break;\n                        }\n                      \t// 寻找下一个\n                        e = e.next;\n                    }\n                    else {\n                        // 到这个判断逻辑中，则说明了链表到了末尾 \n                       // node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。\n                       // 采用头插法进行插入。\n                       // 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t // 这也是区别于HashMap的地方，HashMap1.7中也是采用头插法但由于没有锁，扩容时会导致循环链表的出现\n                        if (node != null)\n                            node.setNext(first);\n                        else\n                            node = new HashEntry<K,V>(hash, key, value, first);\n                        int c = count + 1;\n                        // 如果超过了该 segment 的阈值，这个 segment 需要扩容\n                        if (c > threshold && tab.length < MAXIMUM_CAPACITY)\n                            rehash(node);\n                        else\n                            // 没有达到阈值，将 node 放到数组 tab 的 index 位置，\n                          // 其实就是将新的节点设置成原链表的表头\n                            setEntryAt(tab, index, node);\n                        ++modCount;\n                        count = c;\n                        oldValue = null;\n                        break;\n                    }\n                }\n            } finally {\n               // 解锁\n                unlock();\n            }\n            return oldValue;\n        }\n```\n\n### 初始化槽: ensureSegment\n\nConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。\n\n这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。\n\n```java\nprivate Segment<K,V> ensureSegment(int k) {\n    final Segment<K,V>[] ss = this.segments;\n    long u = (k << SSHIFT) + SBASE; // raw offset\n    Segment<K,V> seg;\n    if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u)) == null) {\n        // 这里看到为什么之前要初始化 segment[0] 了，\n        // 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]\n        // 为什么要用“当前”，因为 segment[0] 可能早就扩容过了\n        Segment<K,V> proto = ss[0];\n        int cap = proto.table.length;\n        float lf = proto.loadFactor;\n        int threshold = (int)(cap * lf);\n\n        // 初始化 segment[k] 内部的数组\n        HashEntry<K,V>[] tab = (HashEntry<K,V>[])new HashEntry[cap];\n        if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))\n            == null) { // 再次检查一遍该槽是否被其他线程初始化了。\n\n            Segment<K,V> s = new Segment<K,V>(lf, threshold, tab);\n            // 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出\n            while ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))\n                   == null) {\n                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))\n                    break;\n            }\n        }\n    }\n    return seg;\n}   \n```\n\n总的来说，ensureSegment(int k) 比较简单，对于并发操作使用 CAS 进行控制。\n\n### 获取写入锁-scanandlockforput\n\n前面我们看到，在往某个 segment 中 put 的时候，首先会调用 node = tryLock() ? null : scanAndLockForPut(key, hash, value)，也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。\n\n下面我们来具体分析这个方法中是怎么控制加锁的。\n\n```java\nprivate HashEntry<K,V> scanAndLockForPut(K key, int hash, V value) {\n    HashEntry<K,V> first = entryForHash(this, hash);\n    HashEntry<K,V> e = first;\n    HashEntry<K,V> node = null;\n    int retries = -1; // negative while locating node\n    // 循环获取锁\n    while (!tryLock()) {\n        HashEntry<K,V> f; // to recheck first below\n        if (retries < 0) {\n            if (e == null) {\n                if (node == null) // speculatively create node\n                    // 进到这里说明数组该位置的链表是空的，没有任何元素\n                    // 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置\n                    node = new HashEntry<K,V>(hash, key, value, null);\n                retries = 0;\n            }\n            else if (key.equals(e.key))\n                retries = 0;\n            else\n                // 顺着链表往下走\n                e = e.next;\n        }\n        // 重试次数如果超过 MAX_SCAN_RETRIES(单核1多核64)，那么不抢了，进入到阻塞队列等待锁\n        //    lock() 是阻塞方法，直到获取锁后返回\n        else if (++retries > MAX_SCAN_RETRIES) {\n            lock();\n            break;\n        }\n        else if ((retries & 1) == 0 &&\n                 // 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头\n                 //     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法\n                 (f = entryForHash(this, hash)) != first) {\n            e = first = f; // re-traverse if entry changed\n            retries = -1;\n        }\n    }\n    return node;\n}\n```\n\n这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。\n\n这个方法就是看似复杂，但是其实就是做了一件事，那就是获取该 segment 的独占锁，如果需要的话顺便实例化了一下 node。\n\n### 扩容-rehash\n\n重复一下，segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry<K,V>[] 进行扩容，扩容后，容量为原来的 2 倍。\n\n首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值，读者这个时候可以回去 put 方法看一眼。\n\n该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。\n\n```java\n// 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。\nprivate void rehash(HashEntry<K,V> node) {\n    HashEntry<K,V>[] oldTable = table;\n    int oldCapacity = oldTable.length;\n    // 2 倍\n    int newCapacity = oldCapacity << 1;\n    threshold = (int)(newCapacity * loadFactor);\n    // 创建新数组\n    HashEntry<K,V>[] newTable =\n        (HashEntry<K,V>[]) new HashEntry[newCapacity];\n    // 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’\n    int sizeMask = newCapacity - 1;\n    // 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置\n    for (int i = 0; i < oldCapacity ; i++) {\n        // e 是链表的第一个元素\n        HashEntry<K,V> e = oldTable[i];\n        if (e != null) {\n            HashEntry<K,V> next = e.next;\n            // 计算应该放置在新数组中的位置，\n            // 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 = 19\n            int idx = e.hash & sizeMask;\n            if (next == null)   // 该位置处只有一个元素，那比较好办\n                newTable[idx] = e;\n            else { // Reuse consecutive sequence at same slot\n                // e 是链表表头\n                HashEntry<K,V> lastRun = e;\n                // idx 是当前链表的头结点 e 的新位置\n                int lastIdx = idx;\n                // 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的\n                for (HashEntry<K,V> last = next;\n                     last != null;\n                     last = last.next) {\n                    int k = last.hash & sizeMask;\n                    if (k != lastIdx) {\n                        lastIdx = k;\n                        lastRun = last;\n                    }\n                }\n                // 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置\n                newTable[lastIdx] = lastRun;\n                // 下面的操作是处理 lastRun 之前的节点，\n                //    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中\n                for (HashEntry<K,V> p = e; p != lastRun; p = p.next) {\n                    V v = p.value;\n                    int h = p.hash;\n                    int k = h & sizeMask;\n                    HashEntry<K,V> n = newTable[k];\n                    newTable[k] = new HashEntry<K,V>(h, p.key, v, n);\n                }\n            }\n        }\n    }\n    // 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部\n    int nodeIndex = node.hash & sizeMask; // add the new node\n    node.setNext(newTable[nodeIndex]);\n    newTable[nodeIndex] = node;\n    table = newTable;\n}\n```\n\n### get 过程分析\n\n相对于 put 来说，get 就很简单了。\n\n- 计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”\n- 槽中也是一个数组，根据 hash 找到数组中具体的位置\n- 到这里是链表了，顺着链表进行查找即可\n\n```java\npublic V get(Object key) {\n    Segment<K,V> s; // manually integrate access methods to reduce overhead\n    HashEntry<K,V>[] tab;\n    // 1. hash 值\n    int h = hash(key);\n    long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;\n    // 2. 根据 hash 找到对应的 segment\n    if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&\n        (tab = s.table) != null) {\n        // 3. 找到segment 内部数组相应位置的链表，遍历\n        for (HashEntry<K,V> e = (HashEntry<K,V>) UNSAFE.getObjectVolatile\n                 (tab, ((long)(((tab.length - 1) & h)) << TSHIFT) + TBASE);\n             e != null; e = e.next) {\n            K k;\n            if ((k = e.key) == key || (e.hash == h && key.equals(k)))\n                return e.value;\n        }\n    }\n    return null;\n}    \n```\n\n### 并发问题分析\n\n现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。\n\n添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。\n\n- put 操作的线程安全性。\n  - 初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的数组。\n  - 添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。\n  - 扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。\n- remove 操作的线程安全性。\n  - remove 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。\n  - get 操作需要遍历链表，但是 remove 操作会\"破坏\"链表。\n  - 如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。\n  - 如果 remove 先破坏了一个节点，分两种情况考虑。 1、如果此节点是头结点，那么需要将头结点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。2、如果要删除的节点不是头结点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。\n\n## ConcurrentHashMap_JDK8\n\n在 Java 8 中，几乎完全重写了 ConcurrentHashMap，代码量从原来 Java 7 中的 1000 多行，变成了现在的 6000 多行，所以也大大提高了源码的阅读难度。而为了方便我们理解，我们还是先从整体的结构示意图出发，看一看总体的设计思路，然后再去深入细节。\n\n![1.8数据结构](https://www.shiyitopo.tech/uPic/1.8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png)\n\n图中的节点有三种类型:\n\n1. 空着的位置代表还没有元素来填充\n2. 相同hash值使用链表向后进行延伸，此举和hashmap相同\n3. 在链表长度超过8，会将链表转换成为红黑树\n\n我们先来看看最基础的内部存储结构 Node，这就是一个一个的节点，如这段代码所示：\n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash;\n    final K key;\n    volatile V val;\n    volatile Node<K,V> next;\n    // ...\n}\n```\n\n可以看出，每个 Node 里面是 key-value 的形式，并且把 value 用 volatile 修饰，以便保证可见性，同时内部还有一个指向下一个节点的 next 指针，方便产生链表结构。\n\n下面我们看两个最重要、最核心的方法。\n\n### put 方法源码分析\n\nput 方法的核心是 putVal 方法，为了方便阅读，我把重要步骤的解读用注释的形式补充在下面的源码中。我们逐步分析这个最重要的方法，这个方法相对有些长，我们一步一步把它看清楚。\n\n```java\nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n    if (key == null || value == null) {\n        throw new NullPointerException();\n    }\n    //计算 hash 值\n    int hash = spread(key.hashCode());\n    int binCount = 0;\n    for (Node<K, V>[] tab = table; ; ) {\n        Node<K, V> f;\n        int n, i, fh;\n        //如果数组是空的，就进行初始化\n        if (tab == null || (n = tab.length) == 0) {\n            tab = initTable();\n        }\n        // 找该 hash 值对应的数组下标\n        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n            //如果该位置是空的，就用 CAS 的方式放入新值\n            if (casTabAt(tab, i, null,\n                    new Node<K, V>(hash, key, value, null))) {\n                break;\n            }\n        }\n        //hash值等于 MOVED 代表在扩容\n        else if ((fh = f.hash) == MOVED) {\n            tab = helpTransfer(tab, f);\n        }\n        //槽点上是有值的情况\n        else {\n            V oldVal = null;\n            //用 synchronized 锁住当前槽点，保证并发安全\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    //如果是链表的形式\n                    if (fh >= 0) {\n                        binCount = 1;\n                        //遍历链表\n                        for (Node<K, V> e = f; ; ++binCount) {\n                            K ek;\n                            //如果发现该 key 已存在，就判断是否需要进行覆盖，然后返回\n                            if (e.hash == hash &&\n                                    ((ek = e.key) == key ||\n                                            (ek != null && key.equals(ek)))) {\n                                oldVal = e.val;\n                                if (!onlyIfAbsent) {\n                                    e.val = value;\n                                }\n                                break;\n                            }\n                            Node<K, V> pred = e;\n                            //到了链表的尾部也没有发现该 key，说明之前不存在，就把新值添加到链表的最后\n                            if ((e = e.next) == null) {\n                                pred.next = new Node<K, V>(hash, key, value, null);\n                                break;\n                            }\n                        }\n                    }\n                    //如果是红黑树的形式\n                    else if (f instanceof TreeBin) {\n                        Node<K, V> p;\n                        binCount = 2;\n                        //调用 putTreeVal 方法往红黑树里增加数据\n                        if ((p = ((TreeBin<K, V>) f).putTreeVal(hash, key,value)) != null) {\n                            oldVal = p.val;\n                            if (!onlyIfAbsent) {\n                                p.val = value;\n                            }\n                        }\n                    }\n                }\n            }\n            if (binCount != 0) {\n                //检查是否满足条件并把链表转换为红黑树的形式，默认的 TREEIFY_THRESHOLD 阈值是 8\n                if (binCount >= TREEIFY_THRESHOLD) {\n                    treeifyBin(tab, i);\n                }\n                //putVal 的返回是添加前的旧值，所以返回 oldVal\n                if (oldVal != null) {\n                    return oldVal;\n                }\n                break;\n            }\n        }\n    }\n    addCount(1L, binCount);\n    return null;\n}\n```\n\n通过以上的源码分析，我们对于 putVal 方法有了详细的认识，可以看出，方法中会逐步根据当前槽点是未初始化、空、扩容、链表、红黑树等不同情况做出不同的处理。\n\n### get 方法源码分析\n\nget 方法比较简单，我们同样用源码注释的方式来分析一下：\n\n```java\npublic V get(Object key) {\n    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;\n    //计算 hash 值\n    int h = spread(key.hashCode());\n    //如果整个数组是空的，或者当前槽点的数据是空的，说明 key 对应的 value 不存在，直接返回 null\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n            (e = tabAt(tab, (n - 1) & h)) != null) {\n        //判断头结点是否就是我们需要的节点，如果是则直接返回\n        if ((eh = e.hash) == h) {\n            if ((ek = e.key) == key || (ek != null && key.equals(ek)))\n                return e.val;\n        }\n        //如果头结点 hash 值小于 0，说明是红黑树或者正在扩容，就用对应的 find 方法来查找\n        else if (eh < 0)\n            return (p = e.find(h, key)) != null ? p.val : null;\n        //遍历链表来查找\n        while ((e = e.next) != null) {\n            if (e.hash == h && ((ek = e.key) == key || (ek != null && key.equals(ek))))\n                return e.val;\n        }\n    }\n    return null;\n}\n```\n\n总结一下 get 的过程：\n\n1. 计算 Hash 值，并由此值找到对应的槽点；\n2. 如果数组是空的或者该位置为 null，那么直接返回 null 就可以了；\n3. 如果该位置处的节点刚好就是我们需要的，直接返回该节点的值；\n4. 如果该位置节点是红黑树或者正在扩容，就用 find 方法继续查找；\n5. 否则那就是链表，就进行遍历链表查找。\n\n## 对比Java7 和Java8 的异同和优缺点\n\n### 并发度\n\nJava 7 中，每个 Segment 独立加锁，最大并发个数就是 Segment 的个数，默认是 16。\n\n但是到了 Java 8 中，锁粒度更细，理想情况下 table 数组元素的个数（也就是数组长度）就是其支持并发的最大个数，并发度比之前有提高。\n\n### 保证并发安全的原理\n\nJava 7 采用 Segment 分段锁来保证安全，而 Segment 是继承自 ReentrantLock。\n\nJava 8 中放弃了 Segment 的设计，采用 Node + CAS + synchronized 保证线程安全。\n\n### 遇到 Hash 碰撞\n\nJava 7 在 Hash 冲突时，会使用拉链法，也就是链表的形式。\n\nJava 8 先使用拉链法，在链表长度超过一定阈值时，将链表转换为红黑树，来提高查找效率。\n\n### 查询时间复杂度\n\nJava 7 遍历链表的时间复杂度是 O(n)，n 为链表长度。\n\nJava 8 如果变成遍历红黑树，那么时间复杂度降低为 O(log(n))，n 为树的节点个数。\n\n参考链接：https://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-ConcurrentHashMap.html\n","html":"<div></div>","field":{"slug":"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解","topic":"Java并发工具包"},"frontmatter":{"title":"ConcurrentHashMap详解","tags":["Java并发工具包","并发工具","并发容器"],"date":"2022-04-21","description":"ConcurrentHashMap详解 ConcurrentHashMap是JUC包中提供的一个高性能并且线程安全的map集合。 相对于Hashtable这种, 对操作进行synchronized加锁的，ConcurrentHashMap却..."}},"topic":{"title":"Java并发工具包","tree":"{\"title\":\"Java并发工具包\",\"id\":\"20220421194022-szu21fl\",\"parentId\":\"\",\"href\":\"/topic/Java并发工具包\",\"path\":\"/topic/Java并发工具包\",\"children\":[{\"title\":\"并发基础\",\"id\":\"20220421224325-jcq08lp\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发基础\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发基础\",\"parentPath\":\"/topic/Java并发工具包\",\"sort\":1,\"children\":[{\"title\":\"线程基础\",\"id\":\"20220421224347-8pq9978\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础\",\"parentPath\":\"/topic/Java并发工具包/并发基础\",\"sort\":1,\"children\":[{\"title\":\"Thread的状态\",\"id\":\"20220421194023-ol9lplx\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"sort\":1,\"children\":[{\"title\":\"New\",\"id\":\"20220421194023-mz6u7e3\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态#New\",\"parentId\":\"20220421194023-ol9lplx\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4},{\"title\":\"Runable\",\"id\":\"20220421194023-i5j5kt4\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态#Runable\",\"parentId\":\"20220421194023-ol9lplx\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4},{\"title\":\"阻塞态\",\"id\":\"20220421194023-tboo24c\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态#阻塞态\",\"parentId\":\"20220421194023-ol9lplx\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[{\"title\":\"Block\",\"id\":\"20220421194023-ffozdtq\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态#Block\",\"parentId\":\"20220421194023-tboo24c\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":5},{\"title\":\"Timed Watting\",\"id\":\"20220421194023-8wsfgft\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态#Timed Watting\",\"parentId\":\"20220421194023-tboo24c\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"Watting\",\"id\":\"20220421194023-dlwp21r\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态#Watting\",\"parentId\":\"20220421194023-ol9lplx\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的状态\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"进程与线程\",\"id\":\"20220421194024-2gxhyjq\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/进程与线程\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/进程与线程\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"sort\":2,\"children\":[{\"title\":\"概述\",\"id\":\"20220421194024-ch040n5\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/进程与线程#概述\",\"parentId\":\"20220421194024-2gxhyjq\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/进程与线程\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"正确停止线程的方式\",\"id\":\"20220421194024-frmfw7a\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"sort\":3,\"children\":[{\"title\":\"废弃的停止方式\",\"id\":\"20220421194024-ghx55hh\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式#废弃的停止方式\",\"parentId\":\"20220421194024-frmfw7a\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[{\"title\":\"Thread.stop和suspend被废弃的原因\",\"id\":\"20220421194024-c7u9s2m\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式#Thread.stop和suspend被废弃的原因\",\"parentId\":\"20220421194024-ghx55hh\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":5},{\"title\":\"volatile标记停止位的错误\",\"id\":\"20220421194024-9ucarn0\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式#volatile标记停止位的错误\",\"parentId\":\"20220421194024-ghx55hh\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"正确的停止方式\",\"id\":\"20220421194024-0r7ntu4\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式#正确的停止方式\",\"parentId\":\"20220421194024-frmfw7a\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[{\"title\":\"通过interrupt方式停止\",\"id\":\"20220421194024-98z6tro\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式#通过interrupt方式停止\",\"parentId\":\"20220421194024-0r7ntu4\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"所以Java中如何正确的停止线程\",\"id\":\"20220421194024-stvj48i\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式#所以Java中如何正确的停止线程\",\"parentId\":\"20220421194024-frmfw7a\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[{\"title\":\"答题思路\",\"id\":\"20220421194024-w3nwz6h\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式#答题思路\",\"parentId\":\"20220421194024-stvj48i\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/正确停止线程的方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"Thread的实现方式\",\"id\":\"20220421194023-v6obecl\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"sort\":4,\"children\":[{\"title\":\"实现Runable接口\",\"id\":\"20220421194023-vrnazbw\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式#实现Runable接口\",\"parentId\":\"20220421194023-v6obecl\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4},{\"title\":\"直接继承Thread\",\"id\":\"20220421194023-id80wie\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式#直接继承Thread\",\"parentId\":\"20220421194023-v6obecl\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4},{\"title\":\"用线程池创建线程\",\"id\":\"20220421194023-7pse6e4\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式#用线程池创建线程\",\"parentId\":\"20220421194023-v6obecl\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4},{\"title\":\"使用Callable方式创建\",\"id\":\"20220421194023-w1w9u8x\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式#使用Callable方式创建\",\"parentId\":\"20220421194023-v6obecl\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4},{\"title\":\"使用Timer\",\"id\":\"20220421194023-pgfiig8\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式#使用Timer\",\"parentId\":\"20220421194023-v6obecl\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4},{\"title\":\"本质?\",\"id\":\"20220421194023-k7hn4oq\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式#本质?\",\"parentId\":\"20220421194023-v6obecl\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/Thread的实现方式\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"waitnotifynotifyAll\",\"id\":\"20220421194023-1yi0nux\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/waitnotifynotifyAll\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/waitnotifynotifyAll\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"sort\":5,\"children\":[{\"title\":\"为什么wait必须在synchronized保护的代码中使用\",\"id\":\"20220421194023-giwl4bj\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/waitnotifynotifyAll#为什么wait必须在synchronized保护的代码中使用\",\"parentId\":\"20220421194023-1yi0nux\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/waitnotifynotifyAll\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4},{\"title\":\"为什么 wait/notify/notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？\",\"id\":\"20220421194023-xaxtdxr\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/waitnotifynotifyAll#为什么 wait/notify/notifyAll 被定义在 Object 类中，而 sleep 定义在 Thread 类中？\",\"parentId\":\"20220421194023-1yi0nux\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/waitnotifynotifyAll\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4},{\"title\":\"wait/notify 和 sleep 方法的异同？\",\"id\":\"20220421194023-6kelqj2\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/waitnotifynotifyAll#wait/notify 和 sleep 方法的异同？\",\"parentId\":\"20220421194023-1yi0nux\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/waitnotifynotifyAll\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"生产者消费者模型\",\"id\":\"20220421194024-s4r7b6l\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/生产者消费者模型\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/生产者消费者模型\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"sort\":6,\"children\":[{\"title\":\"生产者消费者模式\",\"id\":\"20220421194024-85fpsgz\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/生产者消费者模型#生产者消费者模式\",\"parentId\":\"20220421194024-s4r7b6l\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/生产者消费者模型\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4},{\"title\":\"使用 BlockingQueue 实现生产者消费者模式\",\"id\":\"20220421194024-xhyv35y\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/生产者消费者模型#使用 BlockingQueue 实现生产者消费者模式\",\"parentId\":\"20220421194024-s4r7b6l\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/生产者消费者模型\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4},{\"title\":\"使用 Condition 实现生产者消费者模式\",\"id\":\"20220421194024-l0y6haz\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/生产者消费者模型#使用 Condition 实现生产者消费者模式\",\"parentId\":\"20220421194024-s4r7b6l\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/生产者消费者模型\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4},{\"title\":\"使用 wait/notify 实现生产者消费者模式\",\"id\":\"20220421194024-41f5dyn\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程基础/生产者消费者模型#使用 wait/notify 实现生产者消费者模式\",\"parentId\":\"20220421194024-s4r7b6l\",\"path\":\"/topic/Java并发工具包/并发基础/线程基础/生产者消费者模型\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程基础\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"线程安全\",\"id\":\"20220421224600-95safof\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础\",\"sort\":2,\"children\":[{\"title\":\"线程不安全\",\"id\":\"20220421194024-ixgv706\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程不安全\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程不安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"sort\":1,\"children\":[{\"title\":\"线程不安全示例\",\"id\":\"20220421194024-pu2r1id\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程不安全#线程不安全示例\",\"parentId\":\"20220421194024-ixgv706\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程不安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"线程安全\",\"id\":\"20220421194024-p4q4kvp\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"sort\":7,\"children\":[{\"title\":\"什么是线程安全问题\",\"id\":\"20220421194024-s2yzr20\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#什么是线程安全问题\",\"parentId\":\"20220421194024-p4q4kvp\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":4},{\"title\":\"为何会出现线程安全问题\",\"id\":\"20220421194024-qq259d6\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#为何会出现线程安全问题\",\"parentId\":\"20220421194024-p4q4kvp\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[{\"title\":\"可见性: CPU缓存引起\",\"id\":\"20220421194024-1hqax8a\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#可见性: CPU缓存引起\",\"parentId\":\"20220421194024-qq259d6\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":5},{\"title\":\"原子性: 分时复用引起\",\"id\":\"20220421194024-vr80zol\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#原子性: 分时复用引起\",\"parentId\":\"20220421194024-qq259d6\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":5},{\"title\":\"有序性: 重排序引起\",\"id\":\"20220421194024-uv6bi5r\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#有序性: 重排序引起\",\"parentId\":\"20220421194024-qq259d6\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"一共有哪三类线程安全问题\",\"id\":\"20220421194024-qv6fwxn\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#一共有哪三类线程安全问题\",\"parentId\":\"20220421194024-p4q4kvp\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[{\"title\":\"运行结果错误\",\"id\":\"20220421194024-zg45j9j\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#运行结果错误\",\"parentId\":\"20220421194024-qv6fwxn\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":5},{\"title\":\"发布和初始化导致线程安全问题\",\"id\":\"20220421194024-82nb2py\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#发布和初始化导致线程安全问题\",\"parentId\":\"20220421194024-qv6fwxn\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":5},{\"title\":\"活跃性问题\",\"id\":\"20220421194024-l06bdd0\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#活跃性问题\",\"parentId\":\"20220421194024-qv6fwxn\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[{\"title\":\"死锁\",\"id\":\"20220421194024-xzamyko\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#死锁\",\"parentId\":\"20220421194024-l06bdd0\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[{\"title\":\"产生死锁的原因主要是：\",\"id\":\"20220421194024-jg853ka\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#产生死锁的原因主要是：\",\"parentId\":\"20220421194024-xzamyko\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":7},{\"title\":\"产生死锁的四个必要条件：\",\"id\":\"20220421194024-tka1tzp\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#产生死锁的四个必要条件：\",\"parentId\":\"20220421194024-xzamyko\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":7},{\"title\":\"死锁的解除与预防：\",\"id\":\"20220421194024-g4hr3e1\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#死锁的解除与预防：\",\"parentId\":\"20220421194024-xzamyko\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":7}],\"level\":6},{\"title\":\"活锁\",\"id\":\"20220421194024-e63z48p\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#活锁\",\"parentId\":\"20220421194024-l06bdd0\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":6},{\"title\":\"饥饿\",\"id\":\"20220421194024-48utpac\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全#饥饿\",\"parentId\":\"20220421194024-l06bdd0\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/线程安全\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":6}],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"需要注意线程安全问题的情况\",\"id\":\"20220421194024-rijyr8z\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/需要注意线程安全问题的情况\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/需要注意线程安全问题的情况\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"sort\":17,\"children\":[{\"title\":\"访问共享变量或资源\",\"id\":\"20220421194024-qsnh4er\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/需要注意线程安全问题的情况#访问共享变量或资源\",\"parentId\":\"20220421194024-rijyr8z\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/需要注意线程安全问题的情况\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":4},{\"title\":\"依赖时序的操作\",\"id\":\"20220421194024-r428t3a\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/需要注意线程安全问题的情况#依赖时序的操作\",\"parentId\":\"20220421194024-rijyr8z\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/需要注意线程安全问题的情况\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":4},{\"title\":\"对方没有声明自己是线程安全的\",\"id\":\"20220421194024-rkeg2mj\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发基础/线程安全/需要注意线程安全问题的情况#对方没有声明自己是线程安全的\",\"parentId\":\"20220421194024-rijyr8z\",\"path\":\"/topic/Java并发工具包/并发基础/线程安全/需要注意线程安全问题的情况\",\"parentPath\":\"/topic/Java并发工具包/并发基础/线程安全\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2}],\"level\":1},{\"title\":\"并发工具\",\"id\":\"20220421224648-bow8i92\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具\",\"parentPath\":\"/topic/Java并发工具包\",\"sort\":2,\"children\":[{\"title\":\"线程协作\",\"id\":\"20220421225409-vum430h\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作\",\"parentPath\":\"/topic/Java并发工具包/并发工具\",\"sort\":1,\"children\":[{\"title\":\"Semaphore信号量\",\"id\":\"20220421194023-zk5fktn\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/Semaphore信号量\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/Semaphore信号量\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"sort\":2,\"children\":[{\"title\":\"介绍\",\"id\":\"20220421194023-6x46it5\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/Semaphore信号量#介绍\",\"parentId\":\"20220421194023-zk5fktn\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/Semaphore信号量\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":4},{\"title\":\"限流实现\",\"id\":\"20220421194023-zkr7ktt\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/Semaphore信号量#限流实现\",\"parentId\":\"20220421194023-zk5fktn\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/Semaphore信号量\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":4},{\"title\":\"思考: FixedThreadPool可以替代Semaphore么?\",\"id\":\"20220421194023-cffzkvl\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/Semaphore信号量#思考: FixedThreadPool可以替代Semaphore么?\",\"parentId\":\"20220421194023-zk5fktn\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/Semaphore信号量\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"CountDownLatch详解\",\"id\":\"20220421194023-m0tc081\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/CountDownLatch详解\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/CountDownLatch详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"sort\":16,\"children\":[{\"title\":\"介绍\",\"id\":\"20220421194023-kbbcxbl\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/CountDownLatch详解#介绍\",\"parentId\":\"20220421194023-m0tc081\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/CountDownLatch详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"使用CompletableFuture解决旅游平台问题\",\"id\":\"20220421194023-7xbmrhw\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"sort\":27,\"children\":[{\"title\":\"旅游平台问题介绍\",\"id\":\"20220421194023-7f92nei\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题#旅游平台问题介绍\",\"parentId\":\"20220421194023-7xbmrhw\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[{\"title\":\"串行获取\",\"id\":\"20220421194023-xtl2a45\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题#串行获取\",\"parentId\":\"20220421194023-7f92nei\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":5},{\"title\":\"并行获取\",\"id\":\"20220421194023-kuctn4p\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题#并行获取\",\"parentId\":\"20220421194023-7f92nei\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"使用线程池实现\",\"id\":\"20220421194023-ipafk28\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题#使用线程池实现\",\"parentId\":\"20220421194023-7xbmrhw\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":4},{\"title\":\"CountDownLatch\",\"id\":\"20220421194023-yhiuvd1\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题#CountDownLatch\",\"parentId\":\"20220421194023-7xbmrhw\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":4},{\"title\":\"CompletableFuture\",\"id\":\"20220421194023-uyxclzb\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题#CompletableFuture\",\"parentId\":\"20220421194023-7xbmrhw\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CompletableFuture解决旅游平台问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"使用CyclicBarrier解决团建问题\",\"id\":\"20220421194023-2t11ew0\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"sort\":30,\"children\":[{\"title\":\"团建问题介绍\",\"id\":\"20220421194023-eubfypd\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题#团建问题介绍\",\"parentId\":\"20220421194023-2t11ew0\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":4},{\"title\":\"模拟场景\",\"id\":\"20220421194023-ths6hk3\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题#模拟场景\",\"parentId\":\"20220421194023-2t11ew0\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":4},{\"title\":\"CyclicBarrier 和 CountDownLatch 的异同\",\"id\":\"20220421194023-w7mli0h\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题#CyclicBarrier 和 CountDownLatch 的异同\",\"parentId\":\"20220421194023-2t11ew0\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[{\"title\":\"相同点\",\"id\":\"20220421194023-ha0hs5i\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题#相同点\",\"parentId\":\"20220421194023-w7mli0h\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":5},{\"title\":\"不同点\",\"id\":\"20220421194023-5khi9b8\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题#不同点\",\"parentId\":\"20220421194023-w7mli0h\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[{\"title\":\"作用对象不同\",\"id\":\"20220421194023-6ka48ra\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题#作用对象不同\",\"parentId\":\"20220421194023-5khi9b8\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":6},{\"title\":\"可重用性不同\",\"id\":\"20220421194023-hpyerj6\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题#可重用性不同\",\"parentId\":\"20220421194023-5khi9b8\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":6},{\"title\":\"执行动作不同\",\"id\":\"20220421194023-xpadrxw\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题#执行动作不同\",\"parentId\":\"20220421194023-5khi9b8\",\"path\":\"/topic/Java并发工具包/并发工具/线程协作/使用CyclicBarrier解决团建问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程协作\",\"children\":[],\"level\":6}],\"level\":5}],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"Future\",\"id\":\"20220421225357-mgk8fm8\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/Future\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/Future\",\"parentPath\":\"/topic/Java并发工具包/并发工具\",\"sort\":2,\"children\":[{\"title\":\"Future主要功能\",\"id\":\"20220421194023-tc7cnvu\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"sort\":2,\"children\":[{\"title\":\"Future接口\",\"id\":\"20220421194023-vy1iaus\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能#Future接口\",\"parentId\":\"20220421194023-tc7cnvu\",\"path\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[{\"title\":\"cancel方法: 取消任务执行\",\"id\":\"20220421194023-2p9j49p\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能#cancel方法: 取消任务执行\",\"parentId\":\"20220421194023-vy1iaus\",\"path\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[],\"level\":5},{\"title\":\"isCancelled() 方法:判断是否被取消\",\"id\":\"20220421194023-abekw76\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能#isCancelled() 方法:判断是否被取消\",\"parentId\":\"20220421194023-vy1iaus\",\"path\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[],\"level\":5},{\"title\":\"isDown():判断是否执行完毕\",\"id\":\"20220421194023-n3gtv77\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能#isDown():判断是否执行完毕\",\"parentId\":\"20220421194023-vy1iaus\",\"path\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[],\"level\":5},{\"title\":\"get(): 获取结果\",\"id\":\"20220421194023-4rsknhp\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能#get(): 获取结果\",\"parentId\":\"20220421194023-vy1iaus\",\"path\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"基础实现\",\"id\":\"20220421194023-vd9seqp\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能#基础实现\",\"parentId\":\"20220421194023-tc7cnvu\",\"path\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[{\"title\":\"FutureTask示例\",\"id\":\"20220421194023-gptncr7\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能#FutureTask示例\",\"parentId\":\"20220421194023-vd9seqp\",\"path\":\"/topic/Java并发工具包/并发工具/Future/Future主要功能\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"FutureTask源码分析\",\"id\":\"20220421194023-lcf6hel\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"sort\":3,\"children\":[{\"title\":\"核心属性\",\"id\":\"20220421194023-b1jl1as\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析#核心属性\",\"parentId\":\"20220421194023-lcf6hel\",\"path\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[],\"level\":4},{\"title\":\"构造函数\",\"id\":\"20220421194023-6ga3tdq\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析#构造函数\",\"parentId\":\"20220421194023-lcf6hel\",\"path\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[],\"level\":4},{\"title\":\"核心方法：Run()\",\"id\":\"20220421194023-wmuyfw2\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析#核心方法：Run()\",\"parentId\":\"20220421194023-lcf6hel\",\"path\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[],\"level\":4},{\"title\":\"核心方法:get()\",\"id\":\"20220421194023-hqg3oz2\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析#核心方法:get()\",\"parentId\":\"20220421194023-lcf6hel\",\"path\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[],\"level\":4},{\"title\":\"核心方法:awaitDone(boolean timed,long nanos)\",\"id\":\"20220421194023-5kudbjb\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析#核心方法:awaitDone(boolean timed,long nanos)\",\"parentId\":\"20220421194023-lcf6hel\",\"path\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[],\"level\":4},{\"title\":\"核心方法:Cancel()\",\"id\":\"20220421194023-z9yspi4\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析#核心方法:Cancel()\",\"parentId\":\"20220421194023-lcf6hel\",\"path\":\"/topic/Java并发工具包/并发工具/Future/FutureTask源码分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/Future\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"ThreadLocal\",\"id\":\"20220421225340-rez89hu\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/ThreadLocal\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/ThreadLocal\",\"parentPath\":\"/topic/Java并发工具包/并发工具\",\"sort\":3,\"children\":[{\"title\":\"ThreadLocal内存泄漏\",\"id\":\"20220421194023-skqpi80\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal内存泄漏\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal内存泄漏\",\"parentPath\":\"/topic/Java并发工具包/并发工具/ThreadLocal\",\"sort\":18,\"children\":[{\"title\":\"ThreadLocal的实现原理\",\"id\":\"20220421194023-8fje0qn\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal内存泄漏#ThreadLocal的实现原理\",\"parentId\":\"20220421194023-skqpi80\",\"path\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal内存泄漏\",\"parentPath\":\"/topic/Java并发工具包/并发工具/ThreadLocal\",\"children\":[],\"level\":4},{\"title\":\"内存泄漏的案例\",\"id\":\"20220421194023-kzn89ie\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal内存泄漏#内存泄漏的案例\",\"parentId\":\"20220421194023-skqpi80\",\"path\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal内存泄漏\",\"parentPath\":\"/topic/Java并发工具包/并发工具/ThreadLocal\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"ThreadLocal使用场景\",\"id\":\"20220421194023-5y0rwt1\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal使用场景\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal使用场景\",\"parentPath\":\"/topic/Java并发工具包/并发工具/ThreadLocal\",\"sort\":28,\"children\":[{\"title\":\"保存线程不安全的工具类\",\"id\":\"20220421194023-ip2bddc\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal使用场景#保存线程不安全的工具类\",\"parentId\":\"20220421194023-5y0rwt1\",\"path\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal使用场景\",\"parentPath\":\"/topic/Java并发工具包/并发工具/ThreadLocal\",\"children\":[],\"level\":4},{\"title\":\"传递全局变量\",\"id\":\"20220421194023-4h7hbuz\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal使用场景#传递全局变量\",\"parentId\":\"20220421194023-5y0rwt1\",\"path\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal使用场景\",\"parentPath\":\"/topic/Java并发工具包/并发工具/ThreadLocal\",\"children\":[],\"level\":4},{\"title\":\"面试题: ThreadLocal是用来解决共享资源的多线程访问吗?\",\"id\":\"20220421194023-jbeie1n\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal使用场景#面试题: ThreadLocal是用来解决共享资源的多线程访问吗?\",\"parentId\":\"20220421194023-5y0rwt1\",\"path\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal使用场景\",\"parentPath\":\"/topic/Java并发工具包/并发工具/ThreadLocal\",\"children\":[{\"title\":\"ThreadLocal 和 synchronized 是什么关系\",\"id\":\"20220421194023-9j0pf34\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal使用场景#ThreadLocal 和 synchronized 是什么关系\",\"parentId\":\"20220421194023-jbeie1n\",\"path\":\"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal使用场景\",\"parentPath\":\"/topic/Java并发工具包/并发工具/ThreadLocal\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"原子类\",\"id\":\"20220421225252-idqz1wx\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/原子类\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/原子类\",\"parentPath\":\"/topic/Java并发工具包/并发工具\",\"sort\":4,\"children\":[{\"title\":\"原子类的作用概览\",\"id\":\"20220421194024-q0d2887\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"sort\":1,\"children\":[{\"title\":\"什么是原子类，有什么作用\",\"id\":\"20220421194024-i2dwj9d\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览#什么是原子类，有什么作用\",\"parentId\":\"20220421194024-q0d2887\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":4},{\"title\":\"原子类概览\",\"id\":\"20220421194024-pbmtb0x\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览#原子类概览\",\"parentId\":\"20220421194024-q0d2887\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[{\"title\":\"原子更新基本类型\",\"id\":\"20220421194024-bkoixwz\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览#原子更新基本类型\",\"parentId\":\"20220421194024-pbmtb0x\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":5},{\"title\":\"原子更新数组\",\"id\":\"20220421194024-3llb9j7\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览#原子更新数组\",\"parentId\":\"20220421194024-pbmtb0x\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":5},{\"title\":\"原子更新引用类型\",\"id\":\"20220421194024-3iezmq2\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览#原子更新引用类型\",\"parentId\":\"20220421194024-pbmtb0x\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":5},{\"title\":\"原子更新字段\",\"id\":\"20220421194024-1vf6ovf\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览#原子更新字段\",\"parentId\":\"20220421194024-pbmtb0x\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":5},{\"title\":\"Adder 加法器和Accumulator积累器\",\"id\":\"20220421194024-uit0km0\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览#Adder 加法器和Accumulator积累器\",\"parentId\":\"20220421194024-pbmtb0x\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[{\"title\":\"Adder介绍\",\"id\":\"20220421194024-h82jb7t\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览#Adder介绍\",\"parentId\":\"20220421194024-uit0km0\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":6},{\"title\":\"Accumulator介绍\",\"id\":\"20220421194024-8fqd15u\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览#Accumulator介绍\",\"parentId\":\"20220421194024-uit0km0\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":6},{\"title\":\"拓展功能\",\"id\":\"20220421194024-dym8r6k\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览#拓展功能\",\"parentId\":\"20220421194024-uit0km0\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":6},{\"title\":\"适用场景\",\"id\":\"20220421194024-y140gog\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览#适用场景\",\"parentId\":\"20220421194024-uit0km0\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的作用概览\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":6}],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"原子类的性能分析\",\"id\":\"20220421194024-x4a73dp\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的性能分析\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的性能分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"sort\":5,\"children\":[{\"title\":\"AtomicLong的问题\",\"id\":\"20220421194024-23koi5c\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的性能分析#AtomicLong的问题\",\"parentId\":\"20220421194024-x4a73dp\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的性能分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":4},{\"title\":\"升级版LongAdder\",\"id\":\"20220421194024-up05t2j\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的性能分析#升级版LongAdder\",\"parentId\":\"20220421194024-x4a73dp\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的性能分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":4},{\"title\":\"如何选择\",\"id\":\"20220421194024-zsum368\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的性能分析#如何选择\",\"parentId\":\"20220421194024-x4a73dp\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的性能分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[{\"title\":\"AtomicLong 可否被 LongAdder 替代？\",\"id\":\"20220421194024-1dx3jlm\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的性能分析#AtomicLong 可否被 LongAdder 替代？\",\"parentId\":\"20220421194024-zsum368\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的性能分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"结论\",\"id\":\"20220421194024-ifiji7o\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/原子类/原子类的性能分析#结论\",\"parentId\":\"20220421194024-x4a73dp\",\"path\":\"/topic/Java并发工具包/并发工具/原子类/原子类的性能分析\",\"parentPath\":\"/topic/Java并发工具包/并发工具/原子类\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"阻塞队列\",\"id\":\"20220421225150-nu224ql\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具\",\"sort\":5,\"children\":[{\"title\":\"常见的阻塞队列\",\"id\":\"20220421194024-9ltr7q3\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"sort\":1,\"children\":[{\"title\":\"ArrayBlockingQueue\",\"id\":\"20220421194024-5nxnstz\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列#ArrayBlockingQueue\",\"parentId\":\"20220421194024-9ltr7q3\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":4},{\"title\":\"LinkedBlockingQueue\",\"id\":\"20220421194024-2anxh67\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列#LinkedBlockingQueue\",\"parentId\":\"20220421194024-9ltr7q3\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":4},{\"title\":\"SynchronousQueue\",\"id\":\"20220421194024-5dmd94t\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列#SynchronousQueue\",\"parentId\":\"20220421194024-9ltr7q3\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":4},{\"title\":\"PriorityBlockingQueue\",\"id\":\"20220421194024-0qkwqym\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列#PriorityBlockingQueue\",\"parentId\":\"20220421194024-9ltr7q3\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":4},{\"title\":\"DelayQueue\",\"id\":\"20220421194024-gwhbp1l\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列#DelayQueue\",\"parentId\":\"20220421194024-9ltr7q3\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":4},{\"title\":\"如何选择\",\"id\":\"20220421194024-bbafwco\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列#如何选择\",\"parentId\":\"20220421194024-9ltr7q3\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[{\"title\":\"线程池对于阻塞队列的选择\",\"id\":\"20220421194024-wfrhink\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列#线程池对于阻塞队列的选择\",\"parentId\":\"20220421194024-bbafwco\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5},{\"title\":\"归纳\",\"id\":\"20220421194024-oncdnpz\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列#归纳\",\"parentId\":\"20220421194024-bbafwco\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/常见的阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"阻塞队列的常用方法\",\"id\":\"20220421194024-f1qdcm3\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"sort\":2,\"children\":[{\"title\":\"第一组：add、remove、element\",\"id\":\"20220421194024-6fq31g5\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#第一组：add、remove、element\",\"parentId\":\"20220421194024-f1qdcm3\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[{\"title\":\"add 方法\",\"id\":\"20220421194024-hw2svfq\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#add 方法\",\"parentId\":\"20220421194024-6fq31g5\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5},{\"title\":\"remove 方法\",\"id\":\"20220421194024-1vkhstt\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#remove 方法\",\"parentId\":\"20220421194024-6fq31g5\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5},{\"title\":\"element 方法\",\"id\":\"20220421194024-5kr6svs\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#element 方法\",\"parentId\":\"20220421194024-6fq31g5\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"第二组：offer、poll、peek\",\"id\":\"20220421194024-cel6bgj\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#第二组：offer、poll、peek\",\"parentId\":\"20220421194024-f1qdcm3\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[{\"title\":\"offer 方法\",\"id\":\"20220421194024-5wzpseg\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#offer 方法\",\"parentId\":\"20220421194024-cel6bgj\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5},{\"title\":\"poll 方法\",\"id\":\"20220421194024-818miy8\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#poll 方法\",\"parentId\":\"20220421194024-cel6bgj\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5},{\"title\":\"peek 方法\",\"id\":\"20220421194024-ym52mns\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#peek 方法\",\"parentId\":\"20220421194024-cel6bgj\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5},{\"title\":\"带超时时间的 offer 和 poll\",\"id\":\"20220421194024-zlxgydf\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#带超时时间的 offer 和 poll\",\"parentId\":\"20220421194024-cel6bgj\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5},{\"title\":\"第三组：put、take\",\"id\":\"20220421194024-s1x6qky\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#第三组：put、take\",\"parentId\":\"20220421194024-cel6bgj\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5},{\"title\":\"put 方法\",\"id\":\"20220421194024-udcplfa\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#put 方法\",\"parentId\":\"20220421194024-cel6bgj\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5},{\"title\":\"take 方法\",\"id\":\"20220421194024-zinhklk\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#take 方法\",\"parentId\":\"20220421194024-cel6bgj\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"总结\",\"id\":\"20220421194024-egm4xgr\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法#总结\",\"parentId\":\"20220421194024-f1qdcm3\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/阻塞队列的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"什么是阻塞队列\",\"id\":\"20220421194023-4d0fgjl\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/什么是阻塞队列\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/什么是阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"sort\":29,\"children\":[{\"title\":\"阻塞队列的作用\",\"id\":\"20220421194023-ct89u9n\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/什么是阻塞队列#阻塞队列的作用\",\"parentId\":\"20220421194023-4d0fgjl\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/什么是阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":4},{\"title\":\"主要并发队列关系图\",\"id\":\"20220421194023-4gdg5oq\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/什么是阻塞队列#主要并发队列关系图\",\"parentId\":\"20220421194023-4d0fgjl\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/什么是阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":4},{\"title\":\"阻塞队列的特点\",\"id\":\"20220421194023-yvfdoea\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/什么是阻塞队列#阻塞队列的特点\",\"parentId\":\"20220421194023-4d0fgjl\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/什么是阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[{\"title\":\"是否有界（容量有多大）\",\"id\":\"20220421194023-thwd1kf\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/阻塞队列/什么是阻塞队列#是否有界（容量有多大）\",\"parentId\":\"20220421194023-yvfdoea\",\"path\":\"/topic/Java并发工具包/并发工具/阻塞队列/什么是阻塞队列\",\"parentPath\":\"/topic/Java并发工具包/并发工具/阻塞队列\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"并发容器\",\"id\":\"20220421225042-g34phsd\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器\",\"parentPath\":\"/topic/Java并发工具包/并发工具\",\"sort\":6,\"children\":[{\"title\":\"HashMap\",\"id\":\"20220421194023-chqzo14\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"sort\":1,\"children\":[{\"title\":\"HashMap实现原理\",\"id\":\"20220421194023-kqco0df\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap#HashMap实现原理\",\"parentId\":\"20220421194023-chqzo14\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":4},{\"title\":\"功能实现\",\"id\":\"20220421194023-c7q57es\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap#功能实现\",\"parentId\":\"20220421194023-chqzo14\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[{\"title\":\"1. 确定哈希桶数组索引位置\",\"id\":\"20220421194023-pna9o0r\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap#1. 确定哈希桶数组索引位置\",\"parentId\":\"20220421194023-c7q57es\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[{\"title\":\"2. 分析HashMap的put方法\",\"id\":\"20220421194023-r988dwu\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap#2. 分析HashMap的put方法\",\"parentId\":\"20220421194023-pna9o0r\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":6}],\"level\":5},{\"title\":\"3. 扩容机制\",\"id\":\"20220421194023-x0skg7v\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap#3. 扩容机制\",\"parentId\":\"20220421194023-c7q57es\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"为什么hashmap的在链表元素数量超过8时改为红黑树?\",\"id\":\"20220421194023-6azroph\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap#为什么hashmap的在链表元素数量超过8时改为红黑树?\",\"parentId\":\"20220421194023-c7q57es\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"线程安全性\",\"id\":\"20220421194023-hc9vfve\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap#线程安全性\",\"parentId\":\"20220421194023-chqzo14\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/HashMap\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"CopyOnWriteArrayList\",\"id\":\"20220421194022-gkzupas\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"sort\":34,\"children\":[{\"title\":\"特点\",\"id\":\"20220421194022-xhc42v3\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#特点\",\"parentId\":\"20220421194022-gkzupas\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":4},{\"title\":\"复制修改\",\"id\":\"20220421194022-f6dagmk\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#复制修改\",\"parentId\":\"20220421194022-gkzupas\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[{\"title\":\"迭代期间允许修改集合内容\",\"id\":\"20220421194022-8p51kd9\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#迭代期间允许修改集合内容\",\"parentId\":\"20220421194022-f6dagmk\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"缺点\",\"id\":\"20220421194022-wei24tc\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#缺点\",\"parentId\":\"20220421194022-gkzupas\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[{\"title\":\"内存占用大\",\"id\":\"20220421194022-vt8lr1s\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#内存占用大\",\"parentId\":\"20220421194022-wei24tc\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"元素较多或者复杂的情况下，复制的开销大\",\"id\":\"20220421194022-1i2c7pa\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#元素较多或者复杂的情况下，复制的开销大\",\"parentId\":\"20220421194022-wei24tc\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"数据一致性无法保证\",\"id\":\"20220421194022-ap6n3fh\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#数据一致性无法保证\",\"parentId\":\"20220421194022-wei24tc\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"只适合读多写少的场景\",\"id\":\"20220421194022-sc0eogs\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#只适合读多写少的场景\",\"parentId\":\"20220421194022-wei24tc\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"源码分析\",\"id\":\"20220421194022-rp1fvlk\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#源码分析\",\"parentId\":\"20220421194022-gkzupas\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[{\"title\":\"数据结构\",\"id\":\"20220421194022-ols3w10\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#数据结构\",\"parentId\":\"20220421194022-rp1fvlk\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"add方法\",\"id\":\"20220421194022-jfyru3k\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#add方法\",\"parentId\":\"20220421194022-rp1fvlk\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"get操作\",\"id\":\"20220421194022-0i2nkyh\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#get操作\",\"parentId\":\"20220421194022-rp1fvlk\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"迭代器COWIterator类\",\"id\":\"20220421194022-8cd7t0h\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList#迭代器COWIterator类\",\"parentId\":\"20220421194022-rp1fvlk\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/CopyOnWriteArrayList\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"ConcurrentHashMap详解\",\"id\":\"20220421194022-5ml6ohm\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"sort\":35,\"children\":[{\"title\":\"ConcurrentHashMap_JDK7\",\"id\":\"20220421194022-6zgzl9m\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#ConcurrentHashMap_JDK7\",\"parentId\":\"20220421194022-5ml6ohm\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[{\"title\":\"数据结构\",\"id\":\"20220421194022-sk8dfnt\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#数据结构\",\"parentId\":\"20220421194022-6zgzl9m\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"初始化\",\"id\":\"20220421194022-g7elxkv\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#初始化\",\"parentId\":\"20220421194022-6zgzl9m\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"初始化\",\"id\":\"20220421194022-yxirnxp\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#初始化\",\"parentId\":\"20220421194022-6zgzl9m\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"put过程分析\",\"id\":\"20220421194022-9gz36tc\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#put过程分析\",\"parentId\":\"20220421194022-6zgzl9m\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"初始化槽: ensureSegment\",\"id\":\"20220421194022-rneyw0q\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#初始化槽: ensureSegment\",\"parentId\":\"20220421194022-6zgzl9m\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"获取写入锁-scanandlockforput\",\"id\":\"20220421194022-s2nr2es\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#获取写入锁-scanandlockforput\",\"parentId\":\"20220421194022-6zgzl9m\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"扩容-rehash\",\"id\":\"20220421194022-yqejgid\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#扩容-rehash\",\"parentId\":\"20220421194022-6zgzl9m\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"get 过程分析\",\"id\":\"20220421194022-b31z8ro\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#get 过程分析\",\"parentId\":\"20220421194022-6zgzl9m\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"并发问题分析\",\"id\":\"20220421194022-3aiwwre\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#并发问题分析\",\"parentId\":\"20220421194022-6zgzl9m\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"ConcurrentHashMap_JDK8\",\"id\":\"20220421194022-9m25zzz\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#ConcurrentHashMap_JDK8\",\"parentId\":\"20220421194022-5ml6ohm\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[{\"title\":\"put 方法源码分析\",\"id\":\"20220421194022-n3u48ll\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#put 方法源码分析\",\"parentId\":\"20220421194022-9m25zzz\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"get 方法源码分析\",\"id\":\"20220421194022-snon8lc\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#get 方法源码分析\",\"parentId\":\"20220421194022-9m25zzz\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"对比Java7 和Java8 的异同和优缺点\",\"id\":\"20220421194022-5t06zk3\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#对比Java7 和Java8 的异同和优缺点\",\"parentId\":\"20220421194022-5ml6ohm\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[{\"title\":\"并发度\",\"id\":\"20220421194022-56z19kf\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#并发度\",\"parentId\":\"20220421194022-5t06zk3\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"保证并发安全的原理\",\"id\":\"20220421194022-unwfvqu\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#保证并发安全的原理\",\"parentId\":\"20220421194022-5t06zk3\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"遇到 Hash 碰撞\",\"id\":\"20220421194022-k1yvu6g\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#遇到 Hash 碰撞\",\"parentId\":\"20220421194022-5t06zk3\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5},{\"title\":\"查询时间复杂度\",\"id\":\"20220421194022-k703vus\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解#查询时间复杂度\",\"parentId\":\"20220421194022-5t06zk3\",\"path\":\"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解\",\"parentPath\":\"/topic/Java并发工具包/并发工具/并发容器\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"线程池\",\"id\":\"20220421224850-czk1iq2\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/线程池\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/线程池\",\"parentPath\":\"/topic/Java并发工具包/并发工具\",\"sort\":7,\"children\":[{\"title\":\"为什么多线程会带来性能问题\",\"id\":\"20220421194023-n21nz3d\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/为什么多线程会带来性能问题\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/为什么多线程会带来性能问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"sort\":1,\"children\":[{\"title\":\"线程调度开销\",\"id\":\"20220421194023-zlthf6f\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/为什么多线程会带来性能问题#线程调度开销\",\"parentId\":\"20220421194023-n21nz3d\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/为什么多线程会带来性能问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[{\"title\":\"上下文切换\",\"id\":\"20220421194023-ampsejl\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/为什么多线程会带来性能问题#上下文切换\",\"parentId\":\"20220421194023-zlthf6f\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/为什么多线程会带来性能问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5},{\"title\":\"缓存失效\",\"id\":\"20220421194023-gxegw5b\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/为什么多线程会带来性能问题#缓存失效\",\"parentId\":\"20220421194023-zlthf6f\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/为什么多线程会带来性能问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"协作开销\",\"id\":\"20220421194023-kqso0jm\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/为什么多线程会带来性能问题#协作开销\",\"parentId\":\"20220421194023-n21nz3d\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/为什么多线程会带来性能问题\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"线程池的优势\",\"id\":\"20220421194024-vgrsujq\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/线程池的优势\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/线程池的优势\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"sort\":2,\"children\":[{\"title\":\"如何提升运行效率\",\"id\":\"20220421194024-6y78ao9\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/线程池的优势#如何提升运行效率\",\"parentId\":\"20220421194024-vgrsujq\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/线程池的优势\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":4},{\"title\":\"使用线程池的好处\",\"id\":\"20220421194024-x77rkxj\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/线程池的优势#使用线程池的好处\",\"parentId\":\"20220421194024-vgrsujq\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/线程池的优势\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":4},{\"title\":\"线程池的思想\",\"id\":\"20220421194024-yyqzh03\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/线程池的优势#线程池的思想\",\"parentId\":\"20220421194024-vgrsujq\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/线程池的优势\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"创建线程池的参数\",\"id\":\"20220421194024-djxcl5s\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"sort\":3,\"children\":[{\"title\":\"参数列表\",\"id\":\"20220421194024-b671uhp\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数#参数列表\",\"parentId\":\"20220421194024-djxcl5s\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":4},{\"title\":\"创建时机\",\"id\":\"20220421194024-7lyw2w7\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数#创建时机\",\"parentId\":\"20220421194024-djxcl5s\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":4},{\"title\":\"线程工厂ThreadFactory\",\"id\":\"20220421194024-nogaxlu\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数#线程工厂ThreadFactory\",\"parentId\":\"20220421194024-djxcl5s\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":4},{\"title\":\"工作队列WorkQueue\",\"id\":\"20220421194024-4kcqxyc\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数#工作队列WorkQueue\",\"parentId\":\"20220421194024-djxcl5s\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":4},{\"title\":\"拒绝策略Handler\",\"id\":\"20220421194024-zl2siby\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数#拒绝策略Handler\",\"parentId\":\"20220421194024-djxcl5s\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[{\"title\":\"DiscardPolicy\",\"id\":\"20220421194024-vtchp4t\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数#DiscardPolicy\",\"parentId\":\"20220421194024-zl2siby\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5},{\"title\":\"DiscardOldestPolicy\",\"id\":\"20220421194024-d1a21wu\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数#DiscardOldestPolicy\",\"parentId\":\"20220421194024-zl2siby\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5},{\"title\":\"CallerRunsPolicy\",\"id\":\"20220421194024-sm0r1i3\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数#CallerRunsPolicy\",\"parentId\":\"20220421194024-zl2siby\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5},{\"title\":\"AbortPolicy\",\"id\":\"20220421194024-9wiz58a\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数#AbortPolicy\",\"parentId\":\"20220421194024-zl2siby\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"如何设置线程数\",\"id\":\"20220429164341-mzc6839\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数/如何设置线程数\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数/如何设置线程数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"children\":[{\"title\":\"现有的解决方案\",\"id\":\"20220429164831-97mzysk\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数/如何设置线程数#现有的解决方案\",\"parentId\":\"20220429164341-mzc6839\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数/如何设置线程数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"children\":[],\"level\":5},{\"title\":\"动态更新的原理\",\"id\":\"20220429165540-guqhe26\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数/如何设置线程数#动态更新的原理\",\"parentId\":\"20220429164341-mzc6839\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数/如何设置线程数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"children\":[],\"level\":5},{\"title\":\"面试考点\",\"id\":\"20220429171440-0qcp4m7\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数/如何设置线程数#面试考点\",\"parentId\":\"20220429164341-mzc6839\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数/如何设置线程数\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池/创建线程池的参数\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"线程池线程复用原理\",\"id\":\"20220421194024-csc9ehx\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/线程池线程复用原理\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/线程池线程复用原理\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"sort\":4,\"children\":[{\"title\":\"实现方式\",\"id\":\"20220421194024-vpwln3p\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/线程池线程复用原理#实现方式\",\"parentId\":\"20220421194024-csc9ehx\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/线程池线程复用原理\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":4},{\"title\":\"总结\",\"id\":\"20220421194024-717ovf1\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/线程池线程复用原理#总结\",\"parentId\":\"20220421194024-csc9ehx\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/线程池线程复用原理\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"ForkJoin框架\",\"id\":\"20220421194023-elf7igk\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"sort\":5,\"children\":[{\"title\":\"案例?\",\"id\":\"20220421194023-tzg5g35\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架#案例?\",\"parentId\":\"20220421194023-elf7igk\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":4},{\"title\":\"原理\",\"id\":\"20220421194023-syy1lho\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架#原理\",\"parentId\":\"20220421194023-elf7igk\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[{\"title\":\"work-stealing 工作窃取\",\"id\":\"20220421194023-av4fqp8\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架#work-stealing 工作窃取\",\"parentId\":\"20220421194023-syy1lho\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5},{\"title\":\"执行流程\",\"id\":\"20220421194023-2lsmwfw\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架#执行流程\",\"parentId\":\"20220421194023-syy1lho\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5},{\"title\":\"步骤分解\",\"id\":\"20220421194023-ziwpdpr\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架#步骤分解\",\"parentId\":\"20220421194023-syy1lho\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5},{\"title\":\"外部任务提交\",\"id\":\"20220421194023-bcns9vl\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架#外部任务提交\",\"parentId\":\"20220421194023-syy1lho\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5},{\"title\":\"子任务提交\",\"id\":\"20220421194023-dnjdw7f\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架#子任务提交\",\"parentId\":\"20220421194023-syy1lho\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5},{\"title\":\"执行任务\",\"id\":\"20220421194023-xf41cyy\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架#执行任务\",\"parentId\":\"20220421194023-syy1lho\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5},{\"title\":\"获取任务执行结果\",\"id\":\"20220421194023-adsuwll\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架#获取任务执行结果\",\"parentId\":\"20220421194023-syy1lho\",\"path\":\"/topic/Java并发工具包/并发工具/线程池/ForkJoin框架\",\"parentPath\":\"/topic/Java并发工具包/并发工具/线程池\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"各种锁\",\"id\":\"20220421224921-0q4b1mn\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具\",\"sort\":9,\"children\":[{\"title\":\"锁的种类和特点\",\"id\":\"20220421194024-5l8t6o8\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"sort\":2,\"children\":[{\"title\":\"偏向锁/轻量级锁/重量级锁\",\"id\":\"20220421194024-h5c55jn\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点#偏向锁/轻量级锁/重量级锁\",\"parentId\":\"20220421194024-5l8t6o8\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"可重入锁/不可重入锁\",\"id\":\"20220421194024-psvbp68\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点#可重入锁/不可重入锁\",\"parentId\":\"20220421194024-5l8t6o8\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"共享锁/独占锁\",\"id\":\"20220421194024-huov0bn\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点#共享锁/独占锁\",\"parentId\":\"20220421194024-5l8t6o8\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"公平锁/非公平锁\",\"id\":\"20220421194024-moj8qbg\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点#公平锁/非公平锁\",\"parentId\":\"20220421194024-5l8t6o8\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"乐观锁/悲观锁\",\"id\":\"20220421194024-kd10zrr\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点#乐观锁/悲观锁\",\"parentId\":\"20220421194024-5l8t6o8\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"自旋锁/非自旋锁\",\"id\":\"20220421194024-mxhbm3r\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点#自旋锁/非自旋锁\",\"parentId\":\"20220421194024-5l8t6o8\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"不可中断锁/可中断锁\",\"id\":\"20220421194024-n17hmsj\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点#不可中断锁/可中断锁\",\"parentId\":\"20220421194024-5l8t6o8\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"公平锁非公平锁\",\"id\":\"20220421194024-ysp8l1x\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/公平锁非公平锁\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/公平锁非公平锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"sort\":1,\"children\":[{\"title\":\"特点\",\"id\":\"20220421194024-611w97c\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/公平锁非公平锁#特点\",\"parentId\":\"20220421194024-ysp8l1x\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/公平锁非公平锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5},{\"title\":\"案例\",\"id\":\"20220421194024-nzgiykj\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/公平锁非公平锁#案例\",\"parentId\":\"20220421194024-ysp8l1x\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/公平锁非公平锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5},{\"title\":\"源码\",\"id\":\"20220421194024-1bh92oa\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/公平锁非公平锁#源码\",\"parentId\":\"20220421194024-ysp8l1x\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/公平锁非公平锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"自旋锁非自旋锁\",\"id\":\"20220421194024-yg8yxap\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/自旋锁非自旋锁\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/自旋锁非自旋锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"sort\":4,\"children\":[{\"title\":\"对比自旋和非自旋获取锁的流程\",\"id\":\"20220421194024-xy6eth3\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/自旋锁非自旋锁#对比自旋和非自旋获取锁的流程\",\"parentId\":\"20220421194024-yg8yxap\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/自旋锁非自旋锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5},{\"title\":\"自旋锁的好处\",\"id\":\"20220421194024-p0fl9am\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/自旋锁非自旋锁#自旋锁的好处\",\"parentId\":\"20220421194024-yg8yxap\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/自旋锁非自旋锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5},{\"title\":\"自旋锁的缺点\",\"id\":\"20220421194024-x747q9w\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/自旋锁非自旋锁#自旋锁的缺点\",\"parentId\":\"20220421194024-yg8yxap\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/自旋锁非自旋锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5},{\"title\":\"适用场景\",\"id\":\"20220421194024-ntoqquk\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/自旋锁非自旋锁#适用场景\",\"parentId\":\"20220421194024-yg8yxap\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/自旋锁非自旋锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"共享锁独占锁\",\"id\":\"20220421194024-pfoblt6\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"sort\":7,\"children\":[{\"title\":\"读写锁的规则\",\"id\":\"20220421194024-inct3ng\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁#读写锁的规则\",\"parentId\":\"20220421194024-pfoblt6\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5},{\"title\":\"使用方式\",\"id\":\"20220421194024-viyhwby\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁#使用方式\",\"parentId\":\"20220421194024-pfoblt6\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5},{\"title\":\"加锁原理分析\",\"id\":\"20220421194024-5584v3u\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁#加锁原理分析\",\"parentId\":\"20220421194024-pfoblt6\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5},{\"title\":\"插队逻辑\",\"id\":\"20220421194024-kzrefev\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁#插队逻辑\",\"parentId\":\"20220421194024-pfoblt6\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[{\"title\":\"第一种策略：允许插队\",\"id\":\"20220421194024-xtt9bo3\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁#第一种策略：允许插队\",\"parentId\":\"20220421194024-kzrefev\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":6},{\"title\":\"第二种策略：不允许插队\",\"id\":\"20220421194024-vab8sxx\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁#第二种策略：不允许插队\",\"parentId\":\"20220421194024-kzrefev\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":6}],\"level\":5},{\"title\":\"锁的升降级\",\"id\":\"20220421194024-qy1rjr6\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁#锁的升降级\",\"parentId\":\"20220421194024-pfoblt6\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[{\"title\":\"降级的过程\",\"id\":\"20220421194024-agdihem\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁#降级的过程\",\"parentId\":\"20220421194024-qy1rjr6\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":6},{\"title\":\"为什么需要锁的降级\",\"id\":\"20220421194024-x3i0wc5\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁#为什么需要锁的降级\",\"parentId\":\"20220421194024-qy1rjr6\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":6},{\"title\":\"为什么不支持锁的升级？\",\"id\":\"20220421194024-93vneo7\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁#为什么不支持锁的升级？\",\"parentId\":\"20220421194024-qy1rjr6\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":6},{\"title\":\"总结\",\"id\":\"20220421194024-3qkx6j2\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁#总结\",\"parentId\":\"20220421194024-qy1rjr6\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/共享锁独占锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":6}],\"level\":5}],\"level\":4},{\"title\":\"乐观锁和悲观锁\",\"id\":\"20220421194023-puex63d\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/乐观锁和悲观锁\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/乐观锁和悲观锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"sort\":17,\"children\":[{\"title\":\"悲观锁\",\"id\":\"20220421194023-7zp2dq3\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/乐观锁和悲观锁#悲观锁\",\"parentId\":\"20220421194023-puex63d\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/乐观锁和悲观锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5},{\"title\":\"乐观锁\",\"id\":\"20220421194023-5cy6qa6\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/乐观锁和悲观锁#乐观锁\",\"parentId\":\"20220421194023-puex63d\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/乐观锁和悲观锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5},{\"title\":\"典型案例\",\"id\":\"20220421194023-i4p0a7q\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/乐观锁和悲观锁#典型案例\",\"parentId\":\"20220421194023-puex63d\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/乐观锁和悲观锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[{\"title\":\"“汝之蜜糖,彼之砒霜”\",\"id\":\"20220421194023-f8m3kwp\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/乐观锁和悲观锁#“汝之蜜糖,彼之砒霜”\",\"parentId\":\"20220421194023-i4p0a7q\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/乐观锁和悲观锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":6}],\"level\":5},{\"title\":\"两种锁各自的使用场景\",\"id\":\"20220421194023-j635qa4\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/乐观锁和悲观锁#两种锁各自的使用场景\",\"parentId\":\"20220421194023-puex63d\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点/乐观锁和悲观锁\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁/锁的种类和特点\",\"children\":[],\"level\":5}],\"level\":4}],\"level\":3},{\"title\":\"JVM锁优化\",\"id\":\"20220421194023-mm3wc10\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/JVM锁优化\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/JVM锁优化\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"sort\":3,\"children\":[{\"title\":\"锁消除\",\"id\":\"20220421194023-2f7z9mm\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/JVM锁优化#锁消除\",\"parentId\":\"20220421194023-mm3wc10\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/JVM锁优化\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"锁粗化\",\"id\":\"20220421194023-fi45rtd\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/JVM锁优化#锁粗化\",\"parentId\":\"20220421194023-mm3wc10\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/JVM锁优化\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"自适应锁自旋\",\"id\":\"20220421194023-nvjn9oa\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/JVM锁优化#自适应锁自旋\",\"parentId\":\"20220421194023-mm3wc10\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/JVM锁优化\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"偏向锁/轻量级锁/重量级锁\",\"id\":\"20220421194023-vvlkzjy\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/JVM锁优化#偏向锁/轻量级锁/重量级锁\",\"parentId\":\"20220421194023-mm3wc10\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/JVM锁优化\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"synchronized加锁流程\",\"id\":\"20220421194023-1sgv6fy\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/JVM锁优化#synchronized加锁流程\",\"parentId\":\"20220421194023-mm3wc10\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/JVM锁优化\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"synchronized和Lock的对比\",\"id\":\"20220421194023-wyopjqc\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"sort\":4,\"children\":[{\"title\":\"相同点\",\"id\":\"20220421194023-e50jqat\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比#相同点\",\"parentId\":\"20220421194023-wyopjqc\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[{\"title\":\"用来保护资源安全\",\"id\":\"20220421194023-vhkm2qj\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比#用来保护资源安全\",\"parentId\":\"20220421194023-e50jqat\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":5},{\"title\":\"都可以保证可见性\",\"id\":\"20220421194023-kpu3pnr\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比#都可以保证可见性\",\"parentId\":\"20220421194023-e50jqat\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":5},{\"title\":\"都可重入\",\"id\":\"20220421194023-fj4p7u3\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比#都可重入\",\"parentId\":\"20220421194023-e50jqat\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"不同点\",\"id\":\"20220421194023-9ocihrd\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比#不同点\",\"parentId\":\"20220421194023-wyopjqc\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[{\"title\":\"用法不同\",\"id\":\"20220421194023-dl0g00i\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比#用法不同\",\"parentId\":\"20220421194023-9ocihrd\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":5},{\"title\":\"加解锁顺序不同\",\"id\":\"20220421194023-z0uqrwg\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比#加解锁顺序不同\",\"parentId\":\"20220421194023-9ocihrd\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":5},{\"title\":\"synchronized锁不够灵活\",\"id\":\"20220421194023-pmdkjn0\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比#synchronized锁不够灵活\",\"parentId\":\"20220421194023-9ocihrd\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":5},{\"title\":\"synchronized锁同时只能被一个线程拥有，Lock没有这个限制\",\"id\":\"20220421194023-nrovusq\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比#synchronized锁同时只能被一个线程拥有，Lock没有这个限制\",\"parentId\":\"20220421194023-9ocihrd\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":5},{\"title\":\"是否可以设置公平锁\",\"id\":\"20220421194023-jfaipd8\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比#是否可以设置公平锁\",\"parentId\":\"20220421194023-9ocihrd\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":5},{\"title\":\"性能区别\",\"id\":\"20220421194023-sv8z5a5\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比#性能区别\",\"parentId\":\"20220421194023-9ocihrd\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"如何选择\",\"id\":\"20220421194023-migtiov\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比#如何选择\",\"parentId\":\"20220421194023-wyopjqc\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/synchronized和Lock的对比\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"lock的常用方法\",\"id\":\"20220421194023-d5u43he\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"sort\":33,\"children\":[{\"title\":\"lock()\",\"id\":\"20220421194023-09n3cif\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法#lock()\",\"parentId\":\"20220421194023-d5u43he\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"tryLock()\",\"id\":\"20220421194023-fi99szk\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法#tryLock()\",\"parentId\":\"20220421194023-d5u43he\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"tryLock(long time, TimeUnit unit)\",\"id\":\"20220421194023-s7bytjl\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法#tryLock(long time, TimeUnit unit)\",\"parentId\":\"20220421194023-d5u43he\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"lockInterruptibly()\",\"id\":\"20220421194023-npz5jti\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法#lockInterruptibly()\",\"parentId\":\"20220421194023-d5u43he\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"unlock()\",\"id\":\"20220421194023-y6p4poo\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法#unlock()\",\"parentId\":\"20220421194023-d5u43he\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4},{\"title\":\"newCondition()\",\"id\":\"20220421194023-sughpnb\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法#newCondition()\",\"parentId\":\"20220421194023-d5u43he\",\"path\":\"/topic/Java并发工具包/并发工具/各种锁/lock的常用方法\",\"parentPath\":\"/topic/Java并发工具包/并发工具/各种锁\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2}],\"level\":1},{\"title\":\"底层原理\",\"id\":\"20220421225546-i01zemh\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/底层原理\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/底层原理\",\"parentPath\":\"/topic/Java并发工具包\",\"sort\":3,\"children\":[{\"title\":\"CAS原理\",\"id\":\"20220421194022-1yd15d4\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/底层原理/CAS原理\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/底层原理/CAS原理\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"sort\":1,\"children\":[{\"title\":\"CAS介绍\",\"id\":\"20220421194022-jdia9lk\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/CAS原理#CAS介绍\",\"parentId\":\"20220421194022-1yd15d4\",\"path\":\"/topic/Java并发工具包/底层原理/CAS原理\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":3},{\"title\":\"CAS的思路\",\"id\":\"20220421194022-fyvsc3v\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/CAS原理#CAS的思路\",\"parentId\":\"20220421194022-1yd15d4\",\"path\":\"/topic/Java并发工具包/底层原理/CAS原理\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":3},{\"title\":\"使用示例\",\"id\":\"20220421194022-3x34oxp\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/CAS原理#使用示例\",\"parentId\":\"20220421194022-1yd15d4\",\"path\":\"/topic/Java并发工具包/底层原理/CAS原理\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":3},{\"title\":\"CAS的问题\",\"id\":\"20220421194022-h6qtglq\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/CAS原理#CAS的问题\",\"parentId\":\"20220421194022-1yd15d4\",\"path\":\"/topic/Java并发工具包/底层原理/CAS原理\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[{\"title\":\"ABA问题\",\"id\":\"20220421194022-bag4cfb\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/CAS原理#ABA问题\",\"parentId\":\"20220421194022-h6qtglq\",\"path\":\"/topic/Java并发工具包/底层原理/CAS原理\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":4},{\"title\":\"循环时间长开销大\",\"id\":\"20220421194022-pttbrtt\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/CAS原理#循环时间长开销大\",\"parentId\":\"20220421194022-h6qtglq\",\"path\":\"/topic/Java并发工具包/底层原理/CAS原理\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":4},{\"title\":\"只能保证一个共享变量的原子操作\",\"id\":\"20220421194022-vta6rxb\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/CAS原理#只能保证一个共享变量的原子操作\",\"parentId\":\"20220421194022-h6qtglq\",\"path\":\"/topic/Java并发工具包/底层原理/CAS原理\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"AQS框架\",\"id\":\"20220421194022-1td53tx\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/底层原理/AQS框架\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/底层原理/AQS框架\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"sort\":2,\"children\":[{\"title\":\"模拟场景\",\"id\":\"20220421194022-n0uvyw8\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/AQS框架#模拟场景\",\"parentId\":\"20220421194022-1td53tx\",\"path\":\"/topic/Java并发工具包/底层原理/AQS框架\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":3},{\"title\":\"源码分析\",\"id\":\"20220421194022-7eiw7qv\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/AQS框架#源码分析\",\"parentId\":\"20220421194022-1td53tx\",\"path\":\"/topic/Java并发工具包/底层原理/AQS框架\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":3},{\"title\":\"获取锁流程\",\"id\":\"20220421194022-dtotqd0\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/AQS框架#获取锁流程\",\"parentId\":\"20220421194022-1td53tx\",\"path\":\"/topic/Java并发工具包/底层原理/AQS框架\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[{\"title\":\"用户A加锁\",\"id\":\"20220421194022-9rqlcvk\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/AQS框架#用户A加锁\",\"parentId\":\"20220421194022-dtotqd0\",\"path\":\"/topic/Java并发工具包/底层原理/AQS框架\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":4},{\"title\":\"用户B加锁\",\"id\":\"20220421194022-9b47tov\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/AQS框架#用户B加锁\",\"parentId\":\"20220421194022-dtotqd0\",\"path\":\"/topic/Java并发工具包/底层原理/AQS框架\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":4},{\"title\":\"用户C加锁\",\"id\":\"20220421194022-b6gyak4\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/AQS框架#用户C加锁\",\"parentId\":\"20220421194022-dtotqd0\",\"path\":\"/topic/Java并发工具包/底层原理/AQS框架\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"释放锁流程\",\"id\":\"20220421194022-taw90hy\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/AQS框架#释放锁流程\",\"parentId\":\"20220421194022-1td53tx\",\"path\":\"/topic/Java并发工具包/底层原理/AQS框架\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":3},{\"title\":\"总结\",\"id\":\"20220421194022-kghc8ld\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/AQS框架#总结\",\"parentId\":\"20220421194022-1td53tx\",\"path\":\"/topic/Java并发工具包/底层原理/AQS框架\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":3}],\"level\":2},{\"title\":\"伪共享\",\"id\":\"20220421194023-jhmtygl\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/底层原理/伪共享\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/底层原理/伪共享\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"sort\":3,\"children\":[{\"title\":\"什么是伪共享\",\"id\":\"20220421194023-ctrke5m\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/伪共享#什么是伪共享\",\"parentId\":\"20220421194023-jhmtygl\",\"path\":\"/topic/Java并发工具包/底层原理/伪共享\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":3},{\"title\":\"JVM中的伪共享\",\"id\":\"20220421194023-a71m3j6\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/伪共享#JVM中的伪共享\",\"parentId\":\"20220421194023-jhmtygl\",\"path\":\"/topic/Java并发工具包/底层原理/伪共享\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[{\"title\":\"如何避免\",\"id\":\"20220421194023-r09nmr8\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/伪共享#如何避免\",\"parentId\":\"20220421194023-a71m3j6\",\"path\":\"/topic/Java并发工具包/底层原理/伪共享\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2},{\"title\":\"java内存模型\",\"id\":\"20220421225623-ocb0581\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"parentPath\":\"/topic/Java并发工具包/底层原理\",\"sort\":4,\"children\":[{\"title\":\"Java内存模型介绍\",\"id\":\"20220421194023-dz3sn14\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/Java内存模型介绍\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/Java内存模型介绍\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"sort\":25,\"children\":[{\"title\":\"容易混淆的JVM内存结构和Java内存模型\",\"id\":\"20220421194023-ltidan3\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/Java内存模型介绍#容易混淆的JVM内存结构和Java内存模型\",\"parentId\":\"20220421194023-dz3sn14\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/Java内存模型介绍\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[{\"title\":\"JVM内存结构\",\"id\":\"20220421194023-hwhuzyc\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/Java内存模型介绍#JVM内存结构\",\"parentId\":\"20220421194023-ltidan3\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/Java内存模型介绍\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":5},{\"title\":\"JMM的引入\",\"id\":\"20220421194023-giug96m\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/Java内存模型介绍#JMM的引入\",\"parentId\":\"20220421194023-ltidan3\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/Java内存模型介绍\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":5},{\"title\":\"JMM的含义\",\"id\":\"20220421194023-k6l0xcb\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/Java内存模型介绍#JMM的含义\",\"parentId\":\"20220421194023-ltidan3\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/Java内存模型介绍\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"JMM与硬件结构的关系\",\"id\":\"20220421194023-s3ta3ij\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/Java内存模型介绍#JMM与硬件结构的关系\",\"parentId\":\"20220421194023-dz3sn14\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/Java内存模型介绍\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":4}],\"level\":3},{\"title\":\"happens-before规则\",\"id\":\"20220421194023-mz0fp6m\",\"type\":\"d\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentId\":\"\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"sort\":32,\"children\":[{\"title\":\"什么是happens_before关系\",\"id\":\"20220421194023-uxmg6t6\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则#什么是happens_before关系\",\"parentId\":\"20220421194023-mz0fp6m\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":4},{\"title\":\"不具备happens_before的例子\",\"id\":\"20220421194023-23izup0\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则#不具备happens_before的例子\",\"parentId\":\"20220421194023-mz0fp6m\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":4},{\"title\":\"happens_before的规则有哪些\",\"id\":\"20220421194023-y3ut2fh\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则#happens_before的规则有哪些\",\"parentId\":\"20220421194023-mz0fp6m\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[{\"title\":\"单线程规则\",\"id\":\"20220421194023-x980qnq\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则#单线程规则\",\"parentId\":\"20220421194023-y3ut2fh\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":5},{\"title\":\"锁操作规则\",\"id\":\"20220421194023-vgbv8gy\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则#锁操作规则\",\"parentId\":\"20220421194023-y3ut2fh\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":5},{\"title\":\"volatile变量规则\",\"id\":\"20220421194023-ktma0mi\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则#volatile变量规则\",\"parentId\":\"20220421194023-y3ut2fh\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":5},{\"title\":\"线程启动规则\",\"id\":\"20220421194023-gpfpqa2\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则#线程启动规则\",\"parentId\":\"20220421194023-y3ut2fh\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":5},{\"title\":\"线程join规则\",\"id\":\"20220421194023-xuf9tiy\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则#线程join规则\",\"parentId\":\"20220421194023-y3ut2fh\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":5},{\"title\":\"中断规则\",\"id\":\"20220421194023-c2tof50\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则#中断规则\",\"parentId\":\"20220421194023-y3ut2fh\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":5},{\"title\":\"并发工具类的规则\",\"id\":\"20220421194023-n42jz2g\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则#并发工具类的规则\",\"parentId\":\"20220421194023-y3ut2fh\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":5}],\"level\":4},{\"title\":\"总结\",\"id\":\"20220421194023-86u79bh\",\"type\":\"h\",\"href\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则#总结\",\"parentId\":\"20220421194023-mz0fp6m\",\"path\":\"/topic/Java并发工具包/底层原理/java内存模型/happens-before规则\",\"parentPath\":\"/topic/Java并发工具包/底层原理/java内存模型\",\"children\":[],\"level\":4}],\"level\":3}],\"level\":2}],\"level\":1}],\"level\":0}"}},"pageContext":{"slug":"/topic/Java并发工具包/并发工具/并发容器/ConcurrentHashMap详解","topic":"Java并发工具包"}},"staticQueryHashes":["1284643331","2841359383"]}