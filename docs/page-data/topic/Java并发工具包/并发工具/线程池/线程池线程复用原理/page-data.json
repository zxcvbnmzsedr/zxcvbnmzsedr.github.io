{
    "componentChunkName": "component---src-templates-topic-page-template-tsx",
    "path": "/topic/Java并发工具包/并发工具/线程池/线程池线程复用原理",
    "result": {"pageContext":{"id":"/topic/Java并发工具包/并发工具/线程池/线程池线程复用原理","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"线程池线程复用原理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"线程池最大的优势就在于可以复用线程，以减少创建和销毁时带来的消耗。线程池运行一堆固定数量的任务，需要的线程数远小于任务的数量，精髓就在于线程复用，让同一个线程去执行不同的任务。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%97%B6%E6%9C%BA.png","alt":"线程池创建线程的时机"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"依旧是这张图，我们能从中可以看到，有三个关键的地方"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"当前线程数小于核心线程数创建线程"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"核心线程数已满，就往任务队列里面塞"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"任务队列和核心线程都满了，就创建非核心线程用于分摊压力"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"当前三个都无法塞入的时候，拒绝执行"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"具体执行的代码在 ThreadPoolExecutor的execute中。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"实现方式"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"来看看是怎么实现的。(最核心的代码)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n  \t\t\t// ctl属性的高3位，提供了线程池的运行状态，包含线程池主要生命周期。\n  \t\t\t// 剩余位记录线程池线程个数\n        int c = ctl.get();\n  \t\t  // 如果工作线程的数量小于核心线程数 （步骤1）\n        if (workerCountOf(c) < corePoolSize) {\n          \t// 如果核心线程没有满，创建核心线程执行任务，如果返回false说明在创建核心线程的时候线程数已经满了\n            if (addWorker(command, true))\n                return;\n            c = ctl.get();\n        }\n  \t\t\t// 当前线程池的状态是正在运行，就把任务放入到队列中\n        if (isRunning(c) && workQueue.offer(command)) {\n            int recheck = ctl.get();\n          \t// 重新检查一番，如果这个时候线程池被关闭了，则从队列中移除这个任务，并执行拒绝策略\n            if (! isRunning(recheck) && remove(command))\n                reject(command);\n            else if (workerCountOf(recheck) == 0)\n              \t// 如果检查下来运行的线程数量为0，就调用addWorker创建新的线程\n                addWorker(null, false);\n        }\n  \t\t\t// 线程池关闭，或者队列已经满了，就去判断最大线程数是否满了，步骤3\n        else if (!addWorker(command, false))\n          \t// 最大线程数满了，执行拒绝策略\n            reject(command);\n    }\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"线程复用的秘密就是在这个addWorker里面。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"private boolean addWorker(Runnable firstTask, boolean core) {\n\t/**\n\t * 跳过上面一大段检查队列的直接看启动\n\t */\n   \t\t\tboolean workerStarted = false;\n        boolean workerAdded = false;\n        Worker w = null;\n        try {\n            w = new Worker(firstTask);\n            final Thread t = w.thread;\n          \t..... \n            if (t != null) {\n                // 加锁\n                if (workerAdded) {\n                  \t// 启动，\n                    t.start();\n                    workerStarted = true;\n                }\n            }\n        } finally {\n            if (! workerStarted)\n                addWorkerFailed(w);\n        }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"通过内置的Worker对象，把自己的firstTask作为任务封装进去，重写了run方法，所以在调用start方法的时候会调用的worker的run方法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"     public void run() {\n            runWorker(this);\n        }\nfinal void runWorker(Worker w) {\n        Thread wt = Thread.currentThread();\n        Runnable task = w.firstTask;\n        w.firstTask = null;\n        w.unlock(); // allow interrupts\n        boolean completedAbruptly = true;\n        try {\n          \t// 加个死循环，不断的从队列中获取任务，并执行----这里的task才是我们要执行的业务代码\n            while (task != null || (task = getTask()) != null) {\n                w.lock();\n                if ((runStateAtLeast(ctl.get(), STOP) ||\n                     (Thread.interrupted() &&\n                      runStateAtLeast(ctl.get(), STOP))) &&\n                    !wt.isInterrupted())\n                    wt.interrupt();\n                try {\n                    beforeExecute(wt, task);\n                    try {\n                        task.run();\n                        afterExecute(task, null);\n                    } catch (Throwable ex) {\n                        afterExecute(task, ex);\n                        throw ex;\n                    }\n                } finally {\n                    task = null;\n                    w.completedTasks++;\n                    w.unlock();\n                }\n            }\n            completedAbruptly = false;\n        } finally {\n            processWorkerExit(w, completedAbruptly);\n        }\n    }\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"总结"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"复用的本质，就是将我们的Runable给封装起来，封装成一个个task，塞入到队列中。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"然后使用worker线程，不断的轮训这个任务队列，直接执行，采用了代理模式，增强了原本runable的执行逻辑。"}]}],"data":{"quirksMode":false}},"headings":[{"depth":1,"value":"线程池线程复用原理","slug":"线程池线程复用原理"},{"depth":2,"value":"实现方式","slug":"实现方式"},{"depth":2,"value":"总结","slug":"总结-2"}]}},
    "staticQueryHashes": ["928362550"]}