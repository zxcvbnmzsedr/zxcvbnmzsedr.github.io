{
    "componentChunkName": "component---src-templates-topic-page-template-tsx",
    "path": "/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal内存泄漏",
    "result": {"pageContext":{"id":"/topic/Java并发工具包/并发工具/ThreadLocal/ThreadLocal内存泄漏","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"ThreadLocal内存泄漏"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"ThreadLocal的实现原理"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ThreadLocal的保存变量，是维护在Thread中的。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"但是由于每个线程在访问ThreadLocal对象之后，都会在Thread中的Map中留下ThreadLocal对象与具体实例的引用，如果不删除这些引用则这些ThreadLocal则不能进行回收，会造成内存泄漏"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/ThreadLocal.png","alt":"ThreadLocal"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://www.shiyitopo.tech/uPic/Cgq2xl5Pld-AHFhJAADLtGXmSxc833.png","alt":"img"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"内存泄漏的案例"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"网上有一段说明ThreadLocal内存泄漏非常好的代码。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"通过线程池去持有ThreadLocal对象，由于线程池的特性，线程被用完之后不会被释放。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"因此，总是存在<ThreadLocal,LocalVariable>的强引用，file static修饰的变量不会被释放，所以即使TreadLocalMap的key是弱引用，但由于强引用的存在，弱引用一直会有值，不会被GC回收。"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"内存泄漏的大小 = "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"核心线程数 * LocalVariable"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"public class ThreadLocalDemo {\n    static class LocalVariable {\n        private Long[] a = new Long[1024 * 1024];\n    }\n\n    // (1)\n    final static ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(5, 5, 1, TimeUnit.MINUTES,\n            new LinkedBlockingQueue<>());\n    // (2)\n    final static ThreadLocal<LocalVariable> localVariable = new ThreadLocal<LocalVariable>();\n\n    public static void main(String[] args) throws InterruptedException {\n        // (3)\n        Thread.sleep(5000 * 4);\n        for (int i = 0; i < 50; ++i) {\n            poolExecutor.execute(new Runnable() {\n                public void run() {\n                    // (4)\n                    localVariable.set(new LocalVariable());\n                    // (5)\n                    System.out.println(\"use local varaible\" + localVariable.get());\n                    localVariable.remove();\n                }\n            });\n        }\n        // (6)\n        System.out.println(\"pool execute over\");\n    }\n}\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"所以, 为了避免出现内存泄露的情况, ThreadLocal提供了一个清除线程中对象的方法, 即 remove, 其实内部实现就是调用 ThreadLocalMap 的remove方法"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-java"]},"children":[{"type":"text","value":"private void remove(ThreadLocal<?> key) {\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode & (len-1);\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        if (e.get() == key) {\n            e.clear();\n            expungeStaleEntry(i);\n            return;\n        }\n    }\n}\n\n"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"找到Key对应的Entry, 并且清除Entry的Key(ThreadLocal)置空, 随后清除过期的Entry即可避免内存泄露。"}]}],"data":{"quirksMode":false}},"headings":[{"depth":1,"value":"ThreadLocal内存泄漏","slug":"threadlocal内存泄漏"},{"depth":2,"value":"ThreadLocal的实现原理","slug":"threadlocal的实现原理"},{"depth":2,"value":"内存泄漏的案例","slug":"内存泄漏的案例"}]}},
    "staticQueryHashes": ["928362550"]}